
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model achievement
 * 
 */
export type achievement = $Result.DefaultSelection<Prisma.$achievementPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Operator
 * 
 */
export type Operator = $Result.DefaultSelection<Prisma.$OperatorPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model operatorgame
 * 
 */
export type operatorgame = $Result.DefaultSelection<Prisma.$operatorgamePayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model TwoFactor
 * 
 */
export type TwoFactor = $Result.DefaultSelection<Prisma.$TwoFactorPayload>
/**
 * Model chatmessage
 * 
 */
export type chatmessage = $Result.DefaultSelection<Prisma.$chatmessagePayload>
/**
 * Model chatroom
 * 
 */
export type chatroom = $Result.DefaultSelection<Prisma.$chatroomPayload>
/**
 * Model friendship
 * 
 */
export type friendship = $Result.DefaultSelection<Prisma.$friendshipPayload>
/**
 * Model gamesession
 * 
 */
export type gamesession = $Result.DefaultSelection<Prisma.$gamesessionPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model tournament
 * 
 */
export type tournament = $Result.DefaultSelection<Prisma.$tournamentPayload>
/**
 * Model tournamententry
 * 
 */
export type tournamententry = $Result.DefaultSelection<Prisma.$tournamententryPayload>
/**
 * Model tournamentgame
 * 
 */
export type tournamentgame = $Result.DefaultSelection<Prisma.$tournamentgamePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model userachievement
 * 
 */
export type userachievement = $Result.DefaultSelection<Prisma.$userachievementPayload>
/**
 * Model RainBet
 * 
 */
export type RainBet = $Result.DefaultSelection<Prisma.$RainBetPayload>
/**
 * Model RainHistory
 * 
 */
export type RainHistory = $Result.DefaultSelection<Prisma.$RainHistoryPayload>
/**
 * Model RainTip
 * 
 */
export type RainTip = $Result.DefaultSelection<Prisma.$RainTipPayload>
/**
 * Model RainWinner
 * 
 */
export type RainWinner = $Result.DefaultSelection<Prisma.$RainWinnerPayload>
/**
 * Model VipInfo
 * 
 */
export type VipInfo = $Result.DefaultSelection<Prisma.$VipInfoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ChatChannel: {
  LOBBY: 'LOBBY',
  GAME: 'GAME',
  TOURNAMENT: 'TOURNAMENT',
  PRIVATE: 'PRIVATE'
};

export type ChatChannel = (typeof ChatChannel)[keyof typeof ChatChannel]


export const FriendshipStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  BLOCKED: 'BLOCKED'
};

export type FriendshipStatus = (typeof FriendshipStatus)[keyof typeof FriendshipStatus]


export const Gender: {
  BOY: 'BOY',
  GIRL: 'GIRL',
  ALIEN: 'ALIEN',
  UNSURE: 'UNSURE',
  ROBOT: 'ROBOT',
  COMPLICATED: 'COMPLICATED'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  FRIEND_REQUEST: 'FRIEND_REQUEST',
  ACHIEVEMENT: 'ACHIEVEMENT',
  BALANCE_UPDATE: 'BALANCE_UPDATE',
  PROMOTIONAL: 'PROMOTIONAL',
  TOURNAMENT: 'TOURNAMENT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const TransactionType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAWAL: 'WITHDRAWAL',
  BET: 'BET',
  WIN: 'WIN',
  BONUS: 'BONUS',
  DONATION: 'DONATION',
  ADJUSTMENT: 'ADJUSTMENT',
  TOURNAMENT_BUYIN: 'TOURNAMENT_BUYIN',
  TOURNAMENT_PRIZE: 'TOURNAMENT_PRIZE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const GameCategory: {
  TABLE: 'TABLE',
  FISH: 'FISH',
  POKER: 'POKER',
  SLOTS: 'SLOTS',
  OTHER: 'OTHER'
};

export type GameCategory = (typeof GameCategory)[keyof typeof GameCategory]

}

export type ChatChannel = $Enums.ChatChannel

export const ChatChannel: typeof $Enums.ChatChannel

export type FriendshipStatus = $Enums.FriendshipStatus

export const FriendshipStatus: typeof $Enums.FriendshipStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type GameCategory = $Enums.GameCategory

export const GameCategory: typeof $Enums.GameCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Achievements
 * const achievements = await prisma.achievement.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Achievements
   * const achievements = await prisma.achievement.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.achievement`: Exposes CRUD operations for the **achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.achievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operator`: Exposes CRUD operations for the **Operator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operators
    * const operators = await prisma.operator.findMany()
    * ```
    */
  get operator(): Prisma.OperatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operatorgame`: Exposes CRUD operations for the **operatorgame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operatorgames
    * const operatorgames = await prisma.operatorgame.findMany()
    * ```
    */
  get operatorgame(): Prisma.operatorgameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twoFactor`: Exposes CRUD operations for the **TwoFactor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactors
    * const twoFactors = await prisma.twoFactor.findMany()
    * ```
    */
  get twoFactor(): Prisma.TwoFactorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatmessage`: Exposes CRUD operations for the **chatmessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatmessages
    * const chatmessages = await prisma.chatmessage.findMany()
    * ```
    */
  get chatmessage(): Prisma.chatmessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatroom`: Exposes CRUD operations for the **chatroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatrooms
    * const chatrooms = await prisma.chatroom.findMany()
    * ```
    */
  get chatroom(): Prisma.chatroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.friendshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gamesession`: Exposes CRUD operations for the **gamesession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gamesessions
    * const gamesessions = await prisma.gamesession.findMany()
    * ```
    */
  get gamesession(): Prisma.gamesessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournament`: Exposes CRUD operations for the **tournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournament.findMany()
    * ```
    */
  get tournament(): Prisma.tournamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamententry`: Exposes CRUD operations for the **tournamententry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournamententries
    * const tournamententries = await prisma.tournamententry.findMany()
    * ```
    */
  get tournamententry(): Prisma.tournamententryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamentgame`: Exposes CRUD operations for the **tournamentgame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournamentgames
    * const tournamentgames = await prisma.tournamentgame.findMany()
    * ```
    */
  get tournamentgame(): Prisma.tournamentgameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userachievement`: Exposes CRUD operations for the **userachievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userachievements
    * const userachievements = await prisma.userachievement.findMany()
    * ```
    */
  get userachievement(): Prisma.userachievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainBet`: Exposes CRUD operations for the **RainBet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainBets
    * const rainBets = await prisma.rainBet.findMany()
    * ```
    */
  get rainBet(): Prisma.RainBetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainHistory`: Exposes CRUD operations for the **RainHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainHistories
    * const rainHistories = await prisma.rainHistory.findMany()
    * ```
    */
  get rainHistory(): Prisma.RainHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainTip`: Exposes CRUD operations for the **RainTip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainTips
    * const rainTips = await prisma.rainTip.findMany()
    * ```
    */
  get rainTip(): Prisma.RainTipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainWinner`: Exposes CRUD operations for the **RainWinner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainWinners
    * const rainWinners = await prisma.rainWinner.findMany()
    * ```
    */
  get rainWinner(): Prisma.RainWinnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vipInfo`: Exposes CRUD operations for the **VipInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VipInfos
    * const vipInfos = await prisma.vipInfo.findMany()
    * ```
    */
  get vipInfo(): Prisma.VipInfoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    achievement: 'achievement',
    User: 'User',
    Session: 'Session',
    Operator: 'Operator',
    Message: 'Message',
    Profile: 'Profile',
    Game: 'Game',
    Account: 'Account',
    operatorgame: 'operatorgame',
    Verification: 'Verification',
    Organization: 'Organization',
    Member: 'Member',
    Invitation: 'Invitation',
    TwoFactor: 'TwoFactor',
    chatmessage: 'chatmessage',
    chatroom: 'chatroom',
    friendship: 'friendship',
    gamesession: 'gamesession',
    Product: 'Product',
    notification: 'notification',
    tournament: 'tournament',
    tournamententry: 'tournamententry',
    tournamentgame: 'tournamentgame',
    Transaction: 'Transaction',
    userachievement: 'userachievement',
    RainBet: 'RainBet',
    RainHistory: 'RainHistory',
    RainTip: 'RainTip',
    RainWinner: 'RainWinner',
    VipInfo: 'VipInfo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "achievement" | "user" | "session" | "operator" | "message" | "profile" | "game" | "account" | "operatorgame" | "verification" | "organization" | "member" | "invitation" | "twoFactor" | "chatmessage" | "chatroom" | "friendship" | "gamesession" | "product" | "notification" | "tournament" | "tournamententry" | "tournamentgame" | "transaction" | "userachievement" | "rainBet" | "rainHistory" | "rainTip" | "rainWinner" | "vipInfo"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      achievement: {
        payload: Prisma.$achievementPayload<ExtArgs>
        fields: Prisma.achievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.achievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.achievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          findFirst: {
            args: Prisma.achievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.achievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          findMany: {
            args: Prisma.achievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>[]
          }
          create: {
            args: Prisma.achievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          createMany: {
            args: Prisma.achievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.achievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>[]
          }
          delete: {
            args: Prisma.achievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          update: {
            args: Prisma.achievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          deleteMany: {
            args: Prisma.achievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.achievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.achievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>[]
          }
          upsert: {
            args: Prisma.achievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.achievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.achievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Operator: {
        payload: Prisma.$OperatorPayload<ExtArgs>
        fields: Prisma.OperatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          findFirst: {
            args: Prisma.OperatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          findMany: {
            args: Prisma.OperatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          create: {
            args: Prisma.OperatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          createMany: {
            args: Prisma.OperatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          delete: {
            args: Prisma.OperatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          update: {
            args: Prisma.OperatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          deleteMany: {
            args: Prisma.OperatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          upsert: {
            args: Prisma.OperatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          aggregate: {
            args: Prisma.OperatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperator>
          }
          groupBy: {
            args: Prisma.OperatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperatorCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      operatorgame: {
        payload: Prisma.$operatorgamePayload<ExtArgs>
        fields: Prisma.operatorgameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.operatorgameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.operatorgameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          findFirst: {
            args: Prisma.operatorgameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.operatorgameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          findMany: {
            args: Prisma.operatorgameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>[]
          }
          create: {
            args: Prisma.operatorgameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          createMany: {
            args: Prisma.operatorgameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.operatorgameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>[]
          }
          delete: {
            args: Prisma.operatorgameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          update: {
            args: Prisma.operatorgameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          deleteMany: {
            args: Prisma.operatorgameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.operatorgameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.operatorgameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>[]
          }
          upsert: {
            args: Prisma.operatorgameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          aggregate: {
            args: Prisma.OperatorgameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperatorgame>
          }
          groupBy: {
            args: Prisma.operatorgameGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorgameGroupByOutputType>[]
          }
          count: {
            args: Prisma.operatorgameCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorgameCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      TwoFactor: {
        payload: Prisma.$TwoFactorPayload<ExtArgs>
        fields: Prisma.TwoFactorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          findMany: {
            args: Prisma.TwoFactorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>[]
          }
          create: {
            args: Prisma.TwoFactorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          createMany: {
            args: Prisma.TwoFactorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwoFactorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>[]
          }
          delete: {
            args: Prisma.TwoFactorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          update: {
            args: Prisma.TwoFactorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TwoFactorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>[]
          }
          upsert: {
            args: Prisma.TwoFactorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactor>
          }
          groupBy: {
            args: Prisma.TwoFactorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorCountAggregateOutputType> | number
          }
        }
      }
      chatmessage: {
        payload: Prisma.$chatmessagePayload<ExtArgs>
        fields: Prisma.chatmessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatmessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatmessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          findFirst: {
            args: Prisma.chatmessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatmessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          findMany: {
            args: Prisma.chatmessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>[]
          }
          create: {
            args: Prisma.chatmessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          createMany: {
            args: Prisma.chatmessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatmessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>[]
          }
          delete: {
            args: Prisma.chatmessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          update: {
            args: Prisma.chatmessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          deleteMany: {
            args: Prisma.chatmessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatmessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatmessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>[]
          }
          upsert: {
            args: Prisma.chatmessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          aggregate: {
            args: Prisma.ChatmessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatmessage>
          }
          groupBy: {
            args: Prisma.chatmessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatmessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatmessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatmessageCountAggregateOutputType> | number
          }
        }
      }
      chatroom: {
        payload: Prisma.$chatroomPayload<ExtArgs>
        fields: Prisma.chatroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          findFirst: {
            args: Prisma.chatroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          findMany: {
            args: Prisma.chatroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          create: {
            args: Prisma.chatroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          createMany: {
            args: Prisma.chatroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          delete: {
            args: Prisma.chatroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          update: {
            args: Prisma.chatroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          deleteMany: {
            args: Prisma.chatroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          upsert: {
            args: Prisma.chatroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          aggregate: {
            args: Prisma.ChatroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatroom>
          }
          groupBy: {
            args: Prisma.chatroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatroomCountArgs<ExtArgs>
            result: $Utils.Optional<ChatroomCountAggregateOutputType> | number
          }
        }
      }
      friendship: {
        payload: Prisma.$friendshipPayload<ExtArgs>
        fields: Prisma.friendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.friendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.friendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          findFirst: {
            args: Prisma.friendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.friendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          findMany: {
            args: Prisma.friendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>[]
          }
          create: {
            args: Prisma.friendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          createMany: {
            args: Prisma.friendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.friendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>[]
          }
          delete: {
            args: Prisma.friendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          update: {
            args: Prisma.friendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          deleteMany: {
            args: Prisma.friendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.friendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.friendshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>[]
          }
          upsert: {
            args: Prisma.friendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.friendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.friendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      gamesession: {
        payload: Prisma.$gamesessionPayload<ExtArgs>
        fields: Prisma.gamesessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gamesessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gamesessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          findFirst: {
            args: Prisma.gamesessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gamesessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          findMany: {
            args: Prisma.gamesessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>[]
          }
          create: {
            args: Prisma.gamesessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          createMany: {
            args: Prisma.gamesessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.gamesessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>[]
          }
          delete: {
            args: Prisma.gamesessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          update: {
            args: Prisma.gamesessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          deleteMany: {
            args: Prisma.gamesessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gamesessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.gamesessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>[]
          }
          upsert: {
            args: Prisma.gamesessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          aggregate: {
            args: Prisma.GamesessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGamesession>
          }
          groupBy: {
            args: Prisma.gamesessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamesessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.gamesessionCountArgs<ExtArgs>
            result: $Utils.Optional<GamesessionCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      tournament: {
        payload: Prisma.$tournamentPayload<ExtArgs>
        fields: Prisma.tournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          findFirst: {
            args: Prisma.tournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          findMany: {
            args: Prisma.tournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>[]
          }
          create: {
            args: Prisma.tournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          createMany: {
            args: Prisma.tournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>[]
          }
          delete: {
            args: Prisma.tournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          update: {
            args: Prisma.tournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          deleteMany: {
            args: Prisma.tournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tournamentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>[]
          }
          upsert: {
            args: Prisma.tournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          aggregate: {
            args: Prisma.TournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament>
          }
          groupBy: {
            args: Prisma.tournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamentCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentCountAggregateOutputType> | number
          }
        }
      }
      tournamententry: {
        payload: Prisma.$tournamententryPayload<ExtArgs>
        fields: Prisma.tournamententryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamententryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamententryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          findFirst: {
            args: Prisma.tournamententryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamententryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          findMany: {
            args: Prisma.tournamententryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>[]
          }
          create: {
            args: Prisma.tournamententryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          createMany: {
            args: Prisma.tournamententryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamententryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>[]
          }
          delete: {
            args: Prisma.tournamententryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          update: {
            args: Prisma.tournamententryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          deleteMany: {
            args: Prisma.tournamententryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamententryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tournamententryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>[]
          }
          upsert: {
            args: Prisma.tournamententryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          aggregate: {
            args: Prisma.TournamententryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamententry>
          }
          groupBy: {
            args: Prisma.tournamententryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamententryGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamententryCountArgs<ExtArgs>
            result: $Utils.Optional<TournamententryCountAggregateOutputType> | number
          }
        }
      }
      tournamentgame: {
        payload: Prisma.$tournamentgamePayload<ExtArgs>
        fields: Prisma.tournamentgameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamentgameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamentgameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          findFirst: {
            args: Prisma.tournamentgameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamentgameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          findMany: {
            args: Prisma.tournamentgameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>[]
          }
          create: {
            args: Prisma.tournamentgameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          createMany: {
            args: Prisma.tournamentgameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamentgameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>[]
          }
          delete: {
            args: Prisma.tournamentgameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          update: {
            args: Prisma.tournamentgameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          deleteMany: {
            args: Prisma.tournamentgameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamentgameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tournamentgameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>[]
          }
          upsert: {
            args: Prisma.tournamentgameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          aggregate: {
            args: Prisma.TournamentgameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentgame>
          }
          groupBy: {
            args: Prisma.tournamentgameGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentgameGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamentgameCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentgameCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      userachievement: {
        payload: Prisma.$userachievementPayload<ExtArgs>
        fields: Prisma.userachievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userachievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userachievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          findFirst: {
            args: Prisma.userachievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userachievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          findMany: {
            args: Prisma.userachievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>[]
          }
          create: {
            args: Prisma.userachievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          createMany: {
            args: Prisma.userachievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userachievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>[]
          }
          delete: {
            args: Prisma.userachievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          update: {
            args: Prisma.userachievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          deleteMany: {
            args: Prisma.userachievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userachievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userachievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>[]
          }
          upsert: {
            args: Prisma.userachievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          aggregate: {
            args: Prisma.UserachievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserachievement>
          }
          groupBy: {
            args: Prisma.userachievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserachievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.userachievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserachievementCountAggregateOutputType> | number
          }
        }
      }
      RainBet: {
        payload: Prisma.$RainBetPayload<ExtArgs>
        fields: Prisma.RainBetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainBetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainBetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          findFirst: {
            args: Prisma.RainBetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainBetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          findMany: {
            args: Prisma.RainBetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>[]
          }
          create: {
            args: Prisma.RainBetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          createMany: {
            args: Prisma.RainBetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainBetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>[]
          }
          delete: {
            args: Prisma.RainBetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          update: {
            args: Prisma.RainBetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          deleteMany: {
            args: Prisma.RainBetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainBetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RainBetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>[]
          }
          upsert: {
            args: Prisma.RainBetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          aggregate: {
            args: Prisma.RainBetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainBet>
          }
          groupBy: {
            args: Prisma.RainBetGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainBetGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainBetCountArgs<ExtArgs>
            result: $Utils.Optional<RainBetCountAggregateOutputType> | number
          }
        }
      }
      RainHistory: {
        payload: Prisma.$RainHistoryPayload<ExtArgs>
        fields: Prisma.RainHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          findFirst: {
            args: Prisma.RainHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          findMany: {
            args: Prisma.RainHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>[]
          }
          create: {
            args: Prisma.RainHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          createMany: {
            args: Prisma.RainHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>[]
          }
          delete: {
            args: Prisma.RainHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          update: {
            args: Prisma.RainHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          deleteMany: {
            args: Prisma.RainHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RainHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>[]
          }
          upsert: {
            args: Prisma.RainHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          aggregate: {
            args: Prisma.RainHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainHistory>
          }
          groupBy: {
            args: Prisma.RainHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<RainHistoryCountAggregateOutputType> | number
          }
        }
      }
      RainTip: {
        payload: Prisma.$RainTipPayload<ExtArgs>
        fields: Prisma.RainTipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainTipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainTipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          findFirst: {
            args: Prisma.RainTipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainTipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          findMany: {
            args: Prisma.RainTipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>[]
          }
          create: {
            args: Prisma.RainTipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          createMany: {
            args: Prisma.RainTipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainTipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>[]
          }
          delete: {
            args: Prisma.RainTipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          update: {
            args: Prisma.RainTipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          deleteMany: {
            args: Prisma.RainTipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainTipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RainTipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>[]
          }
          upsert: {
            args: Prisma.RainTipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          aggregate: {
            args: Prisma.RainTipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainTip>
          }
          groupBy: {
            args: Prisma.RainTipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainTipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainTipCountArgs<ExtArgs>
            result: $Utils.Optional<RainTipCountAggregateOutputType> | number
          }
        }
      }
      RainWinner: {
        payload: Prisma.$RainWinnerPayload<ExtArgs>
        fields: Prisma.RainWinnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainWinnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainWinnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          findFirst: {
            args: Prisma.RainWinnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainWinnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          findMany: {
            args: Prisma.RainWinnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>[]
          }
          create: {
            args: Prisma.RainWinnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          createMany: {
            args: Prisma.RainWinnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainWinnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>[]
          }
          delete: {
            args: Prisma.RainWinnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          update: {
            args: Prisma.RainWinnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          deleteMany: {
            args: Prisma.RainWinnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainWinnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RainWinnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>[]
          }
          upsert: {
            args: Prisma.RainWinnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          aggregate: {
            args: Prisma.RainWinnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainWinner>
          }
          groupBy: {
            args: Prisma.RainWinnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainWinnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainWinnerCountArgs<ExtArgs>
            result: $Utils.Optional<RainWinnerCountAggregateOutputType> | number
          }
        }
      }
      VipInfo: {
        payload: Prisma.$VipInfoPayload<ExtArgs>
        fields: Prisma.VipInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VipInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VipInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          findFirst: {
            args: Prisma.VipInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VipInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          findMany: {
            args: Prisma.VipInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>[]
          }
          create: {
            args: Prisma.VipInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          createMany: {
            args: Prisma.VipInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VipInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>[]
          }
          delete: {
            args: Prisma.VipInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          update: {
            args: Prisma.VipInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          deleteMany: {
            args: Prisma.VipInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VipInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VipInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>[]
          }
          upsert: {
            args: Prisma.VipInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VipInfoPayload>
          }
          aggregate: {
            args: Prisma.VipInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVipInfo>
          }
          groupBy: {
            args: Prisma.VipInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VipInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VipInfoCountArgs<ExtArgs>
            result: $Utils.Optional<VipInfoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    achievement?: achievementOmit
    user?: UserOmit
    session?: SessionOmit
    operator?: OperatorOmit
    message?: MessageOmit
    profile?: ProfileOmit
    game?: GameOmit
    account?: AccountOmit
    operatorgame?: operatorgameOmit
    verification?: VerificationOmit
    organization?: OrganizationOmit
    member?: MemberOmit
    invitation?: InvitationOmit
    twoFactor?: TwoFactorOmit
    chatmessage?: chatmessageOmit
    chatroom?: chatroomOmit
    friendship?: friendshipOmit
    gamesession?: gamesessionOmit
    product?: ProductOmit
    notification?: notificationOmit
    tournament?: tournamentOmit
    tournamententry?: tournamententryOmit
    tournamentgame?: tournamentgameOmit
    transaction?: TransactionOmit
    userachievement?: userachievementOmit
    rainBet?: RainBetOmit
    rainHistory?: RainHistoryOmit
    rainTip?: RainTipOmit
    rainWinner?: RainWinnerOmit
    vipInfo?: VipInfoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userachievement: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userachievement?: boolean | AchievementCountOutputTypeCountUserachievementArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userachievementWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    members: number
    invitations: number
    twofactors: number
    RainBet: number
    RainHistory: number
    RainTip: number
    RainWinner: number
    chatmessage: number
    friendship_friendship_friendIdTouser: number
    friendship_friendship_userIdTouser: number
    notification: number
    operator: number
    activeProfile: number
    tournamententry: number
    userachievement: number
    vipInfo: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    members?: boolean | UserCountOutputTypeCountMembersArgs
    invitations?: boolean | UserCountOutputTypeCountInvitationsArgs
    twofactors?: boolean | UserCountOutputTypeCountTwofactorsArgs
    RainBet?: boolean | UserCountOutputTypeCountRainBetArgs
    RainHistory?: boolean | UserCountOutputTypeCountRainHistoryArgs
    RainTip?: boolean | UserCountOutputTypeCountRainTipArgs
    RainWinner?: boolean | UserCountOutputTypeCountRainWinnerArgs
    chatmessage?: boolean | UserCountOutputTypeCountChatmessageArgs
    friendship_friendship_friendIdTouser?: boolean | UserCountOutputTypeCountFriendship_friendship_friendIdTouserArgs
    friendship_friendship_userIdTouser?: boolean | UserCountOutputTypeCountFriendship_friendship_userIdTouserArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    operator?: boolean | UserCountOutputTypeCountOperatorArgs
    activeProfile?: boolean | UserCountOutputTypeCountActiveProfileArgs
    tournamententry?: boolean | UserCountOutputTypeCountTournamententryArgs
    userachievement?: boolean | UserCountOutputTypeCountUserachievementArgs
    vipInfo?: boolean | UserCountOutputTypeCountVipInfoArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTwofactorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendship_friendship_friendIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendship_friendship_userIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActiveProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamententryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userachievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVipInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipInfoWhereInput
  }


  /**
   * Count Type OperatorCountOutputType
   */

  export type OperatorCountOutputType = {
    games: number
    profiles: number
    tournaments: number
    Product: number
  }

  export type OperatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | OperatorCountOutputTypeCountGamesArgs
    profiles?: boolean | OperatorCountOutputTypeCountProfilesArgs
    tournaments?: boolean | OperatorCountOutputTypeCountTournamentsArgs
    Product?: boolean | OperatorCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCountOutputType
     */
    select?: OperatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountTournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    gamesession: number
    tournamententry: number
    transactions: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | ProfileCountOutputTypeCountGamesessionArgs
    tournamententry?: boolean | ProfileCountOutputTypeCountTournamententryArgs
    transactions?: boolean | ProfileCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesessionWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamententryWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    gamesession: number
    tournamentgame: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | GameCountOutputTypeCountGamesessionArgs
    tournamentgame?: boolean | GameCountOutputTypeCountTournamentgameArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesessionWhereInput
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountTournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentgameWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number
    invitations: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    invitations?: boolean | OrganizationCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * Count Type ChatroomCountOutputType
   */

  export type ChatroomCountOutputType = {
    chatmessage: number
  }

  export type ChatroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatmessage?: boolean | ChatroomCountOutputTypeCountChatmessageArgs
  }

  // Custom InputTypes
  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomCountOutputType
     */
    select?: ChatroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeCountChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
  }


  /**
   * Count Type GamesessionCountOutputType
   */

  export type GamesessionCountOutputType = {
    chatroom: number
    Transaction: number
  }

  export type GamesessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | GamesessionCountOutputTypeCountChatroomArgs
    Transaction?: boolean | GamesessionCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamesessionCountOutputType
     */
    select?: GamesessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeCountChatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatroomWhereInput
  }

  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    transactions: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ProductCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type TournamentCountOutputType
   */

  export type TournamentCountOutputType = {
    gamesession: number
    tournamententry: number
    tournamentgame: number
  }

  export type TournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | TournamentCountOutputTypeCountGamesessionArgs
    tournamententry?: boolean | TournamentCountOutputTypeCountTournamententryArgs
    tournamentgame?: boolean | TournamentCountOutputTypeCountTournamentgameArgs
  }

  // Custom InputTypes
  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentCountOutputType
     */
    select?: TournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesessionWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamententryWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountTournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentgameWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    Product: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | TransactionCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type RainHistoryCountOutputType
   */

  export type RainHistoryCountOutputType = {
    RainBet: number
    RainTip: number
    RainWinner: number
  }

  export type RainHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainBet?: boolean | RainHistoryCountOutputTypeCountRainBetArgs
    RainTip?: boolean | RainHistoryCountOutputTypeCountRainTipArgs
    RainWinner?: boolean | RainHistoryCountOutputTypeCountRainWinnerArgs
  }

  // Custom InputTypes
  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistoryCountOutputType
     */
    select?: RainHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    targetXp: number | null
    reward: number | null
  }

  export type AchievementSumAggregateOutputType = {
    targetXp: number | null
    reward: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    targetXp: number | null
    reward: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    targetXp: number | null
    reward: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    targetXp: number
    reward: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    targetXp?: true
    reward?: true
  }

  export type AchievementSumAggregateInputType = {
    targetXp?: true
    reward?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which achievement to aggregate.
     */
    where?: achievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementOrderByWithRelationInput | achievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: achievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type achievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: achievementWhereInput
    orderBy?: achievementOrderByWithAggregationInput | achievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: achievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string
    targetXp: number
    reward: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends achievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type achievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userachievement?: boolean | achievement$userachievementArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type achievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type achievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type achievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type achievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "targetXp" | "reward" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["achievement"]>
  export type achievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userachievement?: boolean | achievement$userachievementArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type achievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type achievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $achievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "achievement"
    objects: {
      userachievement: Prisma.$userachievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      targetXp: number
      reward: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type achievementGetPayload<S extends boolean | null | undefined | achievementDefaultArgs> = $Result.GetResult<Prisma.$achievementPayload, S>

  type achievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<achievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface achievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['achievement'], meta: { name: 'achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {achievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends achievementFindUniqueArgs>(args: SelectSubset<T, achievementFindUniqueArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {achievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends achievementFindUniqueOrThrowArgs>(args: SelectSubset<T, achievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends achievementFindFirstArgs>(args?: SelectSubset<T, achievementFindFirstArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends achievementFindFirstOrThrowArgs>(args?: SelectSubset<T, achievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends achievementFindManyArgs>(args?: SelectSubset<T, achievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {achievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends achievementCreateArgs>(args: SelectSubset<T, achievementCreateArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {achievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends achievementCreateManyArgs>(args?: SelectSubset<T, achievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {achievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends achievementCreateManyAndReturnArgs>(args?: SelectSubset<T, achievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {achievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends achievementDeleteArgs>(args: SelectSubset<T, achievementDeleteArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {achievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends achievementUpdateArgs>(args: SelectSubset<T, achievementUpdateArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {achievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends achievementDeleteManyArgs>(args?: SelectSubset<T, achievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends achievementUpdateManyArgs>(args: SelectSubset<T, achievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {achievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends achievementUpdateManyAndReturnArgs>(args: SelectSubset<T, achievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {achievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends achievementUpsertArgs>(args: SelectSubset<T, achievementUpsertArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends achievementCountArgs>(
      args?: Subset<T, achievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends achievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: achievementGroupByArgs['orderBy'] }
        : { orderBy?: achievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, achievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the achievement model
   */
  readonly fields: achievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__achievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userachievement<T extends achievement$userachievementArgs<ExtArgs> = {}>(args?: Subset<T, achievement$userachievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the achievement model
   */
  interface achievementFieldRefs {
    readonly id: FieldRef<"achievement", 'String'>
    readonly name: FieldRef<"achievement", 'String'>
    readonly description: FieldRef<"achievement", 'String'>
    readonly targetXp: FieldRef<"achievement", 'Int'>
    readonly reward: FieldRef<"achievement", 'Int'>
    readonly isActive: FieldRef<"achievement", 'Boolean'>
    readonly createdAt: FieldRef<"achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * achievement findUnique
   */
  export type achievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievement to fetch.
     */
    where: achievementWhereUniqueInput
  }

  /**
   * achievement findUniqueOrThrow
   */
  export type achievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievement to fetch.
     */
    where: achievementWhereUniqueInput
  }

  /**
   * achievement findFirst
   */
  export type achievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievement to fetch.
     */
    where?: achievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementOrderByWithRelationInput | achievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for achievements.
     */
    cursor?: achievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * achievement findFirstOrThrow
   */
  export type achievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievement to fetch.
     */
    where?: achievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementOrderByWithRelationInput | achievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for achievements.
     */
    cursor?: achievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * achievement findMany
   */
  export type achievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievements to fetch.
     */
    where?: achievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementOrderByWithRelationInput | achievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing achievements.
     */
    cursor?: achievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * achievement create
   */
  export type achievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * The data needed to create a achievement.
     */
    data: XOR<achievementCreateInput, achievementUncheckedCreateInput>
  }

  /**
   * achievement createMany
   */
  export type achievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many achievements.
     */
    data: achievementCreateManyInput | achievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * achievement createManyAndReturn
   */
  export type achievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * The data used to create many achievements.
     */
    data: achievementCreateManyInput | achievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * achievement update
   */
  export type achievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * The data needed to update a achievement.
     */
    data: XOR<achievementUpdateInput, achievementUncheckedUpdateInput>
    /**
     * Choose, which achievement to update.
     */
    where: achievementWhereUniqueInput
  }

  /**
   * achievement updateMany
   */
  export type achievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update achievements.
     */
    data: XOR<achievementUpdateManyMutationInput, achievementUncheckedUpdateManyInput>
    /**
     * Filter which achievements to update
     */
    where?: achievementWhereInput
    /**
     * Limit how many achievements to update.
     */
    limit?: number
  }

  /**
   * achievement updateManyAndReturn
   */
  export type achievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * The data used to update achievements.
     */
    data: XOR<achievementUpdateManyMutationInput, achievementUncheckedUpdateManyInput>
    /**
     * Filter which achievements to update
     */
    where?: achievementWhereInput
    /**
     * Limit how many achievements to update.
     */
    limit?: number
  }

  /**
   * achievement upsert
   */
  export type achievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * The filter to search for the achievement to update in case it exists.
     */
    where: achievementWhereUniqueInput
    /**
     * In case the achievement found by the `where` argument doesn't exist, create a new achievement with this data.
     */
    create: XOR<achievementCreateInput, achievementUncheckedCreateInput>
    /**
     * In case the achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<achievementUpdateInput, achievementUncheckedUpdateInput>
  }

  /**
   * achievement delete
   */
  export type achievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter which achievement to delete.
     */
    where: achievementWhereUniqueInput
  }

  /**
   * achievement deleteMany
   */
  export type achievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which achievements to delete
     */
    where?: achievementWhereInput
    /**
     * Limit how many achievements to delete.
     */
    limit?: number
  }

  /**
   * achievement.userachievement
   */
  export type achievement$userachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    where?: userachievementWhereInput
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    cursor?: userachievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * achievement without action
   */
  export type achievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    totalXp: number | null
    balance: number | null
    phpId: number | null
  }

  export type UserSumAggregateOutputType = {
    totalXp: number | null
    balance: number | null
    phpId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    username: string | null
    passwordHash: string | null
    totalXp: number | null
    balance: number | null
    isVerified: boolean | null
    active: boolean | null
    lastLogin: Date | null
    lastDailySpin: Date | null
    verificationToken: string | null
    avatar: string | null
    activeProfileId: string | null
    vipInfoId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    username: string | null
    passwordHash: string | null
    totalXp: number | null
    balance: number | null
    isVerified: boolean | null
    active: boolean | null
    lastLogin: Date | null
    lastDailySpin: Date | null
    verificationToken: string | null
    avatar: string | null
    activeProfileId: string | null
    vipInfoId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    twoFactorEnabled: number
    role: number
    banned: number
    banReason: number
    banExpires: number
    username: number
    passwordHash: number
    totalXp: number
    balance: number
    isVerified: number
    active: number
    lastLogin: number
    lastDailySpin: number
    verificationToken: number
    avatar: number
    activeProfileId: number
    vipInfoId: number
    gender: number
    status: number
    cashtag: number
    phpId: number
    accessToken: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    totalXp?: true
    balance?: true
    phpId?: true
  }

  export type UserSumAggregateInputType = {
    totalXp?: true
    balance?: true
    phpId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    username?: true
    passwordHash?: true
    totalXp?: true
    balance?: true
    isVerified?: true
    active?: true
    lastLogin?: true
    lastDailySpin?: true
    verificationToken?: true
    avatar?: true
    activeProfileId?: true
    vipInfoId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    username?: true
    passwordHash?: true
    totalXp?: true
    balance?: true
    isVerified?: true
    active?: true
    lastLogin?: true
    lastDailySpin?: true
    verificationToken?: true
    avatar?: true
    activeProfileId?: true
    vipInfoId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    twoFactorEnabled?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    username?: true
    passwordHash?: true
    totalXp?: true
    balance?: true
    isVerified?: true
    active?: true
    lastLogin?: true
    lastDailySpin?: true
    verificationToken?: true
    avatar?: true
    activeProfileId?: true
    vipInfoId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: boolean | null
    image: string | null
    createdAt: Date
    updatedAt: Date | null
    twoFactorEnabled: boolean | null
    role: string | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    username: string
    passwordHash: string | null
    totalXp: number
    balance: number
    isVerified: boolean
    active: boolean
    lastLogin: Date | null
    lastDailySpin: Date | null
    verificationToken: string | null
    avatar: string | null
    activeProfileId: string | null
    vipInfoId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    username?: boolean
    passwordHash?: boolean
    totalXp?: boolean
    balance?: boolean
    isVerified?: boolean
    active?: boolean
    lastLogin?: boolean
    lastDailySpin?: boolean
    verificationToken?: boolean
    avatar?: boolean
    activeProfileId?: boolean
    vipInfoId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    members?: boolean | User$membersArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    twofactors?: boolean | User$twofactorsArgs<ExtArgs>
    RainBet?: boolean | User$RainBetArgs<ExtArgs>
    RainHistory?: boolean | User$RainHistoryArgs<ExtArgs>
    RainTip?: boolean | User$RainTipArgs<ExtArgs>
    RainWinner?: boolean | User$RainWinnerArgs<ExtArgs>
    chatmessage?: boolean | User$chatmessageArgs<ExtArgs>
    friendship_friendship_friendIdTouser?: boolean | User$friendship_friendship_friendIdTouserArgs<ExtArgs>
    friendship_friendship_userIdTouser?: boolean | User$friendship_friendship_userIdTouserArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    operator?: boolean | User$operatorArgs<ExtArgs>
    activeProfile?: boolean | User$activeProfileArgs<ExtArgs>
    tournamententry?: boolean | User$tournamententryArgs<ExtArgs>
    userachievement?: boolean | User$userachievementArgs<ExtArgs>
    vipInfo?: boolean | User$vipInfoArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    username?: boolean
    passwordHash?: boolean
    totalXp?: boolean
    balance?: boolean
    isVerified?: boolean
    active?: boolean
    lastLogin?: boolean
    lastDailySpin?: boolean
    verificationToken?: boolean
    avatar?: boolean
    activeProfileId?: boolean
    vipInfoId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    username?: boolean
    passwordHash?: boolean
    totalXp?: boolean
    balance?: boolean
    isVerified?: boolean
    active?: boolean
    lastLogin?: boolean
    lastDailySpin?: boolean
    verificationToken?: boolean
    avatar?: boolean
    activeProfileId?: boolean
    vipInfoId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    twoFactorEnabled?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    username?: boolean
    passwordHash?: boolean
    totalXp?: boolean
    balance?: boolean
    isVerified?: boolean
    active?: boolean
    lastLogin?: boolean
    lastDailySpin?: boolean
    verificationToken?: boolean
    avatar?: boolean
    activeProfileId?: boolean
    vipInfoId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt" | "twoFactorEnabled" | "role" | "banned" | "banReason" | "banExpires" | "username" | "passwordHash" | "totalXp" | "balance" | "isVerified" | "active" | "lastLogin" | "lastDailySpin" | "verificationToken" | "avatar" | "activeProfileId" | "vipInfoId" | "gender" | "status" | "cashtag" | "phpId" | "accessToken", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    members?: boolean | User$membersArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    twofactors?: boolean | User$twofactorsArgs<ExtArgs>
    RainBet?: boolean | User$RainBetArgs<ExtArgs>
    RainHistory?: boolean | User$RainHistoryArgs<ExtArgs>
    RainTip?: boolean | User$RainTipArgs<ExtArgs>
    RainWinner?: boolean | User$RainWinnerArgs<ExtArgs>
    chatmessage?: boolean | User$chatmessageArgs<ExtArgs>
    friendship_friendship_friendIdTouser?: boolean | User$friendship_friendship_friendIdTouserArgs<ExtArgs>
    friendship_friendship_userIdTouser?: boolean | User$friendship_friendship_userIdTouserArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    operator?: boolean | User$operatorArgs<ExtArgs>
    activeProfile?: boolean | User$activeProfileArgs<ExtArgs>
    tournamententry?: boolean | User$tournamententryArgs<ExtArgs>
    userachievement?: boolean | User$userachievementArgs<ExtArgs>
    vipInfo?: boolean | User$vipInfoArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      members: Prisma.$MemberPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
      twofactors: Prisma.$TwoFactorPayload<ExtArgs>[]
      RainBet: Prisma.$RainBetPayload<ExtArgs>[]
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>[]
      RainTip: Prisma.$RainTipPayload<ExtArgs>[]
      RainWinner: Prisma.$RainWinnerPayload<ExtArgs>[]
      chatmessage: Prisma.$chatmessagePayload<ExtArgs>[]
      friendship_friendship_friendIdTouser: Prisma.$friendshipPayload<ExtArgs>[]
      friendship_friendship_userIdTouser: Prisma.$friendshipPayload<ExtArgs>[]
      notification: Prisma.$notificationPayload<ExtArgs>[]
      operator: Prisma.$OperatorPayload<ExtArgs>[]
      activeProfile: Prisma.$ProfilePayload<ExtArgs>[]
      tournamententry: Prisma.$tournamententryPayload<ExtArgs>[]
      userachievement: Prisma.$userachievementPayload<ExtArgs>[]
      vipInfo: Prisma.$VipInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: boolean | null
      image: string | null
      createdAt: Date
      updatedAt: Date | null
      twoFactorEnabled: boolean | null
      role: string | null
      banned: boolean | null
      banReason: string | null
      banExpires: Date | null
      username: string
      passwordHash: string | null
      totalXp: number
      balance: number
      isVerified: boolean
      active: boolean
      lastLogin: Date | null
      lastDailySpin: Date | null
      verificationToken: string | null
      avatar: string | null
      activeProfileId: string | null
      vipInfoId: string | null
      gender: $Enums.Gender | null
      status: $Enums.UserStatus | null
      cashtag: string | null
      phpId: number | null
      accessToken: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends User$membersArgs<ExtArgs> = {}>(args?: Subset<T, User$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends User$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    twofactors<T extends User$twofactorsArgs<ExtArgs> = {}>(args?: Subset<T, User$twofactorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainBet<T extends User$RainBetArgs<ExtArgs> = {}>(args?: Subset<T, User$RainBetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainHistory<T extends User$RainHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$RainHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainTip<T extends User$RainTipArgs<ExtArgs> = {}>(args?: Subset<T, User$RainTipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainWinner<T extends User$RainWinnerArgs<ExtArgs> = {}>(args?: Subset<T, User$RainWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatmessage<T extends User$chatmessageArgs<ExtArgs> = {}>(args?: Subset<T, User$chatmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendship_friendship_friendIdTouser<T extends User$friendship_friendship_friendIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, User$friendship_friendship_friendIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendship_friendship_userIdTouser<T extends User$friendship_friendship_userIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, User$friendship_friendship_userIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification<T extends User$notificationArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operator<T extends User$operatorArgs<ExtArgs> = {}>(args?: Subset<T, User$operatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activeProfile<T extends User$activeProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$activeProfileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamententry<T extends User$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, User$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userachievement<T extends User$userachievementArgs<ExtArgs> = {}>(args?: Subset<T, User$userachievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vipInfo<T extends User$vipInfoArgs<ExtArgs> = {}>(args?: Subset<T, User$vipInfoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly banned: FieldRef<"User", 'Boolean'>
    readonly banReason: FieldRef<"User", 'String'>
    readonly banExpires: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly totalXp: FieldRef<"User", 'Int'>
    readonly balance: FieldRef<"User", 'Int'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly lastDailySpin: FieldRef<"User", 'DateTime'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly activeProfileId: FieldRef<"User", 'String'>
    readonly vipInfoId: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly cashtag: FieldRef<"User", 'String'>
    readonly phpId: FieldRef<"User", 'Int'>
    readonly accessToken: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.members
   */
  export type User$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * User.invitations
   */
  export type User$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.twofactors
   */
  export type User$twofactorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    where?: TwoFactorWhereInput
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    cursor?: TwoFactorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * User.RainBet
   */
  export type User$RainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    cursor?: RainBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * User.RainHistory
   */
  export type User$RainHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    where?: RainHistoryWhereInput
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    cursor?: RainHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * User.RainTip
   */
  export type User$RainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    cursor?: RainTipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * User.RainWinner
   */
  export type User$RainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    cursor?: RainWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * User.chatmessage
   */
  export type User$chatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    cursor?: chatmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * User.friendship_friendship_friendIdTouser
   */
  export type User$friendship_friendship_friendIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    cursor?: friendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.friendship_friendship_userIdTouser
   */
  export type User$friendship_friendship_userIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    cursor?: friendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * User.notification
   */
  export type User$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.operator
   */
  export type User$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    where?: OperatorWhereInput
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    cursor?: OperatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * User.activeProfile
   */
  export type User$activeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * User.tournamententry
   */
  export type User$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    where?: tournamententryWhereInput
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    cursor?: tournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * User.userachievement
   */
  export type User$userachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    where?: userachievementWhereInput
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    cursor?: userachievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * User.vipInfo
   */
  export type User$vipInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    where?: VipInfoWhereInput
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    cursor?: VipInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VipInfoScalarFieldEnum | VipInfoScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    refreshToken: string | null
    active: boolean | null
    token: string | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    refreshToken: string | null
    active: boolean | null
    token: string | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    activeGameId: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    refreshToken: number
    active: number
    token: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
    token?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
    token?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
    token?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    refreshToken: string | null
    active: boolean
    token: string
    updatedAt: Date | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    token?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    token?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    token?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    token?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "activeGameId" | "ipAddress" | "userAgent" | "expiresAt" | "createdAt" | "refreshToken" | "active" | "token" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      activeGameId: string | null
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
      refreshToken: string | null
      active: boolean
      token: string
      updatedAt: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly activeGameId: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly active: FieldRef<"Session", 'Boolean'>
    readonly token: FieldRef<"Session", 'String'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Operator
   */

  export type AggregateOperator = {
    _count: OperatorCountAggregateOutputType | null
    _avg: OperatorAvgAggregateOutputType | null
    _sum: OperatorSumAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  export type OperatorAvgAggregateOutputType = {
    balance: number | null
  }

  export type OperatorSumAggregateOutputType = {
    balance: number | null
  }

  export type OperatorMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    balance: number | null
  }

  export type OperatorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    balance: number | null
  }

  export type OperatorCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    ownerId: number
    balance: number
    _all: number
  }


  export type OperatorAvgAggregateInputType = {
    balance?: true
  }

  export type OperatorSumAggregateInputType = {
    balance?: true
  }

  export type OperatorMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    balance?: true
  }

  export type OperatorMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    balance?: true
  }

  export type OperatorCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    balance?: true
    _all?: true
  }

  export type OperatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operator to aggregate.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operators
    **/
    _count?: true | OperatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorMaxAggregateInputType
  }

  export type GetOperatorAggregateType<T extends OperatorAggregateArgs> = {
        [P in keyof T & keyof AggregateOperator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperator[P]>
      : GetScalarType<T[P], AggregateOperator[P]>
  }




  export type OperatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorWhereInput
    orderBy?: OperatorOrderByWithAggregationInput | OperatorOrderByWithAggregationInput[]
    by: OperatorScalarFieldEnum[] | OperatorScalarFieldEnum
    having?: OperatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorCountAggregateInputType | true
    _avg?: OperatorAvgAggregateInputType
    _sum?: OperatorSumAggregateInputType
    _min?: OperatorMinAggregateInputType
    _max?: OperatorMaxAggregateInputType
  }

  export type OperatorGroupByOutputType = {
    id: string
    name: string
    slug: string
    logo: string | null
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    ownerId: string
    balance: number
    _count: OperatorCountAggregateOutputType | null
    _avg: OperatorAvgAggregateOutputType | null
    _sum: OperatorSumAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  type GetOperatorGroupByPayload<T extends OperatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorGroupByOutputType[P]>
        }
      >
    >


  export type OperatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    balance?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    games?: boolean | Operator$gamesArgs<ExtArgs>
    profiles?: boolean | Operator$profilesArgs<ExtArgs>
    tournaments?: boolean | Operator$tournamentsArgs<ExtArgs>
    Product?: boolean | Operator$ProductArgs<ExtArgs>
    _count?: boolean | OperatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    balance?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    balance?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    balance?: boolean
  }

  export type OperatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "logo" | "description" | "isActive" | "createdAt" | "updatedAt" | "ownerId" | "balance", ExtArgs["result"]["operator"]>
  export type OperatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    games?: boolean | Operator$gamesArgs<ExtArgs>
    profiles?: boolean | Operator$profilesArgs<ExtArgs>
    tournaments?: boolean | Operator$tournamentsArgs<ExtArgs>
    Product?: boolean | Operator$ProductArgs<ExtArgs>
    _count?: boolean | OperatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OperatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OperatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OperatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operator"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      games: Prisma.$GamePayload<ExtArgs>[]
      profiles: Prisma.$ProfilePayload<ExtArgs>[]
      tournaments: Prisma.$tournamentPayload<ExtArgs>[]
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logo: string | null
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
      ownerId: string
      balance: number
    }, ExtArgs["result"]["operator"]>
    composites: {}
  }

  type OperatorGetPayload<S extends boolean | null | undefined | OperatorDefaultArgs> = $Result.GetResult<Prisma.$OperatorPayload, S>

  type OperatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperatorCountAggregateInputType | true
    }

  export interface OperatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operator'], meta: { name: 'Operator' } }
    /**
     * Find zero or one Operator that matches the filter.
     * @param {OperatorFindUniqueArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatorFindUniqueArgs>(args: SelectSubset<T, OperatorFindUniqueArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Operator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperatorFindUniqueOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatorFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindFirstArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatorFindFirstArgs>(args?: SelectSubset<T, OperatorFindFirstArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindFirstOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatorFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operators
     * const operators = await prisma.operator.findMany()
     * 
     * // Get first 10 Operators
     * const operators = await prisma.operator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorWithIdOnly = await prisma.operator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatorFindManyArgs>(args?: SelectSubset<T, OperatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Operator.
     * @param {OperatorCreateArgs} args - Arguments to create a Operator.
     * @example
     * // Create one Operator
     * const Operator = await prisma.operator.create({
     *   data: {
     *     // ... data to create a Operator
     *   }
     * })
     * 
     */
    create<T extends OperatorCreateArgs>(args: SelectSubset<T, OperatorCreateArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Operators.
     * @param {OperatorCreateManyArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatorCreateManyArgs>(args?: SelectSubset<T, OperatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operators and returns the data saved in the database.
     * @param {OperatorCreateManyAndReturnArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operators and only return the `id`
     * const operatorWithIdOnly = await prisma.operator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperatorCreateManyAndReturnArgs>(args?: SelectSubset<T, OperatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Operator.
     * @param {OperatorDeleteArgs} args - Arguments to delete one Operator.
     * @example
     * // Delete one Operator
     * const Operator = await prisma.operator.delete({
     *   where: {
     *     // ... filter to delete one Operator
     *   }
     * })
     * 
     */
    delete<T extends OperatorDeleteArgs>(args: SelectSubset<T, OperatorDeleteArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Operator.
     * @param {OperatorUpdateArgs} args - Arguments to update one Operator.
     * @example
     * // Update one Operator
     * const operator = await prisma.operator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatorUpdateArgs>(args: SelectSubset<T, OperatorUpdateArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Operators.
     * @param {OperatorDeleteManyArgs} args - Arguments to filter Operators to delete.
     * @example
     * // Delete a few Operators
     * const { count } = await prisma.operator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatorDeleteManyArgs>(args?: SelectSubset<T, OperatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operators
     * const operator = await prisma.operator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatorUpdateManyArgs>(args: SelectSubset<T, OperatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators and returns the data updated in the database.
     * @param {OperatorUpdateManyAndReturnArgs} args - Arguments to update many Operators.
     * @example
     * // Update many Operators
     * const operator = await prisma.operator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operators and only return the `id`
     * const operatorWithIdOnly = await prisma.operator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperatorUpdateManyAndReturnArgs>(args: SelectSubset<T, OperatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Operator.
     * @param {OperatorUpsertArgs} args - Arguments to update or create a Operator.
     * @example
     * // Update or create a Operator
     * const operator = await prisma.operator.upsert({
     *   create: {
     *     // ... data to create a Operator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operator we want to update
     *   }
     * })
     */
    upsert<T extends OperatorUpsertArgs>(args: SelectSubset<T, OperatorUpsertArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCountArgs} args - Arguments to filter Operators to count.
     * @example
     * // Count the number of Operators
     * const count = await prisma.operator.count({
     *   where: {
     *     // ... the filter for the Operators we want to count
     *   }
     * })
    **/
    count<T extends OperatorCountArgs>(
      args?: Subset<T, OperatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorAggregateArgs>(args: Subset<T, OperatorAggregateArgs>): Prisma.PrismaPromise<GetOperatorAggregateType<T>>

    /**
     * Group by Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatorGroupByArgs['orderBy'] }
        : { orderBy?: OperatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operator model
   */
  readonly fields: OperatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    games<T extends Operator$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Operator$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profiles<T extends Operator$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Operator$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournaments<T extends Operator$tournamentsArgs<ExtArgs> = {}>(args?: Subset<T, Operator$tournamentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Product<T extends Operator$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Operator$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Operator model
   */
  interface OperatorFieldRefs {
    readonly id: FieldRef<"Operator", 'String'>
    readonly name: FieldRef<"Operator", 'String'>
    readonly slug: FieldRef<"Operator", 'String'>
    readonly logo: FieldRef<"Operator", 'String'>
    readonly description: FieldRef<"Operator", 'String'>
    readonly isActive: FieldRef<"Operator", 'Boolean'>
    readonly createdAt: FieldRef<"Operator", 'DateTime'>
    readonly updatedAt: FieldRef<"Operator", 'DateTime'>
    readonly ownerId: FieldRef<"Operator", 'String'>
    readonly balance: FieldRef<"Operator", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Operator findUnique
   */
  export type OperatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator findUniqueOrThrow
   */
  export type OperatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator findFirst
   */
  export type OperatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator findFirstOrThrow
   */
  export type OperatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator findMany
   */
  export type OperatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter, which Operators to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator create
   */
  export type OperatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Operator.
     */
    data: XOR<OperatorCreateInput, OperatorUncheckedCreateInput>
  }

  /**
   * Operator createMany
   */
  export type OperatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operators.
     */
    data: OperatorCreateManyInput | OperatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operator createManyAndReturn
   */
  export type OperatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * The data used to create many Operators.
     */
    data: OperatorCreateManyInput | OperatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operator update
   */
  export type OperatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Operator.
     */
    data: XOR<OperatorUpdateInput, OperatorUncheckedUpdateInput>
    /**
     * Choose, which Operator to update.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator updateMany
   */
  export type OperatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operators.
     */
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyInput>
    /**
     * Filter which Operators to update
     */
    where?: OperatorWhereInput
    /**
     * Limit how many Operators to update.
     */
    limit?: number
  }

  /**
   * Operator updateManyAndReturn
   */
  export type OperatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * The data used to update Operators.
     */
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyInput>
    /**
     * Filter which Operators to update
     */
    where?: OperatorWhereInput
    /**
     * Limit how many Operators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Operator upsert
   */
  export type OperatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Operator to update in case it exists.
     */
    where: OperatorWhereUniqueInput
    /**
     * In case the Operator found by the `where` argument doesn't exist, create a new Operator with this data.
     */
    create: XOR<OperatorCreateInput, OperatorUncheckedCreateInput>
    /**
     * In case the Operator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatorUpdateInput, OperatorUncheckedUpdateInput>
  }

  /**
   * Operator delete
   */
  export type OperatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    /**
     * Filter which Operator to delete.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator deleteMany
   */
  export type OperatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operators to delete
     */
    where?: OperatorWhereInput
    /**
     * Limit how many Operators to delete.
     */
    limit?: number
  }

  /**
   * Operator.games
   */
  export type Operator$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Operator.profiles
   */
  export type Operator$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Operator.tournaments
   */
  export type Operator$tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    where?: tournamentWhereInput
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    cursor?: tournamentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Operator.Product
   */
  export type Operator$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Operator without action
   */
  export type OperatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    authorId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    authorId: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt" | "authorId", ExtArgs["result"]["message"]>

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
      authorId: string
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly authorId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    balance: number | null
    xpEarned: number | null
    phpId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    balance: number | null
    xpEarned: number | null
    phpId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    balance: number | null
    xpEarned: number | null
    isActive: boolean | null
    lastPlayed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    phpId: number | null
    userId: string | null
    currency: string | null
    shopId: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    balance: number | null
    xpEarned: number | null
    isActive: boolean | null
    lastPlayed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    phpId: number | null
    userId: string | null
    currency: string | null
    shopId: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    balance: number
    xpEarned: number
    isActive: number
    lastPlayed: number
    createdAt: number
    updatedAt: number
    phpId: number
    userId: number
    currency: number
    shopId: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    balance?: true
    xpEarned?: true
    phpId?: true
  }

  export type ProfileSumAggregateInputType = {
    balance?: true
    xpEarned?: true
    phpId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    currency?: true
    shopId?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    currency?: true
    shopId?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    currency?: true
    shopId?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    balance: number
    xpEarned: number
    isActive: boolean
    lastPlayed: Date | null
    createdAt: Date
    updatedAt: Date | null
    phpId: number | null
    userId: string
    currency: string
    shopId: string
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    currency?: boolean
    shopId?: boolean
    gamesession?: boolean | Profile$gamesessionArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
    tournamententry?: boolean | Profile$tournamententryArgs<ExtArgs>
    transactions?: boolean | Profile$transactionsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    currency?: boolean
    shopId?: boolean
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    currency?: boolean
    shopId?: boolean
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    currency?: boolean
    shopId?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "balance" | "xpEarned" | "isActive" | "lastPlayed" | "createdAt" | "updatedAt" | "phpId" | "userId" | "currency" | "shopId", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | Profile$gamesessionArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
    tournamententry?: boolean | Profile$tournamententryArgs<ExtArgs>
    transactions?: boolean | Profile$transactionsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      gamesession: Prisma.$gamesessionPayload<ExtArgs>[]
      operator: Prisma.$OperatorPayload<ExtArgs>
      user_profile_userIdTouser: Prisma.$UserPayload<ExtArgs>
      tournamententry: Prisma.$tournamententryPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      balance: number
      xpEarned: number
      isActive: boolean
      lastPlayed: Date | null
      createdAt: Date
      updatedAt: Date | null
      phpId: number | null
      userId: string
      currency: string
      shopId: string
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends Profile$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, Profile$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operator<T extends OperatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperatorDefaultArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user_profile_userIdTouser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournamententry<T extends Profile$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, Profile$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Profile$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly balance: FieldRef<"Profile", 'Int'>
    readonly xpEarned: FieldRef<"Profile", 'Int'>
    readonly isActive: FieldRef<"Profile", 'Boolean'>
    readonly lastPlayed: FieldRef<"Profile", 'DateTime'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly phpId: FieldRef<"Profile", 'Int'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly currency: FieldRef<"Profile", 'String'>
    readonly shopId: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.gamesession
   */
  export type Profile$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    cursor?: gamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * Profile.tournamententry
   */
  export type Profile$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    where?: tournamententryWhereInput
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    cursor?: tournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * Profile.transactions
   */
  export type Profile$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    vipLevel: number | null
    device: number | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    rezerv: number | null
    cask: number | null
    view: number | null
  }

  export type GameSumAggregateOutputType = {
    vipLevel: number | null
    device: number | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    rezerv: number | null
    cask: number | null
    view: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    temperature: string | null
    developer: string | null
    vipLevel: number | null
    isActive: boolean | null
    device: number | null
    featured: boolean | null
    gamebank: string | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    linesPercentConfigSpin: string | null
    linesPercentConfigSpinBonus: string | null
    linesPercentConfigBonus: string | null
    linesPercentConfigBonusBonus: string | null
    rezerv: number | null
    cask: number | null
    advanced: string | null
    scaleMode: string | null
    slotViewState: string | null
    view: number | null
    categoryId: string | null
    operatorId: string | null
    providerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    category: $Enums.GameCategory | null
    jackpotGroupId: string | null
    active: boolean | null
    password: string | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    title: string | null
    temperature: string | null
    developer: string | null
    vipLevel: number | null
    isActive: boolean | null
    device: number | null
    featured: boolean | null
    gamebank: string | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    linesPercentConfigSpin: string | null
    linesPercentConfigSpinBonus: string | null
    linesPercentConfigBonus: string | null
    linesPercentConfigBonusBonus: string | null
    rezerv: number | null
    cask: number | null
    advanced: string | null
    scaleMode: string | null
    slotViewState: string | null
    view: number | null
    categoryId: string | null
    operatorId: string | null
    providerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    category: $Enums.GameCategory | null
    jackpotGroupId: string | null
    active: boolean | null
    password: string | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    name: number
    title: number
    temperature: number
    developer: number
    vipLevel: number
    isActive: number
    device: number
    featured: number
    gamebank: number
    bet: number
    denomination: number
    categoryTemp: number
    originalId: number
    bids: number
    statIn: number
    statOut: number
    currentRtp: number
    rtpStatIn: number
    rtpStatOut: number
    standardRtp: number
    popularity: number
    chanceFirepot1: number
    chanceFirepot2: number
    chanceFirepot3: number
    fireCount1: number
    fireCount2: number
    fireCount3: number
    linesPercentConfigSpin: number
    linesPercentConfigSpinBonus: number
    linesPercentConfigBonus: number
    linesPercentConfigBonusBonus: number
    rezerv: number
    cask: number
    advanced: number
    scaleMode: number
    slotViewState: number
    view: number
    categoryId: number
    operatorId: number
    providerId: number
    createdAt: number
    updatedAt: number
    category: number
    jackpotGroupId: number
    active: number
    password: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    vipLevel?: true
    device?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    rezerv?: true
    cask?: true
    view?: true
  }

  export type GameSumAggregateInputType = {
    vipLevel?: true
    device?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    rezerv?: true
    cask?: true
    view?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    name?: true
    title?: true
    temperature?: true
    developer?: true
    vipLevel?: true
    isActive?: true
    device?: true
    featured?: true
    gamebank?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    linesPercentConfigSpin?: true
    linesPercentConfigSpinBonus?: true
    linesPercentConfigBonus?: true
    linesPercentConfigBonusBonus?: true
    rezerv?: true
    cask?: true
    advanced?: true
    scaleMode?: true
    slotViewState?: true
    view?: true
    categoryId?: true
    operatorId?: true
    providerId?: true
    createdAt?: true
    updatedAt?: true
    category?: true
    jackpotGroupId?: true
    active?: true
    password?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    name?: true
    title?: true
    temperature?: true
    developer?: true
    vipLevel?: true
    isActive?: true
    device?: true
    featured?: true
    gamebank?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    linesPercentConfigSpin?: true
    linesPercentConfigSpinBonus?: true
    linesPercentConfigBonus?: true
    linesPercentConfigBonusBonus?: true
    rezerv?: true
    cask?: true
    advanced?: true
    scaleMode?: true
    slotViewState?: true
    view?: true
    categoryId?: true
    operatorId?: true
    providerId?: true
    createdAt?: true
    updatedAt?: true
    category?: true
    jackpotGroupId?: true
    active?: true
    password?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    name?: true
    title?: true
    temperature?: true
    developer?: true
    vipLevel?: true
    isActive?: true
    device?: true
    featured?: true
    gamebank?: true
    bet?: true
    denomination?: true
    categoryTemp?: true
    originalId?: true
    bids?: true
    statIn?: true
    statOut?: true
    currentRtp?: true
    rtpStatIn?: true
    rtpStatOut?: true
    standardRtp?: true
    popularity?: true
    chanceFirepot1?: true
    chanceFirepot2?: true
    chanceFirepot3?: true
    fireCount1?: true
    fireCount2?: true
    fireCount3?: true
    linesPercentConfigSpin?: true
    linesPercentConfigSpinBonus?: true
    linesPercentConfigBonus?: true
    linesPercentConfigBonusBonus?: true
    rezerv?: true
    cask?: true
    advanced?: true
    scaleMode?: true
    slotViewState?: true
    view?: true
    categoryId?: true
    operatorId?: true
    providerId?: true
    createdAt?: true
    updatedAt?: true
    category?: true
    jackpotGroupId?: true
    active?: true
    password?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    name: string
    title: string
    temperature: string | null
    developer: string | null
    vipLevel: number | null
    isActive: boolean | null
    device: number | null
    featured: boolean | null
    gamebank: string | null
    bet: number | null
    denomination: number | null
    categoryTemp: number | null
    originalId: number | null
    bids: number | null
    statIn: number | null
    statOut: number | null
    currentRtp: number | null
    rtpStatIn: number | null
    rtpStatOut: number | null
    standardRtp: number | null
    popularity: number | null
    chanceFirepot1: number | null
    chanceFirepot2: number | null
    chanceFirepot3: number | null
    fireCount1: number | null
    fireCount2: number | null
    fireCount3: number | null
    linesPercentConfigSpin: string | null
    linesPercentConfigSpinBonus: string | null
    linesPercentConfigBonus: string | null
    linesPercentConfigBonusBonus: string | null
    rezerv: number | null
    cask: number | null
    advanced: string | null
    scaleMode: string
    slotViewState: string
    view: number | null
    categoryId: string | null
    operatorId: string | null
    providerId: string | null
    createdAt: Date
    updatedAt: Date
    category: $Enums.GameCategory
    jackpotGroupId: string | null
    active: boolean
    password: string | null
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    temperature?: boolean
    developer?: boolean
    vipLevel?: boolean
    isActive?: boolean
    device?: boolean
    featured?: boolean
    gamebank?: boolean
    bet?: boolean
    denomination?: boolean
    categoryTemp?: boolean
    originalId?: boolean
    bids?: boolean
    statIn?: boolean
    statOut?: boolean
    currentRtp?: boolean
    rtpStatIn?: boolean
    rtpStatOut?: boolean
    standardRtp?: boolean
    popularity?: boolean
    chanceFirepot1?: boolean
    chanceFirepot2?: boolean
    chanceFirepot3?: boolean
    fireCount1?: boolean
    fireCount2?: boolean
    fireCount3?: boolean
    linesPercentConfigSpin?: boolean
    linesPercentConfigSpinBonus?: boolean
    linesPercentConfigBonus?: boolean
    linesPercentConfigBonusBonus?: boolean
    rezerv?: boolean
    cask?: boolean
    advanced?: boolean
    scaleMode?: boolean
    slotViewState?: boolean
    view?: boolean
    categoryId?: boolean
    operatorId?: boolean
    providerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean
    jackpotGroupId?: boolean
    active?: boolean
    password?: boolean
    operator?: boolean | Game$operatorArgs<ExtArgs>
    gamesession?: boolean | Game$gamesessionArgs<ExtArgs>
    tournamentgame?: boolean | Game$tournamentgameArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    temperature?: boolean
    developer?: boolean
    vipLevel?: boolean
    isActive?: boolean
    device?: boolean
    featured?: boolean
    gamebank?: boolean
    bet?: boolean
    denomination?: boolean
    categoryTemp?: boolean
    originalId?: boolean
    bids?: boolean
    statIn?: boolean
    statOut?: boolean
    currentRtp?: boolean
    rtpStatIn?: boolean
    rtpStatOut?: boolean
    standardRtp?: boolean
    popularity?: boolean
    chanceFirepot1?: boolean
    chanceFirepot2?: boolean
    chanceFirepot3?: boolean
    fireCount1?: boolean
    fireCount2?: boolean
    fireCount3?: boolean
    linesPercentConfigSpin?: boolean
    linesPercentConfigSpinBonus?: boolean
    linesPercentConfigBonus?: boolean
    linesPercentConfigBonusBonus?: boolean
    rezerv?: boolean
    cask?: boolean
    advanced?: boolean
    scaleMode?: boolean
    slotViewState?: boolean
    view?: boolean
    categoryId?: boolean
    operatorId?: boolean
    providerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean
    jackpotGroupId?: boolean
    active?: boolean
    password?: boolean
    operator?: boolean | Game$operatorArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    title?: boolean
    temperature?: boolean
    developer?: boolean
    vipLevel?: boolean
    isActive?: boolean
    device?: boolean
    featured?: boolean
    gamebank?: boolean
    bet?: boolean
    denomination?: boolean
    categoryTemp?: boolean
    originalId?: boolean
    bids?: boolean
    statIn?: boolean
    statOut?: boolean
    currentRtp?: boolean
    rtpStatIn?: boolean
    rtpStatOut?: boolean
    standardRtp?: boolean
    popularity?: boolean
    chanceFirepot1?: boolean
    chanceFirepot2?: boolean
    chanceFirepot3?: boolean
    fireCount1?: boolean
    fireCount2?: boolean
    fireCount3?: boolean
    linesPercentConfigSpin?: boolean
    linesPercentConfigSpinBonus?: boolean
    linesPercentConfigBonus?: boolean
    linesPercentConfigBonusBonus?: boolean
    rezerv?: boolean
    cask?: boolean
    advanced?: boolean
    scaleMode?: boolean
    slotViewState?: boolean
    view?: boolean
    categoryId?: boolean
    operatorId?: boolean
    providerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean
    jackpotGroupId?: boolean
    active?: boolean
    password?: boolean
    operator?: boolean | Game$operatorArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    name?: boolean
    title?: boolean
    temperature?: boolean
    developer?: boolean
    vipLevel?: boolean
    isActive?: boolean
    device?: boolean
    featured?: boolean
    gamebank?: boolean
    bet?: boolean
    denomination?: boolean
    categoryTemp?: boolean
    originalId?: boolean
    bids?: boolean
    statIn?: boolean
    statOut?: boolean
    currentRtp?: boolean
    rtpStatIn?: boolean
    rtpStatOut?: boolean
    standardRtp?: boolean
    popularity?: boolean
    chanceFirepot1?: boolean
    chanceFirepot2?: boolean
    chanceFirepot3?: boolean
    fireCount1?: boolean
    fireCount2?: boolean
    fireCount3?: boolean
    linesPercentConfigSpin?: boolean
    linesPercentConfigSpinBonus?: boolean
    linesPercentConfigBonus?: boolean
    linesPercentConfigBonusBonus?: boolean
    rezerv?: boolean
    cask?: boolean
    advanced?: boolean
    scaleMode?: boolean
    slotViewState?: boolean
    view?: boolean
    categoryId?: boolean
    operatorId?: boolean
    providerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean
    jackpotGroupId?: boolean
    active?: boolean
    password?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "title" | "temperature" | "developer" | "vipLevel" | "isActive" | "device" | "featured" | "gamebank" | "bet" | "denomination" | "categoryTemp" | "originalId" | "bids" | "statIn" | "statOut" | "currentRtp" | "rtpStatIn" | "rtpStatOut" | "standardRtp" | "popularity" | "chanceFirepot1" | "chanceFirepot2" | "chanceFirepot3" | "fireCount1" | "fireCount2" | "fireCount3" | "linesPercentConfigSpin" | "linesPercentConfigSpinBonus" | "linesPercentConfigBonus" | "linesPercentConfigBonusBonus" | "rezerv" | "cask" | "advanced" | "scaleMode" | "slotViewState" | "view" | "categoryId" | "operatorId" | "providerId" | "createdAt" | "updatedAt" | "category" | "jackpotGroupId" | "active" | "password", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Game$operatorArgs<ExtArgs>
    gamesession?: boolean | Game$gamesessionArgs<ExtArgs>
    tournamentgame?: boolean | Game$tournamentgameArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Game$operatorArgs<ExtArgs>
  }
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Game$operatorArgs<ExtArgs>
  }

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      operator: Prisma.$OperatorPayload<ExtArgs> | null
      gamesession: Prisma.$gamesessionPayload<ExtArgs>[]
      tournamentgame: Prisma.$tournamentgamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      title: string
      temperature: string | null
      developer: string | null
      vipLevel: number | null
      isActive: boolean | null
      device: number | null
      featured: boolean | null
      gamebank: string | null
      bet: number | null
      denomination: number | null
      categoryTemp: number | null
      originalId: number | null
      bids: number | null
      statIn: number | null
      statOut: number | null
      currentRtp: number | null
      rtpStatIn: number | null
      rtpStatOut: number | null
      standardRtp: number | null
      popularity: number | null
      chanceFirepot1: number | null
      chanceFirepot2: number | null
      chanceFirepot3: number | null
      fireCount1: number | null
      fireCount2: number | null
      fireCount3: number | null
      linesPercentConfigSpin: string | null
      linesPercentConfigSpinBonus: string | null
      linesPercentConfigBonus: string | null
      linesPercentConfigBonusBonus: string | null
      rezerv: number | null
      cask: number | null
      advanced: string | null
      scaleMode: string
      slotViewState: string
      view: number | null
      categoryId: string | null
      operatorId: string | null
      providerId: string | null
      createdAt: Date
      updatedAt: Date
      category: $Enums.GameCategory
      jackpotGroupId: string | null
      active: boolean
      password: string | null
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operator<T extends Game$operatorArgs<ExtArgs> = {}>(args?: Subset<T, Game$operatorArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    gamesession<T extends Game$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, Game$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamentgame<T extends Game$tournamentgameArgs<ExtArgs> = {}>(args?: Subset<T, Game$tournamentgameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly name: FieldRef<"Game", 'String'>
    readonly title: FieldRef<"Game", 'String'>
    readonly temperature: FieldRef<"Game", 'String'>
    readonly developer: FieldRef<"Game", 'String'>
    readonly vipLevel: FieldRef<"Game", 'Int'>
    readonly isActive: FieldRef<"Game", 'Boolean'>
    readonly device: FieldRef<"Game", 'Int'>
    readonly featured: FieldRef<"Game", 'Boolean'>
    readonly gamebank: FieldRef<"Game", 'String'>
    readonly bet: FieldRef<"Game", 'Float'>
    readonly denomination: FieldRef<"Game", 'Float'>
    readonly categoryTemp: FieldRef<"Game", 'Float'>
    readonly originalId: FieldRef<"Game", 'Int'>
    readonly bids: FieldRef<"Game", 'Int'>
    readonly statIn: FieldRef<"Game", 'Float'>
    readonly statOut: FieldRef<"Game", 'Float'>
    readonly currentRtp: FieldRef<"Game", 'Float'>
    readonly rtpStatIn: FieldRef<"Game", 'Float'>
    readonly rtpStatOut: FieldRef<"Game", 'Float'>
    readonly standardRtp: FieldRef<"Game", 'Float'>
    readonly popularity: FieldRef<"Game", 'Float'>
    readonly chanceFirepot1: FieldRef<"Game", 'Float'>
    readonly chanceFirepot2: FieldRef<"Game", 'Float'>
    readonly chanceFirepot3: FieldRef<"Game", 'Float'>
    readonly fireCount1: FieldRef<"Game", 'Float'>
    readonly fireCount2: FieldRef<"Game", 'Float'>
    readonly fireCount3: FieldRef<"Game", 'Float'>
    readonly linesPercentConfigSpin: FieldRef<"Game", 'String'>
    readonly linesPercentConfigSpinBonus: FieldRef<"Game", 'String'>
    readonly linesPercentConfigBonus: FieldRef<"Game", 'String'>
    readonly linesPercentConfigBonusBonus: FieldRef<"Game", 'String'>
    readonly rezerv: FieldRef<"Game", 'Float'>
    readonly cask: FieldRef<"Game", 'Float'>
    readonly advanced: FieldRef<"Game", 'String'>
    readonly scaleMode: FieldRef<"Game", 'String'>
    readonly slotViewState: FieldRef<"Game", 'String'>
    readonly view: FieldRef<"Game", 'Int'>
    readonly categoryId: FieldRef<"Game", 'String'>
    readonly operatorId: FieldRef<"Game", 'String'>
    readonly providerId: FieldRef<"Game", 'String'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
    readonly category: FieldRef<"Game", 'GameCategory'>
    readonly jackpotGroupId: FieldRef<"Game", 'String'>
    readonly active: FieldRef<"Game", 'Boolean'>
    readonly password: FieldRef<"Game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game.operator
   */
  export type Game$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    where?: OperatorWhereInput
  }

  /**
   * Game.gamesession
   */
  export type Game$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    cursor?: gamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * Game.tournamentgame
   */
  export type Game$tournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    where?: tournamentgameWhereInput
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    cursor?: tournamentgameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date | null
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model operatorgame
   */

  export type AggregateOperatorgame = {
    _count: OperatorgameCountAggregateOutputType | null
    _avg: OperatorgameAvgAggregateOutputType | null
    _sum: OperatorgameSumAggregateOutputType | null
    _min: OperatorgameMinAggregateOutputType | null
    _max: OperatorgameMaxAggregateOutputType | null
  }

  export type OperatorgameAvgAggregateOutputType = {
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number | null
  }

  export type OperatorgameSumAggregateOutputType = {
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number | null
  }

  export type OperatorgameMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    thumbnail: string | null
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number | null
    isActive: boolean | null
    isPromoted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type OperatorgameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    thumbnail: string | null
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number | null
    isActive: boolean | null
    isPromoted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type OperatorgameCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    thumbnail: number
    minBet: number
    maxBet: number
    xpMultiplier: number
    isActive: number
    isPromoted: number
    createdAt: number
    updatedAt: number
    operatorId: number
    _all: number
  }


  export type OperatorgameAvgAggregateInputType = {
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
  }

  export type OperatorgameSumAggregateInputType = {
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
  }

  export type OperatorgameMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type OperatorgameMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type OperatorgameCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
    _all?: true
  }

  export type OperatorgameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operatorgame to aggregate.
     */
    where?: operatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operatorgames to fetch.
     */
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operatorgames
    **/
    _count?: true | OperatorgameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatorgameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatorgameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorgameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorgameMaxAggregateInputType
  }

  export type GetOperatorgameAggregateType<T extends OperatorgameAggregateArgs> = {
        [P in keyof T & keyof AggregateOperatorgame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperatorgame[P]>
      : GetScalarType<T[P], AggregateOperatorgame[P]>
  }




  export type operatorgameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operatorgameWhereInput
    orderBy?: operatorgameOrderByWithAggregationInput | operatorgameOrderByWithAggregationInput[]
    by: OperatorgameScalarFieldEnum[] | OperatorgameScalarFieldEnum
    having?: operatorgameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorgameCountAggregateInputType | true
    _avg?: OperatorgameAvgAggregateInputType
    _sum?: OperatorgameSumAggregateInputType
    _min?: OperatorgameMinAggregateInputType
    _max?: OperatorgameMaxAggregateInputType
  }

  export type OperatorgameGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    thumbnail: string | null
    minBet: number | null
    maxBet: number | null
    xpMultiplier: number
    isActive: boolean
    isPromoted: boolean
    createdAt: Date
    updatedAt: Date | null
    operatorId: string
    _count: OperatorgameCountAggregateOutputType | null
    _avg: OperatorgameAvgAggregateOutputType | null
    _sum: OperatorgameSumAggregateOutputType | null
    _min: OperatorgameMinAggregateOutputType | null
    _max: OperatorgameMaxAggregateOutputType | null
  }

  type GetOperatorgameGroupByPayload<T extends operatorgameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorgameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorgameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorgameGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorgameGroupByOutputType[P]>
        }
      >
    >


  export type operatorgameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
  }, ExtArgs["result"]["operatorgame"]>

  export type operatorgameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
  }, ExtArgs["result"]["operatorgame"]>

  export type operatorgameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
  }, ExtArgs["result"]["operatorgame"]>

  export type operatorgameSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
  }

  export type operatorgameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "thumbnail" | "minBet" | "maxBet" | "xpMultiplier" | "isActive" | "isPromoted" | "createdAt" | "updatedAt" | "operatorId", ExtArgs["result"]["operatorgame"]>

  export type $operatorgamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "operatorgame"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      thumbnail: string | null
      minBet: number | null
      maxBet: number | null
      xpMultiplier: number
      isActive: boolean
      isPromoted: boolean
      createdAt: Date
      updatedAt: Date | null
      operatorId: string
    }, ExtArgs["result"]["operatorgame"]>
    composites: {}
  }

  type operatorgameGetPayload<S extends boolean | null | undefined | operatorgameDefaultArgs> = $Result.GetResult<Prisma.$operatorgamePayload, S>

  type operatorgameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<operatorgameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperatorgameCountAggregateInputType | true
    }

  export interface operatorgameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operatorgame'], meta: { name: 'operatorgame' } }
    /**
     * Find zero or one Operatorgame that matches the filter.
     * @param {operatorgameFindUniqueArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends operatorgameFindUniqueArgs>(args: SelectSubset<T, operatorgameFindUniqueArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Operatorgame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {operatorgameFindUniqueOrThrowArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends operatorgameFindUniqueOrThrowArgs>(args: SelectSubset<T, operatorgameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operatorgame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameFindFirstArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends operatorgameFindFirstArgs>(args?: SelectSubset<T, operatorgameFindFirstArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operatorgame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameFindFirstOrThrowArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends operatorgameFindFirstOrThrowArgs>(args?: SelectSubset<T, operatorgameFindFirstOrThrowArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Operatorgames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operatorgames
     * const operatorgames = await prisma.operatorgame.findMany()
     * 
     * // Get first 10 Operatorgames
     * const operatorgames = await prisma.operatorgame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorgameWithIdOnly = await prisma.operatorgame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends operatorgameFindManyArgs>(args?: SelectSubset<T, operatorgameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Operatorgame.
     * @param {operatorgameCreateArgs} args - Arguments to create a Operatorgame.
     * @example
     * // Create one Operatorgame
     * const Operatorgame = await prisma.operatorgame.create({
     *   data: {
     *     // ... data to create a Operatorgame
     *   }
     * })
     * 
     */
    create<T extends operatorgameCreateArgs>(args: SelectSubset<T, operatorgameCreateArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Operatorgames.
     * @param {operatorgameCreateManyArgs} args - Arguments to create many Operatorgames.
     * @example
     * // Create many Operatorgames
     * const operatorgame = await prisma.operatorgame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends operatorgameCreateManyArgs>(args?: SelectSubset<T, operatorgameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operatorgames and returns the data saved in the database.
     * @param {operatorgameCreateManyAndReturnArgs} args - Arguments to create many Operatorgames.
     * @example
     * // Create many Operatorgames
     * const operatorgame = await prisma.operatorgame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operatorgames and only return the `id`
     * const operatorgameWithIdOnly = await prisma.operatorgame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends operatorgameCreateManyAndReturnArgs>(args?: SelectSubset<T, operatorgameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Operatorgame.
     * @param {operatorgameDeleteArgs} args - Arguments to delete one Operatorgame.
     * @example
     * // Delete one Operatorgame
     * const Operatorgame = await prisma.operatorgame.delete({
     *   where: {
     *     // ... filter to delete one Operatorgame
     *   }
     * })
     * 
     */
    delete<T extends operatorgameDeleteArgs>(args: SelectSubset<T, operatorgameDeleteArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Operatorgame.
     * @param {operatorgameUpdateArgs} args - Arguments to update one Operatorgame.
     * @example
     * // Update one Operatorgame
     * const operatorgame = await prisma.operatorgame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends operatorgameUpdateArgs>(args: SelectSubset<T, operatorgameUpdateArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Operatorgames.
     * @param {operatorgameDeleteManyArgs} args - Arguments to filter Operatorgames to delete.
     * @example
     * // Delete a few Operatorgames
     * const { count } = await prisma.operatorgame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends operatorgameDeleteManyArgs>(args?: SelectSubset<T, operatorgameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operatorgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operatorgames
     * const operatorgame = await prisma.operatorgame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends operatorgameUpdateManyArgs>(args: SelectSubset<T, operatorgameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operatorgames and returns the data updated in the database.
     * @param {operatorgameUpdateManyAndReturnArgs} args - Arguments to update many Operatorgames.
     * @example
     * // Update many Operatorgames
     * const operatorgame = await prisma.operatorgame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operatorgames and only return the `id`
     * const operatorgameWithIdOnly = await prisma.operatorgame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends operatorgameUpdateManyAndReturnArgs>(args: SelectSubset<T, operatorgameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Operatorgame.
     * @param {operatorgameUpsertArgs} args - Arguments to update or create a Operatorgame.
     * @example
     * // Update or create a Operatorgame
     * const operatorgame = await prisma.operatorgame.upsert({
     *   create: {
     *     // ... data to create a Operatorgame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operatorgame we want to update
     *   }
     * })
     */
    upsert<T extends operatorgameUpsertArgs>(args: SelectSubset<T, operatorgameUpsertArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Operatorgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameCountArgs} args - Arguments to filter Operatorgames to count.
     * @example
     * // Count the number of Operatorgames
     * const count = await prisma.operatorgame.count({
     *   where: {
     *     // ... the filter for the Operatorgames we want to count
     *   }
     * })
    **/
    count<T extends operatorgameCountArgs>(
      args?: Subset<T, operatorgameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorgameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operatorgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorgameAggregateArgs>(args: Subset<T, OperatorgameAggregateArgs>): Prisma.PrismaPromise<GetOperatorgameAggregateType<T>>

    /**
     * Group by Operatorgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operatorgameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operatorgameGroupByArgs['orderBy'] }
        : { orderBy?: operatorgameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operatorgameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorgameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the operatorgame model
   */
  readonly fields: operatorgameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for operatorgame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__operatorgameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the operatorgame model
   */
  interface operatorgameFieldRefs {
    readonly id: FieldRef<"operatorgame", 'String'>
    readonly name: FieldRef<"operatorgame", 'String'>
    readonly slug: FieldRef<"operatorgame", 'String'>
    readonly description: FieldRef<"operatorgame", 'String'>
    readonly thumbnail: FieldRef<"operatorgame", 'String'>
    readonly minBet: FieldRef<"operatorgame", 'Int'>
    readonly maxBet: FieldRef<"operatorgame", 'Int'>
    readonly xpMultiplier: FieldRef<"operatorgame", 'Float'>
    readonly isActive: FieldRef<"operatorgame", 'Boolean'>
    readonly isPromoted: FieldRef<"operatorgame", 'Boolean'>
    readonly createdAt: FieldRef<"operatorgame", 'DateTime'>
    readonly updatedAt: FieldRef<"operatorgame", 'DateTime'>
    readonly operatorId: FieldRef<"operatorgame", 'String'>
  }
    

  // Custom InputTypes
  /**
   * operatorgame findUnique
   */
  export type operatorgameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Filter, which operatorgame to fetch.
     */
    where: operatorgameWhereUniqueInput
  }

  /**
   * operatorgame findUniqueOrThrow
   */
  export type operatorgameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Filter, which operatorgame to fetch.
     */
    where: operatorgameWhereUniqueInput
  }

  /**
   * operatorgame findFirst
   */
  export type operatorgameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Filter, which operatorgame to fetch.
     */
    where?: operatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operatorgames to fetch.
     */
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operatorgames.
     */
    cursor?: operatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operatorgames.
     */
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * operatorgame findFirstOrThrow
   */
  export type operatorgameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Filter, which operatorgame to fetch.
     */
    where?: operatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operatorgames to fetch.
     */
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operatorgames.
     */
    cursor?: operatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operatorgames.
     */
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * operatorgame findMany
   */
  export type operatorgameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Filter, which operatorgames to fetch.
     */
    where?: operatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operatorgames to fetch.
     */
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operatorgames.
     */
    cursor?: operatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operatorgames.
     */
    skip?: number
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * operatorgame create
   */
  export type operatorgameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * The data needed to create a operatorgame.
     */
    data: XOR<operatorgameCreateInput, operatorgameUncheckedCreateInput>
  }

  /**
   * operatorgame createMany
   */
  export type operatorgameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operatorgames.
     */
    data: operatorgameCreateManyInput | operatorgameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * operatorgame createManyAndReturn
   */
  export type operatorgameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * The data used to create many operatorgames.
     */
    data: operatorgameCreateManyInput | operatorgameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * operatorgame update
   */
  export type operatorgameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * The data needed to update a operatorgame.
     */
    data: XOR<operatorgameUpdateInput, operatorgameUncheckedUpdateInput>
    /**
     * Choose, which operatorgame to update.
     */
    where: operatorgameWhereUniqueInput
  }

  /**
   * operatorgame updateMany
   */
  export type operatorgameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operatorgames.
     */
    data: XOR<operatorgameUpdateManyMutationInput, operatorgameUncheckedUpdateManyInput>
    /**
     * Filter which operatorgames to update
     */
    where?: operatorgameWhereInput
    /**
     * Limit how many operatorgames to update.
     */
    limit?: number
  }

  /**
   * operatorgame updateManyAndReturn
   */
  export type operatorgameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * The data used to update operatorgames.
     */
    data: XOR<operatorgameUpdateManyMutationInput, operatorgameUncheckedUpdateManyInput>
    /**
     * Filter which operatorgames to update
     */
    where?: operatorgameWhereInput
    /**
     * Limit how many operatorgames to update.
     */
    limit?: number
  }

  /**
   * operatorgame upsert
   */
  export type operatorgameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * The filter to search for the operatorgame to update in case it exists.
     */
    where: operatorgameWhereUniqueInput
    /**
     * In case the operatorgame found by the `where` argument doesn't exist, create a new operatorgame with this data.
     */
    create: XOR<operatorgameCreateInput, operatorgameUncheckedCreateInput>
    /**
     * In case the operatorgame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operatorgameUpdateInput, operatorgameUncheckedUpdateInput>
  }

  /**
   * operatorgame delete
   */
  export type operatorgameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Filter which operatorgame to delete.
     */
    where: operatorgameWhereUniqueInput
  }

  /**
   * operatorgame deleteMany
   */
  export type operatorgameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operatorgames to delete
     */
    where?: operatorgameWhereInput
    /**
     * Limit how many operatorgames to delete.
     */
    limit?: number
  }

  /**
   * operatorgame without action
   */
  export type operatorgameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    createdAt: Date | null
    metadata: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    createdAt: Date | null
    metadata: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string | null
    logo: string | null
    createdAt: Date
    metadata: string | null
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
    members?: boolean | Organization$membersArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    createdAt?: boolean
    metadata?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "logo" | "createdAt" | "metadata", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Organization$membersArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      members: Prisma.$MemberPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string | null
      logo: string | null
      createdAt: Date
      metadata: string | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Organization$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly metadata: FieldRef<"Organization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Organization.invitations
   */
  export type Organization$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    role: number
    createdAt: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "role" | "createdAt", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      userId: string
      role: string
      createdAt: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'String'>
    readonly organizationId: FieldRef<"Member", 'String'>
    readonly userId: FieldRef<"Member", 'String'>
    readonly role: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    role: string | null
    status: string | null
    expiresAt: Date | null
    inviterId: string | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    email: string | null
    role: string | null
    status: string | null
    expiresAt: Date | null
    inviterId: string | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    organizationId: number
    email: number
    role: number
    status: number
    expiresAt: number
    inviterId: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    organizationId?: true
    email?: true
    role?: true
    status?: true
    expiresAt?: true
    inviterId?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    organizationId: string
    email: string
    role: string | null
    status: string
    expiresAt: Date
    inviterId: string
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    email?: boolean
    role?: boolean
    status?: boolean
    expiresAt?: boolean
    inviterId?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "email" | "role" | "status" | "expiresAt" | "inviterId", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      email: string
      role: string | null
      status: string
      expiresAt: Date
      inviterId: string
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly organizationId: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly role: FieldRef<"Invitation", 'String'>
    readonly status: FieldRef<"Invitation", 'String'>
    readonly expiresAt: FieldRef<"Invitation", 'DateTime'>
    readonly inviterId: FieldRef<"Invitation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model TwoFactor
   */

  export type AggregateTwoFactor = {
    _count: TwoFactorCountAggregateOutputType | null
    _min: TwoFactorMinAggregateOutputType | null
    _max: TwoFactorMaxAggregateOutputType | null
  }

  export type TwoFactorMinAggregateOutputType = {
    id: string | null
    secret: string | null
    backupCodes: string | null
    userId: string | null
  }

  export type TwoFactorMaxAggregateOutputType = {
    id: string | null
    secret: string | null
    backupCodes: string | null
    userId: string | null
  }

  export type TwoFactorCountAggregateOutputType = {
    id: number
    secret: number
    backupCodes: number
    userId: number
    _all: number
  }


  export type TwoFactorMinAggregateInputType = {
    id?: true
    secret?: true
    backupCodes?: true
    userId?: true
  }

  export type TwoFactorMaxAggregateInputType = {
    id?: true
    secret?: true
    backupCodes?: true
    userId?: true
  }

  export type TwoFactorCountAggregateInputType = {
    id?: true
    secret?: true
    backupCodes?: true
    userId?: true
    _all?: true
  }

  export type TwoFactorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactor to aggregate.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactors
    **/
    _count?: true | TwoFactorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorMaxAggregateInputType
  }

  export type GetTwoFactorAggregateType<T extends TwoFactorAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactor[P]>
      : GetScalarType<T[P], AggregateTwoFactor[P]>
  }




  export type TwoFactorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorWhereInput
    orderBy?: TwoFactorOrderByWithAggregationInput | TwoFactorOrderByWithAggregationInput[]
    by: TwoFactorScalarFieldEnum[] | TwoFactorScalarFieldEnum
    having?: TwoFactorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorCountAggregateInputType | true
    _min?: TwoFactorMinAggregateInputType
    _max?: TwoFactorMaxAggregateInputType
  }

  export type TwoFactorGroupByOutputType = {
    id: string
    secret: string
    backupCodes: string
    userId: string
    _count: TwoFactorCountAggregateOutputType | null
    _min: TwoFactorMinAggregateOutputType | null
    _max: TwoFactorMaxAggregateOutputType | null
  }

  type GetTwoFactorGroupByPayload<T extends TwoFactorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    secret?: boolean
    backupCodes?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactor"]>

  export type TwoFactorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    secret?: boolean
    backupCodes?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactor"]>

  export type TwoFactorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    secret?: boolean
    backupCodes?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactor"]>

  export type TwoFactorSelectScalar = {
    id?: boolean
    secret?: boolean
    backupCodes?: boolean
    userId?: boolean
  }

  export type TwoFactorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "secret" | "backupCodes" | "userId", ExtArgs["result"]["twoFactor"]>
  export type TwoFactorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwoFactorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwoFactorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TwoFactorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      secret: string
      backupCodes: string
      userId: string
    }, ExtArgs["result"]["twoFactor"]>
    composites: {}
  }

  type TwoFactorGetPayload<S extends boolean | null | undefined | TwoFactorDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorPayload, S>

  type TwoFactorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwoFactorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwoFactorCountAggregateInputType | true
    }

  export interface TwoFactorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactor'], meta: { name: 'TwoFactor' } }
    /**
     * Find zero or one TwoFactor that matches the filter.
     * @param {TwoFactorFindUniqueArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorFindUniqueArgs>(args: SelectSubset<T, TwoFactorFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwoFactor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwoFactorFindUniqueOrThrowArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindFirstArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorFindFirstArgs>(args?: SelectSubset<T, TwoFactorFindFirstArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindFirstOrThrowArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwoFactors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactors
     * const twoFactors = await prisma.twoFactor.findMany()
     * 
     * // Get first 10 TwoFactors
     * const twoFactors = await prisma.twoFactor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorWithIdOnly = await prisma.twoFactor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorFindManyArgs>(args?: SelectSubset<T, TwoFactorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwoFactor.
     * @param {TwoFactorCreateArgs} args - Arguments to create a TwoFactor.
     * @example
     * // Create one TwoFactor
     * const TwoFactor = await prisma.twoFactor.create({
     *   data: {
     *     // ... data to create a TwoFactor
     *   }
     * })
     * 
     */
    create<T extends TwoFactorCreateArgs>(args: SelectSubset<T, TwoFactorCreateArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwoFactors.
     * @param {TwoFactorCreateManyArgs} args - Arguments to create many TwoFactors.
     * @example
     * // Create many TwoFactors
     * const twoFactor = await prisma.twoFactor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorCreateManyArgs>(args?: SelectSubset<T, TwoFactorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwoFactors and returns the data saved in the database.
     * @param {TwoFactorCreateManyAndReturnArgs} args - Arguments to create many TwoFactors.
     * @example
     * // Create many TwoFactors
     * const twoFactor = await prisma.twoFactor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwoFactors and only return the `id`
     * const twoFactorWithIdOnly = await prisma.twoFactor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwoFactorCreateManyAndReturnArgs>(args?: SelectSubset<T, TwoFactorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TwoFactor.
     * @param {TwoFactorDeleteArgs} args - Arguments to delete one TwoFactor.
     * @example
     * // Delete one TwoFactor
     * const TwoFactor = await prisma.twoFactor.delete({
     *   where: {
     *     // ... filter to delete one TwoFactor
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorDeleteArgs>(args: SelectSubset<T, TwoFactorDeleteArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwoFactor.
     * @param {TwoFactorUpdateArgs} args - Arguments to update one TwoFactor.
     * @example
     * // Update one TwoFactor
     * const twoFactor = await prisma.twoFactor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorUpdateArgs>(args: SelectSubset<T, TwoFactorUpdateArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwoFactors.
     * @param {TwoFactorDeleteManyArgs} args - Arguments to filter TwoFactors to delete.
     * @example
     * // Delete a few TwoFactors
     * const { count } = await prisma.twoFactor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorDeleteManyArgs>(args?: SelectSubset<T, TwoFactorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactors
     * const twoFactor = await prisma.twoFactor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorUpdateManyArgs>(args: SelectSubset<T, TwoFactorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactors and returns the data updated in the database.
     * @param {TwoFactorUpdateManyAndReturnArgs} args - Arguments to update many TwoFactors.
     * @example
     * // Update many TwoFactors
     * const twoFactor = await prisma.twoFactor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TwoFactors and only return the `id`
     * const twoFactorWithIdOnly = await prisma.twoFactor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TwoFactorUpdateManyAndReturnArgs>(args: SelectSubset<T, TwoFactorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TwoFactor.
     * @param {TwoFactorUpsertArgs} args - Arguments to update or create a TwoFactor.
     * @example
     * // Update or create a TwoFactor
     * const twoFactor = await prisma.twoFactor.upsert({
     *   create: {
     *     // ... data to create a TwoFactor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactor we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorUpsertArgs>(args: SelectSubset<T, TwoFactorUpsertArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TwoFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorCountArgs} args - Arguments to filter TwoFactors to count.
     * @example
     * // Count the number of TwoFactors
     * const count = await prisma.twoFactor.count({
     *   where: {
     *     // ... the filter for the TwoFactors we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorCountArgs>(
      args?: Subset<T, TwoFactorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorAggregateArgs>(args: Subset<T, TwoFactorAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorAggregateType<T>>

    /**
     * Group by TwoFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactor model
   */
  readonly fields: TwoFactorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactor model
   */
  interface TwoFactorFieldRefs {
    readonly id: FieldRef<"TwoFactor", 'String'>
    readonly secret: FieldRef<"TwoFactor", 'String'>
    readonly backupCodes: FieldRef<"TwoFactor", 'String'>
    readonly userId: FieldRef<"TwoFactor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactor findUnique
   */
  export type TwoFactorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor findUniqueOrThrow
   */
  export type TwoFactorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor findFirst
   */
  export type TwoFactorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactors.
     */
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor findFirstOrThrow
   */
  export type TwoFactorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactors.
     */
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor findMany
   */
  export type TwoFactorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactors to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor create
   */
  export type TwoFactorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactor.
     */
    data: XOR<TwoFactorCreateInput, TwoFactorUncheckedCreateInput>
  }

  /**
   * TwoFactor createMany
   */
  export type TwoFactorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactors.
     */
    data: TwoFactorCreateManyInput | TwoFactorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactor createManyAndReturn
   */
  export type TwoFactorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * The data used to create many TwoFactors.
     */
    data: TwoFactorCreateManyInput | TwoFactorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwoFactor update
   */
  export type TwoFactorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactor.
     */
    data: XOR<TwoFactorUpdateInput, TwoFactorUncheckedUpdateInput>
    /**
     * Choose, which TwoFactor to update.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor updateMany
   */
  export type TwoFactorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactors.
     */
    data: XOR<TwoFactorUpdateManyMutationInput, TwoFactorUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactors to update
     */
    where?: TwoFactorWhereInput
    /**
     * Limit how many TwoFactors to update.
     */
    limit?: number
  }

  /**
   * TwoFactor updateManyAndReturn
   */
  export type TwoFactorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * The data used to update TwoFactors.
     */
    data: XOR<TwoFactorUpdateManyMutationInput, TwoFactorUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactors to update
     */
    where?: TwoFactorWhereInput
    /**
     * Limit how many TwoFactors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwoFactor upsert
   */
  export type TwoFactorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactor to update in case it exists.
     */
    where: TwoFactorWhereUniqueInput
    /**
     * In case the TwoFactor found by the `where` argument doesn't exist, create a new TwoFactor with this data.
     */
    create: XOR<TwoFactorCreateInput, TwoFactorUncheckedCreateInput>
    /**
     * In case the TwoFactor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorUpdateInput, TwoFactorUncheckedUpdateInput>
  }

  /**
   * TwoFactor delete
   */
  export type TwoFactorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter which TwoFactor to delete.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor deleteMany
   */
  export type TwoFactorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactors to delete
     */
    where?: TwoFactorWhereInput
    /**
     * Limit how many TwoFactors to delete.
     */
    limit?: number
  }

  /**
   * TwoFactor without action
   */
  export type TwoFactorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactor
     */
    omit?: TwoFactorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
  }


  /**
   * Model chatmessage
   */

  export type AggregateChatmessage = {
    _count: ChatmessageCountAggregateOutputType | null
    _min: ChatmessageMinAggregateOutputType | null
    _max: ChatmessageMaxAggregateOutputType | null
  }

  export type ChatmessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    channel: $Enums.ChatChannel | null
    createdAt: Date | null
    userId: string | null
    roomId: string | null
  }

  export type ChatmessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    channel: $Enums.ChatChannel | null
    createdAt: Date | null
    userId: string | null
    roomId: string | null
  }

  export type ChatmessageCountAggregateOutputType = {
    id: number
    content: number
    channel: number
    metadata: number
    createdAt: number
    userId: number
    roomId: number
    _all: number
  }


  export type ChatmessageMinAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    createdAt?: true
    userId?: true
    roomId?: true
  }

  export type ChatmessageMaxAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    createdAt?: true
    userId?: true
    roomId?: true
  }

  export type ChatmessageCountAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    metadata?: true
    createdAt?: true
    userId?: true
    roomId?: true
    _all?: true
  }

  export type ChatmessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatmessage to aggregate.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatmessages
    **/
    _count?: true | ChatmessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatmessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatmessageMaxAggregateInputType
  }

  export type GetChatmessageAggregateType<T extends ChatmessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatmessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatmessage[P]>
      : GetScalarType<T[P], AggregateChatmessage[P]>
  }




  export type chatmessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithAggregationInput | chatmessageOrderByWithAggregationInput[]
    by: ChatmessageScalarFieldEnum[] | ChatmessageScalarFieldEnum
    having?: chatmessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatmessageCountAggregateInputType | true
    _min?: ChatmessageMinAggregateInputType
    _max?: ChatmessageMaxAggregateInputType
  }

  export type ChatmessageGroupByOutputType = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata: JsonValue | null
    createdAt: Date
    userId: string
    roomId: string | null
    _count: ChatmessageCountAggregateOutputType | null
    _min: ChatmessageMinAggregateOutputType | null
    _max: ChatmessageMaxAggregateOutputType | null
  }

  type GetChatmessageGroupByPayload<T extends chatmessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatmessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatmessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatmessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatmessageGroupByOutputType[P]>
        }
      >
    >


  export type chatmessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>

  export type chatmessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>

  export type chatmessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>

  export type chatmessageSelectScalar = {
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
  }

  export type chatmessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "channel" | "metadata" | "createdAt" | "userId" | "roomId", ExtArgs["result"]["chatmessage"]>
  export type chatmessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type chatmessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type chatmessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $chatmessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatmessage"
    objects: {
      chatroom: Prisma.$chatroomPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      channel: $Enums.ChatChannel
      metadata: Prisma.JsonValue | null
      createdAt: Date
      userId: string
      roomId: string | null
    }, ExtArgs["result"]["chatmessage"]>
    composites: {}
  }

  type chatmessageGetPayload<S extends boolean | null | undefined | chatmessageDefaultArgs> = $Result.GetResult<Prisma.$chatmessagePayload, S>

  type chatmessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatmessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatmessageCountAggregateInputType | true
    }

  export interface chatmessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatmessage'], meta: { name: 'chatmessage' } }
    /**
     * Find zero or one Chatmessage that matches the filter.
     * @param {chatmessageFindUniqueArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatmessageFindUniqueArgs>(args: SelectSubset<T, chatmessageFindUniqueArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatmessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatmessageFindUniqueOrThrowArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatmessageFindUniqueOrThrowArgs>(args: SelectSubset<T, chatmessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatmessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindFirstArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatmessageFindFirstArgs>(args?: SelectSubset<T, chatmessageFindFirstArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatmessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindFirstOrThrowArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatmessageFindFirstOrThrowArgs>(args?: SelectSubset<T, chatmessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatmessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatmessages
     * const chatmessages = await prisma.chatmessage.findMany()
     * 
     * // Get first 10 Chatmessages
     * const chatmessages = await prisma.chatmessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatmessageFindManyArgs>(args?: SelectSubset<T, chatmessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatmessage.
     * @param {chatmessageCreateArgs} args - Arguments to create a Chatmessage.
     * @example
     * // Create one Chatmessage
     * const Chatmessage = await prisma.chatmessage.create({
     *   data: {
     *     // ... data to create a Chatmessage
     *   }
     * })
     * 
     */
    create<T extends chatmessageCreateArgs>(args: SelectSubset<T, chatmessageCreateArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatmessages.
     * @param {chatmessageCreateManyArgs} args - Arguments to create many Chatmessages.
     * @example
     * // Create many Chatmessages
     * const chatmessage = await prisma.chatmessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatmessageCreateManyArgs>(args?: SelectSubset<T, chatmessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatmessages and returns the data saved in the database.
     * @param {chatmessageCreateManyAndReturnArgs} args - Arguments to create many Chatmessages.
     * @example
     * // Create many Chatmessages
     * const chatmessage = await prisma.chatmessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatmessages and only return the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatmessageCreateManyAndReturnArgs>(args?: SelectSubset<T, chatmessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chatmessage.
     * @param {chatmessageDeleteArgs} args - Arguments to delete one Chatmessage.
     * @example
     * // Delete one Chatmessage
     * const Chatmessage = await prisma.chatmessage.delete({
     *   where: {
     *     // ... filter to delete one Chatmessage
     *   }
     * })
     * 
     */
    delete<T extends chatmessageDeleteArgs>(args: SelectSubset<T, chatmessageDeleteArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatmessage.
     * @param {chatmessageUpdateArgs} args - Arguments to update one Chatmessage.
     * @example
     * // Update one Chatmessage
     * const chatmessage = await prisma.chatmessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatmessageUpdateArgs>(args: SelectSubset<T, chatmessageUpdateArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatmessages.
     * @param {chatmessageDeleteManyArgs} args - Arguments to filter Chatmessages to delete.
     * @example
     * // Delete a few Chatmessages
     * const { count } = await prisma.chatmessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatmessageDeleteManyArgs>(args?: SelectSubset<T, chatmessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatmessages
     * const chatmessage = await prisma.chatmessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatmessageUpdateManyArgs>(args: SelectSubset<T, chatmessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatmessages and returns the data updated in the database.
     * @param {chatmessageUpdateManyAndReturnArgs} args - Arguments to update many Chatmessages.
     * @example
     * // Update many Chatmessages
     * const chatmessage = await prisma.chatmessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatmessages and only return the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatmessageUpdateManyAndReturnArgs>(args: SelectSubset<T, chatmessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chatmessage.
     * @param {chatmessageUpsertArgs} args - Arguments to update or create a Chatmessage.
     * @example
     * // Update or create a Chatmessage
     * const chatmessage = await prisma.chatmessage.upsert({
     *   create: {
     *     // ... data to create a Chatmessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatmessage we want to update
     *   }
     * })
     */
    upsert<T extends chatmessageUpsertArgs>(args: SelectSubset<T, chatmessageUpsertArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageCountArgs} args - Arguments to filter Chatmessages to count.
     * @example
     * // Count the number of Chatmessages
     * const count = await prisma.chatmessage.count({
     *   where: {
     *     // ... the filter for the Chatmessages we want to count
     *   }
     * })
    **/
    count<T extends chatmessageCountArgs>(
      args?: Subset<T, chatmessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatmessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatmessageAggregateArgs>(args: Subset<T, ChatmessageAggregateArgs>): Prisma.PrismaPromise<GetChatmessageAggregateType<T>>

    /**
     * Group by Chatmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatmessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatmessageGroupByArgs['orderBy'] }
        : { orderBy?: chatmessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatmessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatmessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatmessage model
   */
  readonly fields: chatmessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatmessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatmessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom<T extends chatmessage$chatroomArgs<ExtArgs> = {}>(args?: Subset<T, chatmessage$chatroomArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatmessage model
   */
  interface chatmessageFieldRefs {
    readonly id: FieldRef<"chatmessage", 'String'>
    readonly content: FieldRef<"chatmessage", 'String'>
    readonly channel: FieldRef<"chatmessage", 'ChatChannel'>
    readonly metadata: FieldRef<"chatmessage", 'Json'>
    readonly createdAt: FieldRef<"chatmessage", 'DateTime'>
    readonly userId: FieldRef<"chatmessage", 'String'>
    readonly roomId: FieldRef<"chatmessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatmessage findUnique
   */
  export type chatmessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage findUniqueOrThrow
   */
  export type chatmessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage findFirst
   */
  export type chatmessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatmessages.
     */
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage findFirstOrThrow
   */
  export type chatmessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatmessages.
     */
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage findMany
   */
  export type chatmessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessages to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage create
   */
  export type chatmessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The data needed to create a chatmessage.
     */
    data: XOR<chatmessageCreateInput, chatmessageUncheckedCreateInput>
  }

  /**
   * chatmessage createMany
   */
  export type chatmessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatmessages.
     */
    data: chatmessageCreateManyInput | chatmessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatmessage createManyAndReturn
   */
  export type chatmessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * The data used to create many chatmessages.
     */
    data: chatmessageCreateManyInput | chatmessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatmessage update
   */
  export type chatmessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The data needed to update a chatmessage.
     */
    data: XOR<chatmessageUpdateInput, chatmessageUncheckedUpdateInput>
    /**
     * Choose, which chatmessage to update.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage updateMany
   */
  export type chatmessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatmessages.
     */
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyInput>
    /**
     * Filter which chatmessages to update
     */
    where?: chatmessageWhereInput
    /**
     * Limit how many chatmessages to update.
     */
    limit?: number
  }

  /**
   * chatmessage updateManyAndReturn
   */
  export type chatmessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * The data used to update chatmessages.
     */
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyInput>
    /**
     * Filter which chatmessages to update
     */
    where?: chatmessageWhereInput
    /**
     * Limit how many chatmessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatmessage upsert
   */
  export type chatmessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The filter to search for the chatmessage to update in case it exists.
     */
    where: chatmessageWhereUniqueInput
    /**
     * In case the chatmessage found by the `where` argument doesn't exist, create a new chatmessage with this data.
     */
    create: XOR<chatmessageCreateInput, chatmessageUncheckedCreateInput>
    /**
     * In case the chatmessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatmessageUpdateInput, chatmessageUncheckedUpdateInput>
  }

  /**
   * chatmessage delete
   */
  export type chatmessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter which chatmessage to delete.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage deleteMany
   */
  export type chatmessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatmessages to delete
     */
    where?: chatmessageWhereInput
    /**
     * Limit how many chatmessages to delete.
     */
    limit?: number
  }

  /**
   * chatmessage.chatroom
   */
  export type chatmessage$chatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    where?: chatroomWhereInput
  }

  /**
   * chatmessage without action
   */
  export type chatmessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
  }


  /**
   * Model chatroom
   */

  export type AggregateChatroom = {
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  export type ChatroomMinAggregateOutputType = {
    id: string | null
    name: string | null
    isGameRoom: boolean | null
    createdAt: Date | null
    gameSessionId: string | null
  }

  export type ChatroomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isGameRoom: boolean | null
    createdAt: Date | null
    gameSessionId: string | null
  }

  export type ChatroomCountAggregateOutputType = {
    id: number
    name: number
    isGameRoom: number
    createdAt: number
    gameSessionId: number
    _all: number
  }


  export type ChatroomMinAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
  }

  export type ChatroomMaxAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
  }

  export type ChatroomCountAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
    _all?: true
  }

  export type ChatroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatroom to aggregate.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatrooms
    **/
    _count?: true | ChatroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatroomMaxAggregateInputType
  }

  export type GetChatroomAggregateType<T extends ChatroomAggregateArgs> = {
        [P in keyof T & keyof AggregateChatroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatroom[P]>
      : GetScalarType<T[P], AggregateChatroom[P]>
  }




  export type chatroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatroomWhereInput
    orderBy?: chatroomOrderByWithAggregationInput | chatroomOrderByWithAggregationInput[]
    by: ChatroomScalarFieldEnum[] | ChatroomScalarFieldEnum
    having?: chatroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatroomCountAggregateInputType | true
    _min?: ChatroomMinAggregateInputType
    _max?: ChatroomMaxAggregateInputType
  }

  export type ChatroomGroupByOutputType = {
    id: string
    name: string
    isGameRoom: boolean
    createdAt: Date
    gameSessionId: string | null
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  type GetChatroomGroupByPayload<T extends chatroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
            : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
        }
      >
    >


  export type chatroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
    chatmessage?: boolean | chatroom$chatmessageArgs<ExtArgs>
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectScalar = {
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
  }

  export type chatroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isGameRoom" | "createdAt" | "gameSessionId", ExtArgs["result"]["chatroom"]>
  export type chatroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatmessage?: boolean | chatroom$chatmessageArgs<ExtArgs>
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chatroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
  }
  export type chatroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
  }

  export type $chatroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatroom"
    objects: {
      chatmessage: Prisma.$chatmessagePayload<ExtArgs>[]
      gamesession: Prisma.$gamesessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isGameRoom: boolean
      createdAt: Date
      gameSessionId: string | null
    }, ExtArgs["result"]["chatroom"]>
    composites: {}
  }

  type chatroomGetPayload<S extends boolean | null | undefined | chatroomDefaultArgs> = $Result.GetResult<Prisma.$chatroomPayload, S>

  type chatroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatroomCountAggregateInputType | true
    }

  export interface chatroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatroom'], meta: { name: 'chatroom' } }
    /**
     * Find zero or one Chatroom that matches the filter.
     * @param {chatroomFindUniqueArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatroomFindUniqueArgs>(args: SelectSubset<T, chatroomFindUniqueArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatroomFindUniqueOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatroomFindUniqueOrThrowArgs>(args: SelectSubset<T, chatroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindFirstArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatroomFindFirstArgs>(args?: SelectSubset<T, chatroomFindFirstArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindFirstOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatroomFindFirstOrThrowArgs>(args?: SelectSubset<T, chatroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatrooms
     * const chatrooms = await prisma.chatroom.findMany()
     * 
     * // Get first 10 Chatrooms
     * const chatrooms = await prisma.chatroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatroomFindManyArgs>(args?: SelectSubset<T, chatroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatroom.
     * @param {chatroomCreateArgs} args - Arguments to create a Chatroom.
     * @example
     * // Create one Chatroom
     * const Chatroom = await prisma.chatroom.create({
     *   data: {
     *     // ... data to create a Chatroom
     *   }
     * })
     * 
     */
    create<T extends chatroomCreateArgs>(args: SelectSubset<T, chatroomCreateArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatrooms.
     * @param {chatroomCreateManyArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatroomCreateManyArgs>(args?: SelectSubset<T, chatroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatrooms and returns the data saved in the database.
     * @param {chatroomCreateManyAndReturnArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatrooms and only return the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatroomCreateManyAndReturnArgs>(args?: SelectSubset<T, chatroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chatroom.
     * @param {chatroomDeleteArgs} args - Arguments to delete one Chatroom.
     * @example
     * // Delete one Chatroom
     * const Chatroom = await prisma.chatroom.delete({
     *   where: {
     *     // ... filter to delete one Chatroom
     *   }
     * })
     * 
     */
    delete<T extends chatroomDeleteArgs>(args: SelectSubset<T, chatroomDeleteArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatroom.
     * @param {chatroomUpdateArgs} args - Arguments to update one Chatroom.
     * @example
     * // Update one Chatroom
     * const chatroom = await prisma.chatroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatroomUpdateArgs>(args: SelectSubset<T, chatroomUpdateArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatrooms.
     * @param {chatroomDeleteManyArgs} args - Arguments to filter Chatrooms to delete.
     * @example
     * // Delete a few Chatrooms
     * const { count } = await prisma.chatroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatroomDeleteManyArgs>(args?: SelectSubset<T, chatroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatrooms
     * const chatroom = await prisma.chatroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatroomUpdateManyArgs>(args: SelectSubset<T, chatroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatrooms and returns the data updated in the database.
     * @param {chatroomUpdateManyAndReturnArgs} args - Arguments to update many Chatrooms.
     * @example
     * // Update many Chatrooms
     * const chatroom = await prisma.chatroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatrooms and only return the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatroomUpdateManyAndReturnArgs>(args: SelectSubset<T, chatroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chatroom.
     * @param {chatroomUpsertArgs} args - Arguments to update or create a Chatroom.
     * @example
     * // Update or create a Chatroom
     * const chatroom = await prisma.chatroom.upsert({
     *   create: {
     *     // ... data to create a Chatroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatroom we want to update
     *   }
     * })
     */
    upsert<T extends chatroomUpsertArgs>(args: SelectSubset<T, chatroomUpsertArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomCountArgs} args - Arguments to filter Chatrooms to count.
     * @example
     * // Count the number of Chatrooms
     * const count = await prisma.chatroom.count({
     *   where: {
     *     // ... the filter for the Chatrooms we want to count
     *   }
     * })
    **/
    count<T extends chatroomCountArgs>(
      args?: Subset<T, chatroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatroomAggregateArgs>(args: Subset<T, ChatroomAggregateArgs>): Prisma.PrismaPromise<GetChatroomAggregateType<T>>

    /**
     * Group by Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatroomGroupByArgs['orderBy'] }
        : { orderBy?: chatroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatroom model
   */
  readonly fields: chatroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatmessage<T extends chatroom$chatmessageArgs<ExtArgs> = {}>(args?: Subset<T, chatroom$chatmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gamesession<T extends chatroom$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, chatroom$gamesessionArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatroom model
   */
  interface chatroomFieldRefs {
    readonly id: FieldRef<"chatroom", 'String'>
    readonly name: FieldRef<"chatroom", 'String'>
    readonly isGameRoom: FieldRef<"chatroom", 'Boolean'>
    readonly createdAt: FieldRef<"chatroom", 'DateTime'>
    readonly gameSessionId: FieldRef<"chatroom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatroom findUnique
   */
  export type chatroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom findUniqueOrThrow
   */
  export type chatroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom findFirst
   */
  export type chatroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom findFirstOrThrow
   */
  export type chatroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom findMany
   */
  export type chatroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatrooms to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom create
   */
  export type chatroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The data needed to create a chatroom.
     */
    data: XOR<chatroomCreateInput, chatroomUncheckedCreateInput>
  }

  /**
   * chatroom createMany
   */
  export type chatroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatrooms.
     */
    data: chatroomCreateManyInput | chatroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatroom createManyAndReturn
   */
  export type chatroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * The data used to create many chatrooms.
     */
    data: chatroomCreateManyInput | chatroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatroom update
   */
  export type chatroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The data needed to update a chatroom.
     */
    data: XOR<chatroomUpdateInput, chatroomUncheckedUpdateInput>
    /**
     * Choose, which chatroom to update.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom updateMany
   */
  export type chatroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatrooms.
     */
    data: XOR<chatroomUpdateManyMutationInput, chatroomUncheckedUpdateManyInput>
    /**
     * Filter which chatrooms to update
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to update.
     */
    limit?: number
  }

  /**
   * chatroom updateManyAndReturn
   */
  export type chatroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * The data used to update chatrooms.
     */
    data: XOR<chatroomUpdateManyMutationInput, chatroomUncheckedUpdateManyInput>
    /**
     * Filter which chatrooms to update
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatroom upsert
   */
  export type chatroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The filter to search for the chatroom to update in case it exists.
     */
    where: chatroomWhereUniqueInput
    /**
     * In case the chatroom found by the `where` argument doesn't exist, create a new chatroom with this data.
     */
    create: XOR<chatroomCreateInput, chatroomUncheckedCreateInput>
    /**
     * In case the chatroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatroomUpdateInput, chatroomUncheckedUpdateInput>
  }

  /**
   * chatroom delete
   */
  export type chatroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter which chatroom to delete.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom deleteMany
   */
  export type chatroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatrooms to delete
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to delete.
     */
    limit?: number
  }

  /**
   * chatroom.chatmessage
   */
  export type chatroom$chatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    cursor?: chatmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatroom.gamesession
   */
  export type chatroom$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
  }

  /**
   * chatroom without action
   */
  export type chatroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
  }


  /**
   * Model friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    friendId: string | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    friendId: string | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    friendId: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which friendship to aggregate.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type friendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithAggregationInput | friendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: friendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    status: $Enums.FriendshipStatus
    createdAt: Date
    updatedAt: Date | null
    userId: string
    friendId: string
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends friendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type friendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
    user_friendship_friendIdTouser?: boolean | UserDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type friendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
    user_friendship_friendIdTouser?: boolean | UserDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type friendshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
    user_friendship_friendIdTouser?: boolean | UserDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type friendshipSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
  }

  export type friendshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "createdAt" | "updatedAt" | "userId" | "friendId", ExtArgs["result"]["friendship"]>
  export type friendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_friendship_friendIdTouser?: boolean | UserDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type friendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_friendship_friendIdTouser?: boolean | UserDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type friendshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_friendship_friendIdTouser?: boolean | UserDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $friendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "friendship"
    objects: {
      user_friendship_friendIdTouser: Prisma.$UserPayload<ExtArgs>
      user_friendship_userIdTouser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.FriendshipStatus
      createdAt: Date
      updatedAt: Date | null
      userId: string
      friendId: string
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type friendshipGetPayload<S extends boolean | null | undefined | friendshipDefaultArgs> = $Result.GetResult<Prisma.$friendshipPayload, S>

  type friendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<friendshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface friendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['friendship'], meta: { name: 'friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {friendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends friendshipFindUniqueArgs>(args: SelectSubset<T, friendshipFindUniqueArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {friendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends friendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, friendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends friendshipFindFirstArgs>(args?: SelectSubset<T, friendshipFindFirstArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends friendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, friendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends friendshipFindManyArgs>(args?: SelectSubset<T, friendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friendship.
     * @param {friendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends friendshipCreateArgs>(args: SelectSubset<T, friendshipCreateArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friendships.
     * @param {friendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends friendshipCreateManyArgs>(args?: SelectSubset<T, friendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {friendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends friendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, friendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Friendship.
     * @param {friendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends friendshipDeleteArgs>(args: SelectSubset<T, friendshipDeleteArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friendship.
     * @param {friendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends friendshipUpdateArgs>(args: SelectSubset<T, friendshipUpdateArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friendships.
     * @param {friendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends friendshipDeleteManyArgs>(args?: SelectSubset<T, friendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends friendshipUpdateManyArgs>(args: SelectSubset<T, friendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships and returns the data updated in the database.
     * @param {friendshipUpdateManyAndReturnArgs} args - Arguments to update many Friendships.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends friendshipUpdateManyAndReturnArgs>(args: SelectSubset<T, friendshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Friendship.
     * @param {friendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends friendshipUpsertArgs>(args: SelectSubset<T, friendshipUpsertArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends friendshipCountArgs>(
      args?: Subset<T, friendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends friendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: friendshipGroupByArgs['orderBy'] }
        : { orderBy?: friendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, friendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the friendship model
   */
  readonly fields: friendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__friendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_friendship_friendIdTouser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user_friendship_userIdTouser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the friendship model
   */
  interface friendshipFieldRefs {
    readonly id: FieldRef<"friendship", 'String'>
    readonly status: FieldRef<"friendship", 'FriendshipStatus'>
    readonly createdAt: FieldRef<"friendship", 'DateTime'>
    readonly updatedAt: FieldRef<"friendship", 'DateTime'>
    readonly userId: FieldRef<"friendship", 'String'>
    readonly friendId: FieldRef<"friendship", 'String'>
  }
    

  // Custom InputTypes
  /**
   * friendship findUnique
   */
  export type friendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship findUniqueOrThrow
   */
  export type friendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship findFirst
   */
  export type friendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship findFirstOrThrow
   */
  export type friendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship findMany
   */
  export type friendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendships to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship create
   */
  export type friendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a friendship.
     */
    data: XOR<friendshipCreateInput, friendshipUncheckedCreateInput>
  }

  /**
   * friendship createMany
   */
  export type friendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many friendships.
     */
    data: friendshipCreateManyInput | friendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * friendship createManyAndReturn
   */
  export type friendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * The data used to create many friendships.
     */
    data: friendshipCreateManyInput | friendshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * friendship update
   */
  export type friendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a friendship.
     */
    data: XOR<friendshipUpdateInput, friendshipUncheckedUpdateInput>
    /**
     * Choose, which friendship to update.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship updateMany
   */
  export type friendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update friendships.
     */
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyInput>
    /**
     * Filter which friendships to update
     */
    where?: friendshipWhereInput
    /**
     * Limit how many friendships to update.
     */
    limit?: number
  }

  /**
   * friendship updateManyAndReturn
   */
  export type friendshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * The data used to update friendships.
     */
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyInput>
    /**
     * Filter which friendships to update
     */
    where?: friendshipWhereInput
    /**
     * Limit how many friendships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * friendship upsert
   */
  export type friendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the friendship to update in case it exists.
     */
    where: friendshipWhereUniqueInput
    /**
     * In case the friendship found by the `where` argument doesn't exist, create a new friendship with this data.
     */
    create: XOR<friendshipCreateInput, friendshipUncheckedCreateInput>
    /**
     * In case the friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<friendshipUpdateInput, friendshipUncheckedUpdateInput>
  }

  /**
   * friendship delete
   */
  export type friendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter which friendship to delete.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship deleteMany
   */
  export type friendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which friendships to delete
     */
    where?: friendshipWhereInput
    /**
     * Limit how many friendships to delete.
     */
    limit?: number
  }

  /**
   * friendship without action
   */
  export type friendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
  }


  /**
   * Model gamesession
   */

  export type AggregateGamesession = {
    _count: GamesessionCountAggregateOutputType | null
    _avg: GamesessionAvgAggregateOutputType | null
    _sum: GamesessionSumAggregateOutputType | null
    _min: GamesessionMinAggregateOutputType | null
    _max: GamesessionMaxAggregateOutputType | null
  }

  export type GamesessionAvgAggregateOutputType = {
    betAmount: number | null
    winAmount: number | null
    xpEarned: number | null
  }

  export type GamesessionSumAggregateOutputType = {
    betAmount: number | null
    winAmount: number | null
    xpEarned: number | null
  }

  export type GamesessionMinAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    betAmount: number | null
    winAmount: number | null
    xpEarned: number | null
    gameId: string | null
    tournamentId: string | null
    active: boolean | null
    profileId: string | null
  }

  export type GamesessionMaxAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    betAmount: number | null
    winAmount: number | null
    xpEarned: number | null
    gameId: string | null
    tournamentId: string | null
    active: boolean | null
    profileId: string | null
  }

  export type GamesessionCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    betAmount: number
    winAmount: number
    xpEarned: number
    metadata: number
    gameId: number
    tournamentId: number
    active: number
    profileId: number
    _all: number
  }


  export type GamesessionAvgAggregateInputType = {
    betAmount?: true
    winAmount?: true
    xpEarned?: true
  }

  export type GamesessionSumAggregateInputType = {
    betAmount?: true
    winAmount?: true
    xpEarned?: true
  }

  export type GamesessionMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
  }

  export type GamesessionMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
  }

  export type GamesessionCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    metadata?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
    _all?: true
  }

  export type GamesessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gamesession to aggregate.
     */
    where?: gamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamesessions to fetch.
     */
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gamesessions
    **/
    _count?: true | GamesessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamesessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamesessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamesessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamesessionMaxAggregateInputType
  }

  export type GetGamesessionAggregateType<T extends GamesessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGamesession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamesession[P]>
      : GetScalarType<T[P], AggregateGamesession[P]>
  }




  export type gamesessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesessionWhereInput
    orderBy?: gamesessionOrderByWithAggregationInput | gamesessionOrderByWithAggregationInput[]
    by: GamesessionScalarFieldEnum[] | GamesessionScalarFieldEnum
    having?: gamesessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamesessionCountAggregateInputType | true
    _avg?: GamesessionAvgAggregateInputType
    _sum?: GamesessionSumAggregateInputType
    _min?: GamesessionMinAggregateInputType
    _max?: GamesessionMaxAggregateInputType
  }

  export type GamesessionGroupByOutputType = {
    id: string
    startTime: Date
    endTime: Date | null
    betAmount: number | null
    winAmount: number | null
    xpEarned: number
    metadata: JsonValue | null
    gameId: string
    tournamentId: string | null
    active: boolean
    profileId: string
    _count: GamesessionCountAggregateOutputType | null
    _avg: GamesessionAvgAggregateOutputType | null
    _sum: GamesessionSumAggregateOutputType | null
    _min: GamesessionMinAggregateOutputType | null
    _max: GamesessionMaxAggregateOutputType | null
  }

  type GetGamesessionGroupByPayload<T extends gamesessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamesessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamesessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamesessionGroupByOutputType[P]>
            : GetScalarType<T[P], GamesessionGroupByOutputType[P]>
        }
      >
    >


  export type gamesessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    chatroom?: boolean | gamesession$chatroomArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
    Transaction?: boolean | gamesession$TransactionArgs<ExtArgs>
    _count?: boolean | GamesessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gamesession"]>

  export type gamesessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
  }, ExtArgs["result"]["gamesession"]>

  export type gamesessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
  }, ExtArgs["result"]["gamesession"]>

  export type gamesessionSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
  }

  export type gamesessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startTime" | "endTime" | "betAmount" | "winAmount" | "xpEarned" | "metadata" | "gameId" | "tournamentId" | "active" | "profileId", ExtArgs["result"]["gamesession"]>
  export type gamesessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | gamesession$chatroomArgs<ExtArgs>
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
    Transaction?: boolean | gamesession$TransactionArgs<ExtArgs>
    _count?: boolean | GamesessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type gamesessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
  }
  export type gamesessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
  }

  export type $gamesessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gamesession"
    objects: {
      chatroom: Prisma.$chatroomPayload<ExtArgs>[]
      game: Prisma.$GamePayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
      tournament: Prisma.$tournamentPayload<ExtArgs> | null
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startTime: Date
      endTime: Date | null
      betAmount: number | null
      winAmount: number | null
      xpEarned: number
      metadata: Prisma.JsonValue | null
      gameId: string
      tournamentId: string | null
      active: boolean
      profileId: string
    }, ExtArgs["result"]["gamesession"]>
    composites: {}
  }

  type gamesessionGetPayload<S extends boolean | null | undefined | gamesessionDefaultArgs> = $Result.GetResult<Prisma.$gamesessionPayload, S>

  type gamesessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gamesessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GamesessionCountAggregateInputType | true
    }

  export interface gamesessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gamesession'], meta: { name: 'gamesession' } }
    /**
     * Find zero or one Gamesession that matches the filter.
     * @param {gamesessionFindUniqueArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gamesessionFindUniqueArgs>(args: SelectSubset<T, gamesessionFindUniqueArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gamesession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gamesessionFindUniqueOrThrowArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gamesessionFindUniqueOrThrowArgs>(args: SelectSubset<T, gamesessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gamesession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionFindFirstArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gamesessionFindFirstArgs>(args?: SelectSubset<T, gamesessionFindFirstArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gamesession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionFindFirstOrThrowArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gamesessionFindFirstOrThrowArgs>(args?: SelectSubset<T, gamesessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gamesessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gamesessions
     * const gamesessions = await prisma.gamesession.findMany()
     * 
     * // Get first 10 Gamesessions
     * const gamesessions = await prisma.gamesession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gamesessionWithIdOnly = await prisma.gamesession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gamesessionFindManyArgs>(args?: SelectSubset<T, gamesessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gamesession.
     * @param {gamesessionCreateArgs} args - Arguments to create a Gamesession.
     * @example
     * // Create one Gamesession
     * const Gamesession = await prisma.gamesession.create({
     *   data: {
     *     // ... data to create a Gamesession
     *   }
     * })
     * 
     */
    create<T extends gamesessionCreateArgs>(args: SelectSubset<T, gamesessionCreateArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gamesessions.
     * @param {gamesessionCreateManyArgs} args - Arguments to create many Gamesessions.
     * @example
     * // Create many Gamesessions
     * const gamesession = await prisma.gamesession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gamesessionCreateManyArgs>(args?: SelectSubset<T, gamesessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gamesessions and returns the data saved in the database.
     * @param {gamesessionCreateManyAndReturnArgs} args - Arguments to create many Gamesessions.
     * @example
     * // Create many Gamesessions
     * const gamesession = await prisma.gamesession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gamesessions and only return the `id`
     * const gamesessionWithIdOnly = await prisma.gamesession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends gamesessionCreateManyAndReturnArgs>(args?: SelectSubset<T, gamesessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gamesession.
     * @param {gamesessionDeleteArgs} args - Arguments to delete one Gamesession.
     * @example
     * // Delete one Gamesession
     * const Gamesession = await prisma.gamesession.delete({
     *   where: {
     *     // ... filter to delete one Gamesession
     *   }
     * })
     * 
     */
    delete<T extends gamesessionDeleteArgs>(args: SelectSubset<T, gamesessionDeleteArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gamesession.
     * @param {gamesessionUpdateArgs} args - Arguments to update one Gamesession.
     * @example
     * // Update one Gamesession
     * const gamesession = await prisma.gamesession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gamesessionUpdateArgs>(args: SelectSubset<T, gamesessionUpdateArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gamesessions.
     * @param {gamesessionDeleteManyArgs} args - Arguments to filter Gamesessions to delete.
     * @example
     * // Delete a few Gamesessions
     * const { count } = await prisma.gamesession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gamesessionDeleteManyArgs>(args?: SelectSubset<T, gamesessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamesessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gamesessions
     * const gamesession = await prisma.gamesession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gamesessionUpdateManyArgs>(args: SelectSubset<T, gamesessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamesessions and returns the data updated in the database.
     * @param {gamesessionUpdateManyAndReturnArgs} args - Arguments to update many Gamesessions.
     * @example
     * // Update many Gamesessions
     * const gamesession = await prisma.gamesession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gamesessions and only return the `id`
     * const gamesessionWithIdOnly = await prisma.gamesession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends gamesessionUpdateManyAndReturnArgs>(args: SelectSubset<T, gamesessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gamesession.
     * @param {gamesessionUpsertArgs} args - Arguments to update or create a Gamesession.
     * @example
     * // Update or create a Gamesession
     * const gamesession = await prisma.gamesession.upsert({
     *   create: {
     *     // ... data to create a Gamesession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gamesession we want to update
     *   }
     * })
     */
    upsert<T extends gamesessionUpsertArgs>(args: SelectSubset<T, gamesessionUpsertArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gamesessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionCountArgs} args - Arguments to filter Gamesessions to count.
     * @example
     * // Count the number of Gamesessions
     * const count = await prisma.gamesession.count({
     *   where: {
     *     // ... the filter for the Gamesessions we want to count
     *   }
     * })
    **/
    count<T extends gamesessionCountArgs>(
      args?: Subset<T, gamesessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamesessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gamesession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamesessionAggregateArgs>(args: Subset<T, GamesessionAggregateArgs>): Prisma.PrismaPromise<GetGamesessionAggregateType<T>>

    /**
     * Group by Gamesession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gamesessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gamesessionGroupByArgs['orderBy'] }
        : { orderBy?: gamesessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gamesessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamesessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gamesession model
   */
  readonly fields: gamesessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gamesession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gamesessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom<T extends gamesession$chatroomArgs<ExtArgs> = {}>(args?: Subset<T, gamesession$chatroomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends gamesession$tournamentArgs<ExtArgs> = {}>(args?: Subset<T, gamesession$tournamentArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Transaction<T extends gamesession$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, gamesession$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gamesession model
   */
  interface gamesessionFieldRefs {
    readonly id: FieldRef<"gamesession", 'String'>
    readonly startTime: FieldRef<"gamesession", 'DateTime'>
    readonly endTime: FieldRef<"gamesession", 'DateTime'>
    readonly betAmount: FieldRef<"gamesession", 'Int'>
    readonly winAmount: FieldRef<"gamesession", 'Int'>
    readonly xpEarned: FieldRef<"gamesession", 'Int'>
    readonly metadata: FieldRef<"gamesession", 'Json'>
    readonly gameId: FieldRef<"gamesession", 'String'>
    readonly tournamentId: FieldRef<"gamesession", 'String'>
    readonly active: FieldRef<"gamesession", 'Boolean'>
    readonly profileId: FieldRef<"gamesession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * gamesession findUnique
   */
  export type gamesessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesession to fetch.
     */
    where: gamesessionWhereUniqueInput
  }

  /**
   * gamesession findUniqueOrThrow
   */
  export type gamesessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesession to fetch.
     */
    where: gamesessionWhereUniqueInput
  }

  /**
   * gamesession findFirst
   */
  export type gamesessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesession to fetch.
     */
    where?: gamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamesessions to fetch.
     */
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gamesessions.
     */
    cursor?: gamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gamesessions.
     */
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * gamesession findFirstOrThrow
   */
  export type gamesessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesession to fetch.
     */
    where?: gamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamesessions to fetch.
     */
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gamesessions.
     */
    cursor?: gamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gamesessions.
     */
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * gamesession findMany
   */
  export type gamesessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesessions to fetch.
     */
    where?: gamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamesessions to fetch.
     */
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gamesessions.
     */
    cursor?: gamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamesessions.
     */
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * gamesession create
   */
  export type gamesessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * The data needed to create a gamesession.
     */
    data: XOR<gamesessionCreateInput, gamesessionUncheckedCreateInput>
  }

  /**
   * gamesession createMany
   */
  export type gamesessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gamesessions.
     */
    data: gamesessionCreateManyInput | gamesessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gamesession createManyAndReturn
   */
  export type gamesessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * The data used to create many gamesessions.
     */
    data: gamesessionCreateManyInput | gamesessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * gamesession update
   */
  export type gamesessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * The data needed to update a gamesession.
     */
    data: XOR<gamesessionUpdateInput, gamesessionUncheckedUpdateInput>
    /**
     * Choose, which gamesession to update.
     */
    where: gamesessionWhereUniqueInput
  }

  /**
   * gamesession updateMany
   */
  export type gamesessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gamesessions.
     */
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyInput>
    /**
     * Filter which gamesessions to update
     */
    where?: gamesessionWhereInput
    /**
     * Limit how many gamesessions to update.
     */
    limit?: number
  }

  /**
   * gamesession updateManyAndReturn
   */
  export type gamesessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * The data used to update gamesessions.
     */
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyInput>
    /**
     * Filter which gamesessions to update
     */
    where?: gamesessionWhereInput
    /**
     * Limit how many gamesessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * gamesession upsert
   */
  export type gamesessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * The filter to search for the gamesession to update in case it exists.
     */
    where: gamesessionWhereUniqueInput
    /**
     * In case the gamesession found by the `where` argument doesn't exist, create a new gamesession with this data.
     */
    create: XOR<gamesessionCreateInput, gamesessionUncheckedCreateInput>
    /**
     * In case the gamesession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gamesessionUpdateInput, gamesessionUncheckedUpdateInput>
  }

  /**
   * gamesession delete
   */
  export type gamesessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter which gamesession to delete.
     */
    where: gamesessionWhereUniqueInput
  }

  /**
   * gamesession deleteMany
   */
  export type gamesessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gamesessions to delete
     */
    where?: gamesessionWhereInput
    /**
     * Limit how many gamesessions to delete.
     */
    limit?: number
  }

  /**
   * gamesession.chatroom
   */
  export type gamesession$chatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    where?: chatroomWhereInput
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    cursor?: chatroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * gamesession.tournament
   */
  export type gamesession$tournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    where?: tournamentWhereInput
  }

  /**
   * gamesession.Transaction
   */
  export type gamesession$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * gamesession without action
   */
  export type gamesessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    bonusTotalInCredits: number | null
    priceInCents: number | null
    amountToReceiveInCredits: number | null
    bestValue: number | null
    discountInCents: number | null
    bonusSpins: number | null
    totalDiscountInCents: number | null
  }

  export type ProductSumAggregateOutputType = {
    bonusTotalInCredits: number | null
    priceInCents: number | null
    amountToReceiveInCredits: number | null
    bestValue: number | null
    discountInCents: number | null
    bonusSpins: number | null
    totalDiscountInCents: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    type: string | null
    bonusCode: string | null
    bonusTotalInCredits: number | null
    priceInCents: number | null
    amountToReceiveInCredits: number | null
    bestValue: number | null
    discountInCents: number | null
    bonusSpins: number | null
    isPromo: boolean | null
    totalDiscountInCents: number | null
    shopId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    type: string | null
    bonusCode: string | null
    bonusTotalInCredits: number | null
    priceInCents: number | null
    amountToReceiveInCredits: number | null
    bestValue: number | null
    discountInCents: number | null
    bonusSpins: number | null
    isPromo: boolean | null
    totalDiscountInCents: number | null
    shopId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    description: number
    url: number
    type: number
    bonusCode: number
    bonusTotalInCredits: number
    priceInCents: number
    amountToReceiveInCredits: number
    bestValue: number
    discountInCents: number
    bonusSpins: number
    isPromo: number
    totalDiscountInCents: number
    shopId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    totalDiscountInCents?: true
  }

  export type ProductSumAggregateInputType = {
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    totalDiscountInCents?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    bonusCode?: true
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    isPromo?: true
    totalDiscountInCents?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    bonusCode?: true
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    isPromo?: true
    totalDiscountInCents?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    type?: true
    bonusCode?: true
    bonusTotalInCredits?: true
    priceInCents?: true
    amountToReceiveInCredits?: true
    bestValue?: true
    discountInCents?: true
    bonusSpins?: true
    isPromo?: true
    totalDiscountInCents?: true
    shopId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    title: string
    description: string
    url: string
    type: string
    bonusCode: string | null
    bonusTotalInCredits: number | null
    priceInCents: number
    amountToReceiveInCredits: number
    bestValue: number
    discountInCents: number
    bonusSpins: number | null
    isPromo: boolean | null
    totalDiscountInCents: number
    shopId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    bonusCode?: boolean
    bonusTotalInCredits?: boolean
    priceInCents?: boolean
    amountToReceiveInCredits?: boolean
    bestValue?: boolean
    discountInCents?: boolean
    bonusSpins?: boolean
    isPromo?: boolean
    totalDiscountInCents?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operator?: boolean | Product$operatorArgs<ExtArgs>
    transactions?: boolean | Product$transactionsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    bonusCode?: boolean
    bonusTotalInCredits?: boolean
    priceInCents?: boolean
    amountToReceiveInCredits?: boolean
    bestValue?: boolean
    discountInCents?: boolean
    bonusSpins?: boolean
    isPromo?: boolean
    totalDiscountInCents?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operator?: boolean | Product$operatorArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    bonusCode?: boolean
    bonusTotalInCredits?: boolean
    priceInCents?: boolean
    amountToReceiveInCredits?: boolean
    bestValue?: boolean
    discountInCents?: boolean
    bonusSpins?: boolean
    isPromo?: boolean
    totalDiscountInCents?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operator?: boolean | Product$operatorArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    type?: boolean
    bonusCode?: boolean
    bonusTotalInCredits?: boolean
    priceInCents?: boolean
    amountToReceiveInCredits?: boolean
    bestValue?: boolean
    discountInCents?: boolean
    bonusSpins?: boolean
    isPromo?: boolean
    totalDiscountInCents?: boolean
    shopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "url" | "type" | "bonusCode" | "bonusTotalInCredits" | "priceInCents" | "amountToReceiveInCredits" | "bestValue" | "discountInCents" | "bonusSpins" | "isPromo" | "totalDiscountInCents" | "shopId" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Product$operatorArgs<ExtArgs>
    transactions?: boolean | Product$transactionsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Product$operatorArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | Product$operatorArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      operator: Prisma.$OperatorPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      url: string
      type: string
      bonusCode: string | null
      bonusTotalInCredits: number | null
      priceInCents: number
      amountToReceiveInCredits: number
      bestValue: number
      discountInCents: number
      bonusSpins: number | null
      isPromo: boolean | null
      totalDiscountInCents: number
      shopId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operator<T extends Product$operatorArgs<ExtArgs> = {}>(args?: Subset<T, Product$operatorArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Product$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly url: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'String'>
    readonly bonusCode: FieldRef<"Product", 'String'>
    readonly bonusTotalInCredits: FieldRef<"Product", 'Int'>
    readonly priceInCents: FieldRef<"Product", 'Int'>
    readonly amountToReceiveInCredits: FieldRef<"Product", 'Int'>
    readonly bestValue: FieldRef<"Product", 'Int'>
    readonly discountInCents: FieldRef<"Product", 'Int'>
    readonly bonusSpins: FieldRef<"Product", 'Int'>
    readonly isPromo: FieldRef<"Product", 'Boolean'>
    readonly totalDiscountInCents: FieldRef<"Product", 'Int'>
    readonly shopId: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.operator
   */
  export type Product$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperatorInclude<ExtArgs> | null
    where?: OperatorWhereInput
  }

  /**
   * Product.transactions
   */
  export type Product$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    isRead: number
    readAt: number
    metadata: number
    createdAt: number
    userId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    metadata?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    readAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type notificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "message" | "isRead" | "readAt" | "metadata" | "createdAt" | "userId", ExtArgs["result"]["notification"]>
  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type notificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type notificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      readAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'String'>
    readonly type: FieldRef<"notification", 'NotificationType'>
    readonly title: FieldRef<"notification", 'String'>
    readonly message: FieldRef<"notification", 'String'>
    readonly isRead: FieldRef<"notification", 'Boolean'>
    readonly readAt: FieldRef<"notification", 'DateTime'>
    readonly metadata: FieldRef<"notification", 'Json'>
    readonly createdAt: FieldRef<"notification", 'DateTime'>
    readonly userId: FieldRef<"notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification createManyAndReturn
   */
  export type notificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notification updateManyAndReturn
   */
  export type notificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model tournament
   */

  export type AggregateTournament = {
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  export type TournamentAvgAggregateOutputType = {
    entryFee: number | null
    prizePool: number | null
  }

  export type TournamentSumAggregateOutputType = {
    entryFee: number | null
    prizePool: number | null
  }

  export type TournamentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    entryFee: number | null
    prizePool: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type TournamentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    entryFee: number | null
    prizePool: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type TournamentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startTime: number
    endTime: number
    entryFee: number
    prizePool: number
    isActive: number
    createdAt: number
    updatedAt: number
    operatorId: number
    leaderboard: number
    _all: number
  }


  export type TournamentAvgAggregateInputType = {
    entryFee?: true
    prizePool?: true
  }

  export type TournamentSumAggregateInputType = {
    entryFee?: true
    prizePool?: true
  }

  export type TournamentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type TournamentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type TournamentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
    leaderboard?: true
    _all?: true
  }

  export type TournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournament to aggregate.
     */
    where?: tournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournaments
    **/
    _count?: true | TournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentMaxAggregateInputType
  }

  export type GetTournamentAggregateType<T extends TournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament[P]>
      : GetScalarType<T[P], AggregateTournament[P]>
  }




  export type tournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentWhereInput
    orderBy?: tournamentOrderByWithAggregationInput | tournamentOrderByWithAggregationInput[]
    by: TournamentScalarFieldEnum[] | TournamentScalarFieldEnum
    having?: tournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentCountAggregateInputType | true
    _avg?: TournamentAvgAggregateInputType
    _sum?: TournamentSumAggregateInputType
    _min?: TournamentMinAggregateInputType
    _max?: TournamentMaxAggregateInputType
  }

  export type TournamentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startTime: Date
    endTime: Date
    entryFee: number | null
    prizePool: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date | null
    operatorId: string
    leaderboard: JsonValue | null
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  type GetTournamentGroupByPayload<T extends tournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentGroupByOutputType[P]>
        }
      >
    >


  export type tournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
    gamesession?: boolean | tournament$gamesessionArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    tournamententry?: boolean | tournament$tournamententryArgs<ExtArgs>
    tournamentgame?: boolean | tournament$tournamentgameArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type tournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type tournamentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type tournamentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
  }

  export type tournamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "startTime" | "endTime" | "entryFee" | "prizePool" | "isActive" | "createdAt" | "updatedAt" | "operatorId" | "leaderboard", ExtArgs["result"]["tournament"]>
  export type tournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | tournament$gamesessionArgs<ExtArgs>
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
    tournamententry?: boolean | tournament$tournamententryArgs<ExtArgs>
    tournamentgame?: boolean | tournament$tournamentgameArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }
  export type tournamentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | OperatorDefaultArgs<ExtArgs>
  }

  export type $tournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournament"
    objects: {
      gamesession: Prisma.$gamesessionPayload<ExtArgs>[]
      operator: Prisma.$OperatorPayload<ExtArgs>
      tournamententry: Prisma.$tournamententryPayload<ExtArgs>[]
      tournamentgame: Prisma.$tournamentgamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startTime: Date
      endTime: Date
      entryFee: number | null
      prizePool: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date | null
      operatorId: string
      leaderboard: Prisma.JsonValue | null
    }, ExtArgs["result"]["tournament"]>
    composites: {}
  }

  type tournamentGetPayload<S extends boolean | null | undefined | tournamentDefaultArgs> = $Result.GetResult<Prisma.$tournamentPayload, S>

  type tournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tournamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentCountAggregateInputType | true
    }

  export interface tournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournament'], meta: { name: 'tournament' } }
    /**
     * Find zero or one Tournament that matches the filter.
     * @param {tournamentFindUniqueArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamentFindUniqueArgs>(args: SelectSubset<T, tournamentFindUniqueArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tournamentFindUniqueOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentFindFirstArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamentFindFirstArgs>(args?: SelectSubset<T, tournamentFindFirstArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentFindFirstOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournament.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentWithIdOnly = await prisma.tournament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamentFindManyArgs>(args?: SelectSubset<T, tournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournament.
     * @param {tournamentCreateArgs} args - Arguments to create a Tournament.
     * @example
     * // Create one Tournament
     * const Tournament = await prisma.tournament.create({
     *   data: {
     *     // ... data to create a Tournament
     *   }
     * })
     * 
     */
    create<T extends tournamentCreateArgs>(args: SelectSubset<T, tournamentCreateArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournaments.
     * @param {tournamentCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamentCreateManyArgs>(args?: SelectSubset<T, tournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {tournamentCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournament.
     * @param {tournamentDeleteArgs} args - Arguments to delete one Tournament.
     * @example
     * // Delete one Tournament
     * const Tournament = await prisma.tournament.delete({
     *   where: {
     *     // ... filter to delete one Tournament
     *   }
     * })
     * 
     */
    delete<T extends tournamentDeleteArgs>(args: SelectSubset<T, tournamentDeleteArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournament.
     * @param {tournamentUpdateArgs} args - Arguments to update one Tournament.
     * @example
     * // Update one Tournament
     * const tournament = await prisma.tournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamentUpdateArgs>(args: SelectSubset<T, tournamentUpdateArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournaments.
     * @param {tournamentDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamentDeleteManyArgs>(args?: SelectSubset<T, tournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamentUpdateManyArgs>(args: SelectSubset<T, tournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments and returns the data updated in the database.
     * @param {tournamentUpdateManyAndReturnArgs} args - Arguments to update many Tournaments.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tournamentUpdateManyAndReturnArgs>(args: SelectSubset<T, tournamentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournament.
     * @param {tournamentUpsertArgs} args - Arguments to update or create a Tournament.
     * @example
     * // Update or create a Tournament
     * const tournament = await prisma.tournament.upsert({
     *   create: {
     *     // ... data to create a Tournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament we want to update
     *   }
     * })
     */
    upsert<T extends tournamentUpsertArgs>(args: SelectSubset<T, tournamentUpsertArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournament.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends tournamentCountArgs>(
      args?: Subset<T, tournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentAggregateArgs>(args: Subset<T, TournamentAggregateArgs>): Prisma.PrismaPromise<GetTournamentAggregateType<T>>

    /**
     * Group by Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamentGroupByArgs['orderBy'] }
        : { orderBy?: tournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournament model
   */
  readonly fields: tournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends tournament$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, tournament$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operator<T extends OperatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperatorDefaultArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournamententry<T extends tournament$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, tournament$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamentgame<T extends tournament$tournamentgameArgs<ExtArgs> = {}>(args?: Subset<T, tournament$tournamentgameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournament model
   */
  interface tournamentFieldRefs {
    readonly id: FieldRef<"tournament", 'String'>
    readonly name: FieldRef<"tournament", 'String'>
    readonly description: FieldRef<"tournament", 'String'>
    readonly startTime: FieldRef<"tournament", 'DateTime'>
    readonly endTime: FieldRef<"tournament", 'DateTime'>
    readonly entryFee: FieldRef<"tournament", 'Int'>
    readonly prizePool: FieldRef<"tournament", 'Int'>
    readonly isActive: FieldRef<"tournament", 'Boolean'>
    readonly createdAt: FieldRef<"tournament", 'DateTime'>
    readonly updatedAt: FieldRef<"tournament", 'DateTime'>
    readonly operatorId: FieldRef<"tournament", 'String'>
    readonly leaderboard: FieldRef<"tournament", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * tournament findUnique
   */
  export type tournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournament to fetch.
     */
    where: tournamentWhereUniqueInput
  }

  /**
   * tournament findUniqueOrThrow
   */
  export type tournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournament to fetch.
     */
    where: tournamentWhereUniqueInput
  }

  /**
   * tournament findFirst
   */
  export type tournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournament to fetch.
     */
    where?: tournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * tournament findFirstOrThrow
   */
  export type tournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournament to fetch.
     */
    where?: tournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * tournament findMany
   */
  export type tournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournaments.
     */
    cursor?: tournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * tournament create
   */
  export type tournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a tournament.
     */
    data: XOR<tournamentCreateInput, tournamentUncheckedCreateInput>
  }

  /**
   * tournament createMany
   */
  export type tournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournaments.
     */
    data: tournamentCreateManyInput | tournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournament createManyAndReturn
   */
  export type tournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * The data used to create many tournaments.
     */
    data: tournamentCreateManyInput | tournamentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournament update
   */
  export type tournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a tournament.
     */
    data: XOR<tournamentUpdateInput, tournamentUncheckedUpdateInput>
    /**
     * Choose, which tournament to update.
     */
    where: tournamentWhereUniqueInput
  }

  /**
   * tournament updateMany
   */
  export type tournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournaments.
     */
    data: XOR<tournamentUpdateManyMutationInput, tournamentUncheckedUpdateManyInput>
    /**
     * Filter which tournaments to update
     */
    where?: tournamentWhereInput
    /**
     * Limit how many tournaments to update.
     */
    limit?: number
  }

  /**
   * tournament updateManyAndReturn
   */
  export type tournamentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * The data used to update tournaments.
     */
    data: XOR<tournamentUpdateManyMutationInput, tournamentUncheckedUpdateManyInput>
    /**
     * Filter which tournaments to update
     */
    where?: tournamentWhereInput
    /**
     * Limit how many tournaments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournament upsert
   */
  export type tournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the tournament to update in case it exists.
     */
    where: tournamentWhereUniqueInput
    /**
     * In case the tournament found by the `where` argument doesn't exist, create a new tournament with this data.
     */
    create: XOR<tournamentCreateInput, tournamentUncheckedCreateInput>
    /**
     * In case the tournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamentUpdateInput, tournamentUncheckedUpdateInput>
  }

  /**
   * tournament delete
   */
  export type tournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter which tournament to delete.
     */
    where: tournamentWhereUniqueInput
  }

  /**
   * tournament deleteMany
   */
  export type tournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournaments to delete
     */
    where?: tournamentWhereInput
    /**
     * Limit how many tournaments to delete.
     */
    limit?: number
  }

  /**
   * tournament.gamesession
   */
  export type tournament$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    cursor?: gamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * tournament.tournamententry
   */
  export type tournament$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    where?: tournamententryWhereInput
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    cursor?: tournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * tournament.tournamentgame
   */
  export type tournament$tournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    where?: tournamentgameWhereInput
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    cursor?: tournamentgameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * tournament without action
   */
  export type tournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
  }


  /**
   * Model tournamententry
   */

  export type AggregateTournamententry = {
    _count: TournamententryCountAggregateOutputType | null
    _avg: TournamententryAvgAggregateOutputType | null
    _sum: TournamententrySumAggregateOutputType | null
    _min: TournamententryMinAggregateOutputType | null
    _max: TournamententryMaxAggregateOutputType | null
  }

  export type TournamententryAvgAggregateOutputType = {
    score: number | null
    wagered: number | null
    won: number | null
  }

  export type TournamententrySumAggregateOutputType = {
    score: number | null
    wagered: number | null
    won: number | null
  }

  export type TournamententryMinAggregateOutputType = {
    id: string | null
    score: number | null
    wagered: number | null
    won: number | null
    joinedAt: Date | null
    userId: string | null
    tournamentId: string | null
    profileId: string | null
  }

  export type TournamententryMaxAggregateOutputType = {
    id: string | null
    score: number | null
    wagered: number | null
    won: number | null
    joinedAt: Date | null
    userId: string | null
    tournamentId: string | null
    profileId: string | null
  }

  export type TournamententryCountAggregateOutputType = {
    id: number
    score: number
    wagered: number
    won: number
    joinedAt: number
    userId: number
    tournamentId: number
    profileId: number
    _all: number
  }


  export type TournamententryAvgAggregateInputType = {
    score?: true
    wagered?: true
    won?: true
  }

  export type TournamententrySumAggregateInputType = {
    score?: true
    wagered?: true
    won?: true
  }

  export type TournamententryMinAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
  }

  export type TournamententryMaxAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
  }

  export type TournamententryCountAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
    _all?: true
  }

  export type TournamententryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournamententry to aggregate.
     */
    where?: tournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamententries to fetch.
     */
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournamententries
    **/
    _count?: true | TournamententryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamententryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamententrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamententryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamententryMaxAggregateInputType
  }

  export type GetTournamententryAggregateType<T extends TournamententryAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamententry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamententry[P]>
      : GetScalarType<T[P], AggregateTournamententry[P]>
  }




  export type tournamententryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamententryWhereInput
    orderBy?: tournamententryOrderByWithAggregationInput | tournamententryOrderByWithAggregationInput[]
    by: TournamententryScalarFieldEnum[] | TournamententryScalarFieldEnum
    having?: tournamententryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamententryCountAggregateInputType | true
    _avg?: TournamententryAvgAggregateInputType
    _sum?: TournamententrySumAggregateInputType
    _min?: TournamententryMinAggregateInputType
    _max?: TournamententryMaxAggregateInputType
  }

  export type TournamententryGroupByOutputType = {
    id: string
    score: number
    wagered: number
    won: number
    joinedAt: Date
    userId: string
    tournamentId: string
    profileId: string
    _count: TournamententryCountAggregateOutputType | null
    _avg: TournamententryAvgAggregateOutputType | null
    _sum: TournamententrySumAggregateOutputType | null
    _min: TournamententryMinAggregateOutputType | null
    _max: TournamententryMaxAggregateOutputType | null
  }

  type GetTournamententryGroupByPayload<T extends tournamententryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamententryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamententryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamententryGroupByOutputType[P]>
            : GetScalarType<T[P], TournamententryGroupByOutputType[P]>
        }
      >
    >


  export type tournamententrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamententry"]>

  export type tournamententrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamententry"]>

  export type tournamententrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamententry"]>

  export type tournamententrySelectScalar = {
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
  }

  export type tournamententryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "score" | "wagered" | "won" | "joinedAt" | "userId" | "tournamentId" | "profileId", ExtArgs["result"]["tournamententry"]>
  export type tournamententryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type tournamententryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type tournamententryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $tournamententryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournamententry"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      tournament: Prisma.$tournamentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      score: number
      wagered: number
      won: number
      joinedAt: Date
      userId: string
      tournamentId: string
      profileId: string
    }, ExtArgs["result"]["tournamententry"]>
    composites: {}
  }

  type tournamententryGetPayload<S extends boolean | null | undefined | tournamententryDefaultArgs> = $Result.GetResult<Prisma.$tournamententryPayload, S>

  type tournamententryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tournamententryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamententryCountAggregateInputType | true
    }

  export interface tournamententryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournamententry'], meta: { name: 'tournamententry' } }
    /**
     * Find zero or one Tournamententry that matches the filter.
     * @param {tournamententryFindUniqueArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamententryFindUniqueArgs>(args: SelectSubset<T, tournamententryFindUniqueArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournamententry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tournamententryFindUniqueOrThrowArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamententryFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamententryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournamententry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryFindFirstArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamententryFindFirstArgs>(args?: SelectSubset<T, tournamententryFindFirstArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournamententry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryFindFirstOrThrowArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamententryFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamententryFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournamententries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournamententries
     * const tournamententries = await prisma.tournamententry.findMany()
     * 
     * // Get first 10 Tournamententries
     * const tournamententries = await prisma.tournamententry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamententryWithIdOnly = await prisma.tournamententry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamententryFindManyArgs>(args?: SelectSubset<T, tournamententryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournamententry.
     * @param {tournamententryCreateArgs} args - Arguments to create a Tournamententry.
     * @example
     * // Create one Tournamententry
     * const Tournamententry = await prisma.tournamententry.create({
     *   data: {
     *     // ... data to create a Tournamententry
     *   }
     * })
     * 
     */
    create<T extends tournamententryCreateArgs>(args: SelectSubset<T, tournamententryCreateArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournamententries.
     * @param {tournamententryCreateManyArgs} args - Arguments to create many Tournamententries.
     * @example
     * // Create many Tournamententries
     * const tournamententry = await prisma.tournamententry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamententryCreateManyArgs>(args?: SelectSubset<T, tournamententryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournamententries and returns the data saved in the database.
     * @param {tournamententryCreateManyAndReturnArgs} args - Arguments to create many Tournamententries.
     * @example
     * // Create many Tournamententries
     * const tournamententry = await prisma.tournamententry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournamententries and only return the `id`
     * const tournamententryWithIdOnly = await prisma.tournamententry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamententryCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamententryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournamententry.
     * @param {tournamententryDeleteArgs} args - Arguments to delete one Tournamententry.
     * @example
     * // Delete one Tournamententry
     * const Tournamententry = await prisma.tournamententry.delete({
     *   where: {
     *     // ... filter to delete one Tournamententry
     *   }
     * })
     * 
     */
    delete<T extends tournamententryDeleteArgs>(args: SelectSubset<T, tournamententryDeleteArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournamententry.
     * @param {tournamententryUpdateArgs} args - Arguments to update one Tournamententry.
     * @example
     * // Update one Tournamententry
     * const tournamententry = await prisma.tournamententry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamententryUpdateArgs>(args: SelectSubset<T, tournamententryUpdateArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournamententries.
     * @param {tournamententryDeleteManyArgs} args - Arguments to filter Tournamententries to delete.
     * @example
     * // Delete a few Tournamententries
     * const { count } = await prisma.tournamententry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamententryDeleteManyArgs>(args?: SelectSubset<T, tournamententryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamententries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournamententries
     * const tournamententry = await prisma.tournamententry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamententryUpdateManyArgs>(args: SelectSubset<T, tournamententryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamententries and returns the data updated in the database.
     * @param {tournamententryUpdateManyAndReturnArgs} args - Arguments to update many Tournamententries.
     * @example
     * // Update many Tournamententries
     * const tournamententry = await prisma.tournamententry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournamententries and only return the `id`
     * const tournamententryWithIdOnly = await prisma.tournamententry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tournamententryUpdateManyAndReturnArgs>(args: SelectSubset<T, tournamententryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournamententry.
     * @param {tournamententryUpsertArgs} args - Arguments to update or create a Tournamententry.
     * @example
     * // Update or create a Tournamententry
     * const tournamententry = await prisma.tournamententry.upsert({
     *   create: {
     *     // ... data to create a Tournamententry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournamententry we want to update
     *   }
     * })
     */
    upsert<T extends tournamententryUpsertArgs>(args: SelectSubset<T, tournamententryUpsertArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournamententries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryCountArgs} args - Arguments to filter Tournamententries to count.
     * @example
     * // Count the number of Tournamententries
     * const count = await prisma.tournamententry.count({
     *   where: {
     *     // ... the filter for the Tournamententries we want to count
     *   }
     * })
    **/
    count<T extends tournamententryCountArgs>(
      args?: Subset<T, tournamententryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamententryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournamententry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamententryAggregateArgs>(args: Subset<T, TournamententryAggregateArgs>): Prisma.PrismaPromise<GetTournamententryAggregateType<T>>

    /**
     * Group by Tournamententry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamententryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamententryGroupByArgs['orderBy'] }
        : { orderBy?: tournamententryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamententryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamententryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournamententry model
   */
  readonly fields: tournamententryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournamententry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamententryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends tournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tournamentDefaultArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournamententry model
   */
  interface tournamententryFieldRefs {
    readonly id: FieldRef<"tournamententry", 'String'>
    readonly score: FieldRef<"tournamententry", 'Int'>
    readonly wagered: FieldRef<"tournamententry", 'Int'>
    readonly won: FieldRef<"tournamententry", 'Int'>
    readonly joinedAt: FieldRef<"tournamententry", 'DateTime'>
    readonly userId: FieldRef<"tournamententry", 'String'>
    readonly tournamentId: FieldRef<"tournamententry", 'String'>
    readonly profileId: FieldRef<"tournamententry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tournamententry findUnique
   */
  export type tournamententryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententry to fetch.
     */
    where: tournamententryWhereUniqueInput
  }

  /**
   * tournamententry findUniqueOrThrow
   */
  export type tournamententryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententry to fetch.
     */
    where: tournamententryWhereUniqueInput
  }

  /**
   * tournamententry findFirst
   */
  export type tournamententryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententry to fetch.
     */
    where?: tournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamententries to fetch.
     */
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournamententries.
     */
    cursor?: tournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournamententries.
     */
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * tournamententry findFirstOrThrow
   */
  export type tournamententryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententry to fetch.
     */
    where?: tournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamententries to fetch.
     */
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournamententries.
     */
    cursor?: tournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournamententries.
     */
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * tournamententry findMany
   */
  export type tournamententryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententries to fetch.
     */
    where?: tournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamententries to fetch.
     */
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournamententries.
     */
    cursor?: tournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamententries.
     */
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * tournamententry create
   */
  export type tournamententryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * The data needed to create a tournamententry.
     */
    data: XOR<tournamententryCreateInput, tournamententryUncheckedCreateInput>
  }

  /**
   * tournamententry createMany
   */
  export type tournamententryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournamententries.
     */
    data: tournamententryCreateManyInput | tournamententryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournamententry createManyAndReturn
   */
  export type tournamententryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * The data used to create many tournamententries.
     */
    data: tournamententryCreateManyInput | tournamententryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournamententry update
   */
  export type tournamententryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * The data needed to update a tournamententry.
     */
    data: XOR<tournamententryUpdateInput, tournamententryUncheckedUpdateInput>
    /**
     * Choose, which tournamententry to update.
     */
    where: tournamententryWhereUniqueInput
  }

  /**
   * tournamententry updateMany
   */
  export type tournamententryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournamententries.
     */
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyInput>
    /**
     * Filter which tournamententries to update
     */
    where?: tournamententryWhereInput
    /**
     * Limit how many tournamententries to update.
     */
    limit?: number
  }

  /**
   * tournamententry updateManyAndReturn
   */
  export type tournamententryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * The data used to update tournamententries.
     */
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyInput>
    /**
     * Filter which tournamententries to update
     */
    where?: tournamententryWhereInput
    /**
     * Limit how many tournamententries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournamententry upsert
   */
  export type tournamententryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * The filter to search for the tournamententry to update in case it exists.
     */
    where: tournamententryWhereUniqueInput
    /**
     * In case the tournamententry found by the `where` argument doesn't exist, create a new tournamententry with this data.
     */
    create: XOR<tournamententryCreateInput, tournamententryUncheckedCreateInput>
    /**
     * In case the tournamententry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamententryUpdateInput, tournamententryUncheckedUpdateInput>
  }

  /**
   * tournamententry delete
   */
  export type tournamententryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter which tournamententry to delete.
     */
    where: tournamententryWhereUniqueInput
  }

  /**
   * tournamententry deleteMany
   */
  export type tournamententryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournamententries to delete
     */
    where?: tournamententryWhereInput
    /**
     * Limit how many tournamententries to delete.
     */
    limit?: number
  }

  /**
   * tournamententry without action
   */
  export type tournamententryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
  }


  /**
   * Model tournamentgame
   */

  export type AggregateTournamentgame = {
    _count: TournamentgameCountAggregateOutputType | null
    _avg: TournamentgameAvgAggregateOutputType | null
    _sum: TournamentgameSumAggregateOutputType | null
    _min: TournamentgameMinAggregateOutputType | null
    _max: TournamentgameMaxAggregateOutputType | null
  }

  export type TournamentgameAvgAggregateOutputType = {
    multiplier: number | null
  }

  export type TournamentgameSumAggregateOutputType = {
    multiplier: number | null
  }

  export type TournamentgameMinAggregateOutputType = {
    id: string | null
    multiplier: number | null
    tournamentId: string | null
    gameId: string | null
  }

  export type TournamentgameMaxAggregateOutputType = {
    id: string | null
    multiplier: number | null
    tournamentId: string | null
    gameId: string | null
  }

  export type TournamentgameCountAggregateOutputType = {
    id: number
    multiplier: number
    tournamentId: number
    gameId: number
    _all: number
  }


  export type TournamentgameAvgAggregateInputType = {
    multiplier?: true
  }

  export type TournamentgameSumAggregateInputType = {
    multiplier?: true
  }

  export type TournamentgameMinAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
  }

  export type TournamentgameMaxAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
  }

  export type TournamentgameCountAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
    _all?: true
  }

  export type TournamentgameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournamentgame to aggregate.
     */
    where?: tournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamentgames to fetch.
     */
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournamentgames
    **/
    _count?: true | TournamentgameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentgameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentgameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentgameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentgameMaxAggregateInputType
  }

  export type GetTournamentgameAggregateType<T extends TournamentgameAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentgame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentgame[P]>
      : GetScalarType<T[P], AggregateTournamentgame[P]>
  }




  export type tournamentgameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentgameWhereInput
    orderBy?: tournamentgameOrderByWithAggregationInput | tournamentgameOrderByWithAggregationInput[]
    by: TournamentgameScalarFieldEnum[] | TournamentgameScalarFieldEnum
    having?: tournamentgameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentgameCountAggregateInputType | true
    _avg?: TournamentgameAvgAggregateInputType
    _sum?: TournamentgameSumAggregateInputType
    _min?: TournamentgameMinAggregateInputType
    _max?: TournamentgameMaxAggregateInputType
  }

  export type TournamentgameGroupByOutputType = {
    id: string
    multiplier: number
    tournamentId: string
    gameId: string
    _count: TournamentgameCountAggregateOutputType | null
    _avg: TournamentgameAvgAggregateOutputType | null
    _sum: TournamentgameSumAggregateOutputType | null
    _min: TournamentgameMinAggregateOutputType | null
    _max: TournamentgameMaxAggregateOutputType | null
  }

  type GetTournamentgameGroupByPayload<T extends tournamentgameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentgameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentgameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentgameGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentgameGroupByOutputType[P]>
        }
      >
    >


  export type tournamentgameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentgame"]>

  export type tournamentgameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentgame"]>

  export type tournamentgameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentgame"]>

  export type tournamentgameSelectScalar = {
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
  }

  export type tournamentgameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "multiplier" | "tournamentId" | "gameId", ExtArgs["result"]["tournamentgame"]>
  export type tournamentgameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }
  export type tournamentgameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }
  export type tournamentgameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }

  export type $tournamentgamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournamentgame"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      tournament: Prisma.$tournamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      multiplier: number
      tournamentId: string
      gameId: string
    }, ExtArgs["result"]["tournamentgame"]>
    composites: {}
  }

  type tournamentgameGetPayload<S extends boolean | null | undefined | tournamentgameDefaultArgs> = $Result.GetResult<Prisma.$tournamentgamePayload, S>

  type tournamentgameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tournamentgameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentgameCountAggregateInputType | true
    }

  export interface tournamentgameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournamentgame'], meta: { name: 'tournamentgame' } }
    /**
     * Find zero or one Tournamentgame that matches the filter.
     * @param {tournamentgameFindUniqueArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamentgameFindUniqueArgs>(args: SelectSubset<T, tournamentgameFindUniqueArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournamentgame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tournamentgameFindUniqueOrThrowArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamentgameFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamentgameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournamentgame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameFindFirstArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamentgameFindFirstArgs>(args?: SelectSubset<T, tournamentgameFindFirstArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournamentgame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameFindFirstOrThrowArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamentgameFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamentgameFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournamentgames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournamentgames
     * const tournamentgames = await prisma.tournamentgame.findMany()
     * 
     * // Get first 10 Tournamentgames
     * const tournamentgames = await prisma.tournamentgame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentgameWithIdOnly = await prisma.tournamentgame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamentgameFindManyArgs>(args?: SelectSubset<T, tournamentgameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournamentgame.
     * @param {tournamentgameCreateArgs} args - Arguments to create a Tournamentgame.
     * @example
     * // Create one Tournamentgame
     * const Tournamentgame = await prisma.tournamentgame.create({
     *   data: {
     *     // ... data to create a Tournamentgame
     *   }
     * })
     * 
     */
    create<T extends tournamentgameCreateArgs>(args: SelectSubset<T, tournamentgameCreateArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournamentgames.
     * @param {tournamentgameCreateManyArgs} args - Arguments to create many Tournamentgames.
     * @example
     * // Create many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamentgameCreateManyArgs>(args?: SelectSubset<T, tournamentgameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournamentgames and returns the data saved in the database.
     * @param {tournamentgameCreateManyAndReturnArgs} args - Arguments to create many Tournamentgames.
     * @example
     * // Create many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournamentgames and only return the `id`
     * const tournamentgameWithIdOnly = await prisma.tournamentgame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamentgameCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamentgameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournamentgame.
     * @param {tournamentgameDeleteArgs} args - Arguments to delete one Tournamentgame.
     * @example
     * // Delete one Tournamentgame
     * const Tournamentgame = await prisma.tournamentgame.delete({
     *   where: {
     *     // ... filter to delete one Tournamentgame
     *   }
     * })
     * 
     */
    delete<T extends tournamentgameDeleteArgs>(args: SelectSubset<T, tournamentgameDeleteArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournamentgame.
     * @param {tournamentgameUpdateArgs} args - Arguments to update one Tournamentgame.
     * @example
     * // Update one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamentgameUpdateArgs>(args: SelectSubset<T, tournamentgameUpdateArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournamentgames.
     * @param {tournamentgameDeleteManyArgs} args - Arguments to filter Tournamentgames to delete.
     * @example
     * // Delete a few Tournamentgames
     * const { count } = await prisma.tournamentgame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamentgameDeleteManyArgs>(args?: SelectSubset<T, tournamentgameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamentgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamentgameUpdateManyArgs>(args: SelectSubset<T, tournamentgameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamentgames and returns the data updated in the database.
     * @param {tournamentgameUpdateManyAndReturnArgs} args - Arguments to update many Tournamentgames.
     * @example
     * // Update many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournamentgames and only return the `id`
     * const tournamentgameWithIdOnly = await prisma.tournamentgame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tournamentgameUpdateManyAndReturnArgs>(args: SelectSubset<T, tournamentgameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournamentgame.
     * @param {tournamentgameUpsertArgs} args - Arguments to update or create a Tournamentgame.
     * @example
     * // Update or create a Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.upsert({
     *   create: {
     *     // ... data to create a Tournamentgame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournamentgame we want to update
     *   }
     * })
     */
    upsert<T extends tournamentgameUpsertArgs>(args: SelectSubset<T, tournamentgameUpsertArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournamentgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameCountArgs} args - Arguments to filter Tournamentgames to count.
     * @example
     * // Count the number of Tournamentgames
     * const count = await prisma.tournamentgame.count({
     *   where: {
     *     // ... the filter for the Tournamentgames we want to count
     *   }
     * })
    **/
    count<T extends tournamentgameCountArgs>(
      args?: Subset<T, tournamentgameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentgameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournamentgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentgameAggregateArgs>(args: Subset<T, TournamentgameAggregateArgs>): Prisma.PrismaPromise<GetTournamentgameAggregateType<T>>

    /**
     * Group by Tournamentgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamentgameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamentgameGroupByArgs['orderBy'] }
        : { orderBy?: tournamentgameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamentgameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentgameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournamentgame model
   */
  readonly fields: tournamentgameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournamentgame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamentgameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends tournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tournamentDefaultArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournamentgame model
   */
  interface tournamentgameFieldRefs {
    readonly id: FieldRef<"tournamentgame", 'String'>
    readonly multiplier: FieldRef<"tournamentgame", 'Float'>
    readonly tournamentId: FieldRef<"tournamentgame", 'String'>
    readonly gameId: FieldRef<"tournamentgame", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tournamentgame findUnique
   */
  export type tournamentgameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgame to fetch.
     */
    where: tournamentgameWhereUniqueInput
  }

  /**
   * tournamentgame findUniqueOrThrow
   */
  export type tournamentgameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgame to fetch.
     */
    where: tournamentgameWhereUniqueInput
  }

  /**
   * tournamentgame findFirst
   */
  export type tournamentgameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgame to fetch.
     */
    where?: tournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamentgames to fetch.
     */
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournamentgames.
     */
    cursor?: tournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournamentgames.
     */
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * tournamentgame findFirstOrThrow
   */
  export type tournamentgameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgame to fetch.
     */
    where?: tournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamentgames to fetch.
     */
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournamentgames.
     */
    cursor?: tournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournamentgames.
     */
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * tournamentgame findMany
   */
  export type tournamentgameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgames to fetch.
     */
    where?: tournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamentgames to fetch.
     */
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournamentgames.
     */
    cursor?: tournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamentgames.
     */
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * tournamentgame create
   */
  export type tournamentgameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * The data needed to create a tournamentgame.
     */
    data: XOR<tournamentgameCreateInput, tournamentgameUncheckedCreateInput>
  }

  /**
   * tournamentgame createMany
   */
  export type tournamentgameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournamentgames.
     */
    data: tournamentgameCreateManyInput | tournamentgameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournamentgame createManyAndReturn
   */
  export type tournamentgameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * The data used to create many tournamentgames.
     */
    data: tournamentgameCreateManyInput | tournamentgameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournamentgame update
   */
  export type tournamentgameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * The data needed to update a tournamentgame.
     */
    data: XOR<tournamentgameUpdateInput, tournamentgameUncheckedUpdateInput>
    /**
     * Choose, which tournamentgame to update.
     */
    where: tournamentgameWhereUniqueInput
  }

  /**
   * tournamentgame updateMany
   */
  export type tournamentgameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournamentgames.
     */
    data: XOR<tournamentgameUpdateManyMutationInput, tournamentgameUncheckedUpdateManyInput>
    /**
     * Filter which tournamentgames to update
     */
    where?: tournamentgameWhereInput
    /**
     * Limit how many tournamentgames to update.
     */
    limit?: number
  }

  /**
   * tournamentgame updateManyAndReturn
   */
  export type tournamentgameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * The data used to update tournamentgames.
     */
    data: XOR<tournamentgameUpdateManyMutationInput, tournamentgameUncheckedUpdateManyInput>
    /**
     * Filter which tournamentgames to update
     */
    where?: tournamentgameWhereInput
    /**
     * Limit how many tournamentgames to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournamentgame upsert
   */
  export type tournamentgameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * The filter to search for the tournamentgame to update in case it exists.
     */
    where: tournamentgameWhereUniqueInput
    /**
     * In case the tournamentgame found by the `where` argument doesn't exist, create a new tournamentgame with this data.
     */
    create: XOR<tournamentgameCreateInput, tournamentgameUncheckedCreateInput>
    /**
     * In case the tournamentgame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamentgameUpdateInput, tournamentgameUncheckedUpdateInput>
  }

  /**
   * tournamentgame delete
   */
  export type tournamentgameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter which tournamentgame to delete.
     */
    where: tournamentgameWhereUniqueInput
  }

  /**
   * tournamentgame deleteMany
   */
  export type tournamentgameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournamentgames to delete
     */
    where?: tournamentgameWhereInput
    /**
     * Limit how many tournamentgames to delete.
     */
    limit?: number
  }

  /**
   * tournamentgame without action
   */
  export type tournamentgameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    reference: string | null
    status: $Enums.TransactionStatus | null
    isRealMoney: boolean | null
    paymentMethod: string | null
    createdAt: Date | null
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    reference: string | null
    status: $Enums.TransactionStatus | null
    isRealMoney: boolean | null
    paymentMethod: string | null
    createdAt: Date | null
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    reference: number
    status: number
    metadata: number
    isRealMoney: number
    paymentMethod: number
    paymentDetails: number
    createdAt: number
    processedAt: number
    gameSessionId: number
    profileId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reference?: true
    status?: true
    isRealMoney?: true
    paymentMethod?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reference?: true
    status?: true
    isRealMoney?: true
    paymentMethod?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reference?: true
    status?: true
    metadata?: true
    isRealMoney?: true
    paymentMethod?: true
    paymentDetails?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    type: $Enums.TransactionType
    amount: number
    reference: string | null
    status: $Enums.TransactionStatus
    metadata: JsonValue | null
    isRealMoney: boolean
    paymentMethod: string | null
    paymentDetails: JsonValue | null
    createdAt: Date
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    Product?: boolean | Transaction$ProductArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "amount" | "reference" | "status" | "metadata" | "isRealMoney" | "paymentMethod" | "paymentDetails" | "createdAt" | "processedAt" | "gameSessionId" | "profileId", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    Product?: boolean | Transaction$ProductArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | Transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      gamesession: Prisma.$gamesessionPayload<ExtArgs> | null
      profile: Prisma.$ProfilePayload<ExtArgs>
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.TransactionType
      amount: number
      reference: string | null
      status: $Enums.TransactionStatus
      metadata: Prisma.JsonValue | null
      isRealMoney: boolean
      paymentMethod: string | null
      paymentDetails: Prisma.JsonValue | null
      createdAt: Date
      processedAt: Date | null
      gameSessionId: string | null
      profileId: string
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends Transaction$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$gamesessionArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Product<T extends Transaction$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly amount: FieldRef<"Transaction", 'Int'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly metadata: FieldRef<"Transaction", 'Json'>
    readonly isRealMoney: FieldRef<"Transaction", 'Boolean'>
    readonly paymentMethod: FieldRef<"Transaction", 'String'>
    readonly paymentDetails: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly processedAt: FieldRef<"Transaction", 'DateTime'>
    readonly gameSessionId: FieldRef<"Transaction", 'String'>
    readonly profileId: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.gamesession
   */
  export type Transaction$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
  }

  /**
   * Transaction.Product
   */
  export type Transaction$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model userachievement
   */

  export type AggregateUserachievement = {
    _count: UserachievementCountAggregateOutputType | null
    _avg: UserachievementAvgAggregateOutputType | null
    _sum: UserachievementSumAggregateOutputType | null
    _min: UserachievementMinAggregateOutputType | null
    _max: UserachievementMaxAggregateOutputType | null
  }

  export type UserachievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserachievementSumAggregateOutputType = {
    progress: number | null
  }

  export type UserachievementMinAggregateOutputType = {
    id: string | null
    progress: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    achievementId: string | null
  }

  export type UserachievementMaxAggregateOutputType = {
    id: string | null
    progress: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    achievementId: string | null
  }

  export type UserachievementCountAggregateOutputType = {
    id: number
    progress: number
    isUnlocked: number
    unlockedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    achievementId: number
    _all: number
  }


  export type UserachievementAvgAggregateInputType = {
    progress?: true
  }

  export type UserachievementSumAggregateInputType = {
    progress?: true
  }

  export type UserachievementMinAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
  }

  export type UserachievementMaxAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
  }

  export type UserachievementCountAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
    _all?: true
  }

  export type UserachievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userachievement to aggregate.
     */
    where?: userachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userachievements to fetch.
     */
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userachievements
    **/
    _count?: true | UserachievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserachievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserachievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserachievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserachievementMaxAggregateInputType
  }

  export type GetUserachievementAggregateType<T extends UserachievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserachievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserachievement[P]>
      : GetScalarType<T[P], AggregateUserachievement[P]>
  }




  export type userachievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userachievementWhereInput
    orderBy?: userachievementOrderByWithAggregationInput | userachievementOrderByWithAggregationInput[]
    by: UserachievementScalarFieldEnum[] | UserachievementScalarFieldEnum
    having?: userachievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserachievementCountAggregateInputType | true
    _avg?: UserachievementAvgAggregateInputType
    _sum?: UserachievementSumAggregateInputType
    _min?: UserachievementMinAggregateInputType
    _max?: UserachievementMaxAggregateInputType
  }

  export type UserachievementGroupByOutputType = {
    id: string
    progress: number
    isUnlocked: boolean
    unlockedAt: Date | null
    createdAt: Date
    updatedAt: Date | null
    userId: string
    achievementId: string
    _count: UserachievementCountAggregateOutputType | null
    _avg: UserachievementAvgAggregateOutputType | null
    _sum: UserachievementSumAggregateOutputType | null
    _min: UserachievementMinAggregateOutputType | null
    _max: UserachievementMaxAggregateOutputType | null
  }

  type GetUserachievementGroupByPayload<T extends userachievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserachievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserachievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserachievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserachievementGroupByOutputType[P]>
        }
      >
    >


  export type userachievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userachievement"]>

  export type userachievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userachievement"]>

  export type userachievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userachievement"]>

  export type userachievementSelectScalar = {
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
  }

  export type userachievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "progress" | "isUnlocked" | "unlockedAt" | "createdAt" | "updatedAt" | "userId" | "achievementId", ExtArgs["result"]["userachievement"]>
  export type userachievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type userachievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type userachievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $userachievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userachievement"
    objects: {
      achievement: Prisma.$achievementPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      progress: number
      isUnlocked: boolean
      unlockedAt: Date | null
      createdAt: Date
      updatedAt: Date | null
      userId: string
      achievementId: string
    }, ExtArgs["result"]["userachievement"]>
    composites: {}
  }

  type userachievementGetPayload<S extends boolean | null | undefined | userachievementDefaultArgs> = $Result.GetResult<Prisma.$userachievementPayload, S>

  type userachievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userachievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserachievementCountAggregateInputType | true
    }

  export interface userachievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userachievement'], meta: { name: 'userachievement' } }
    /**
     * Find zero or one Userachievement that matches the filter.
     * @param {userachievementFindUniqueArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userachievementFindUniqueArgs>(args: SelectSubset<T, userachievementFindUniqueArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userachievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userachievementFindUniqueOrThrowArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userachievementFindUniqueOrThrowArgs>(args: SelectSubset<T, userachievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userachievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementFindFirstArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userachievementFindFirstArgs>(args?: SelectSubset<T, userachievementFindFirstArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userachievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementFindFirstOrThrowArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userachievementFindFirstOrThrowArgs>(args?: SelectSubset<T, userachievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userachievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userachievements
     * const userachievements = await prisma.userachievement.findMany()
     * 
     * // Get first 10 Userachievements
     * const userachievements = await prisma.userachievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userachievementWithIdOnly = await prisma.userachievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userachievementFindManyArgs>(args?: SelectSubset<T, userachievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userachievement.
     * @param {userachievementCreateArgs} args - Arguments to create a Userachievement.
     * @example
     * // Create one Userachievement
     * const Userachievement = await prisma.userachievement.create({
     *   data: {
     *     // ... data to create a Userachievement
     *   }
     * })
     * 
     */
    create<T extends userachievementCreateArgs>(args: SelectSubset<T, userachievementCreateArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userachievements.
     * @param {userachievementCreateManyArgs} args - Arguments to create many Userachievements.
     * @example
     * // Create many Userachievements
     * const userachievement = await prisma.userachievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userachievementCreateManyArgs>(args?: SelectSubset<T, userachievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userachievements and returns the data saved in the database.
     * @param {userachievementCreateManyAndReturnArgs} args - Arguments to create many Userachievements.
     * @example
     * // Create many Userachievements
     * const userachievement = await prisma.userachievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userachievements and only return the `id`
     * const userachievementWithIdOnly = await prisma.userachievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userachievementCreateManyAndReturnArgs>(args?: SelectSubset<T, userachievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userachievement.
     * @param {userachievementDeleteArgs} args - Arguments to delete one Userachievement.
     * @example
     * // Delete one Userachievement
     * const Userachievement = await prisma.userachievement.delete({
     *   where: {
     *     // ... filter to delete one Userachievement
     *   }
     * })
     * 
     */
    delete<T extends userachievementDeleteArgs>(args: SelectSubset<T, userachievementDeleteArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userachievement.
     * @param {userachievementUpdateArgs} args - Arguments to update one Userachievement.
     * @example
     * // Update one Userachievement
     * const userachievement = await prisma.userachievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userachievementUpdateArgs>(args: SelectSubset<T, userachievementUpdateArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userachievements.
     * @param {userachievementDeleteManyArgs} args - Arguments to filter Userachievements to delete.
     * @example
     * // Delete a few Userachievements
     * const { count } = await prisma.userachievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userachievementDeleteManyArgs>(args?: SelectSubset<T, userachievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userachievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userachievements
     * const userachievement = await prisma.userachievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userachievementUpdateManyArgs>(args: SelectSubset<T, userachievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userachievements and returns the data updated in the database.
     * @param {userachievementUpdateManyAndReturnArgs} args - Arguments to update many Userachievements.
     * @example
     * // Update many Userachievements
     * const userachievement = await prisma.userachievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userachievements and only return the `id`
     * const userachievementWithIdOnly = await prisma.userachievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userachievementUpdateManyAndReturnArgs>(args: SelectSubset<T, userachievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userachievement.
     * @param {userachievementUpsertArgs} args - Arguments to update or create a Userachievement.
     * @example
     * // Update or create a Userachievement
     * const userachievement = await prisma.userachievement.upsert({
     *   create: {
     *     // ... data to create a Userachievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userachievement we want to update
     *   }
     * })
     */
    upsert<T extends userachievementUpsertArgs>(args: SelectSubset<T, userachievementUpsertArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userachievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementCountArgs} args - Arguments to filter Userachievements to count.
     * @example
     * // Count the number of Userachievements
     * const count = await prisma.userachievement.count({
     *   where: {
     *     // ... the filter for the Userachievements we want to count
     *   }
     * })
    **/
    count<T extends userachievementCountArgs>(
      args?: Subset<T, userachievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserachievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userachievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserachievementAggregateArgs>(args: Subset<T, UserachievementAggregateArgs>): Prisma.PrismaPromise<GetUserachievementAggregateType<T>>

    /**
     * Group by Userachievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userachievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userachievementGroupByArgs['orderBy'] }
        : { orderBy?: userachievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userachievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserachievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userachievement model
   */
  readonly fields: userachievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userachievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userachievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    achievement<T extends achievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, achievementDefaultArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userachievement model
   */
  interface userachievementFieldRefs {
    readonly id: FieldRef<"userachievement", 'String'>
    readonly progress: FieldRef<"userachievement", 'Int'>
    readonly isUnlocked: FieldRef<"userachievement", 'Boolean'>
    readonly unlockedAt: FieldRef<"userachievement", 'DateTime'>
    readonly createdAt: FieldRef<"userachievement", 'DateTime'>
    readonly updatedAt: FieldRef<"userachievement", 'DateTime'>
    readonly userId: FieldRef<"userachievement", 'String'>
    readonly achievementId: FieldRef<"userachievement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * userachievement findUnique
   */
  export type userachievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievement to fetch.
     */
    where: userachievementWhereUniqueInput
  }

  /**
   * userachievement findUniqueOrThrow
   */
  export type userachievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievement to fetch.
     */
    where: userachievementWhereUniqueInput
  }

  /**
   * userachievement findFirst
   */
  export type userachievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievement to fetch.
     */
    where?: userachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userachievements to fetch.
     */
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userachievements.
     */
    cursor?: userachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userachievements.
     */
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * userachievement findFirstOrThrow
   */
  export type userachievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievement to fetch.
     */
    where?: userachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userachievements to fetch.
     */
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userachievements.
     */
    cursor?: userachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userachievements.
     */
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * userachievement findMany
   */
  export type userachievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievements to fetch.
     */
    where?: userachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userachievements to fetch.
     */
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userachievements.
     */
    cursor?: userachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userachievements.
     */
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * userachievement create
   */
  export type userachievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * The data needed to create a userachievement.
     */
    data: XOR<userachievementCreateInput, userachievementUncheckedCreateInput>
  }

  /**
   * userachievement createMany
   */
  export type userachievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userachievements.
     */
    data: userachievementCreateManyInput | userachievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userachievement createManyAndReturn
   */
  export type userachievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * The data used to create many userachievements.
     */
    data: userachievementCreateManyInput | userachievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userachievement update
   */
  export type userachievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * The data needed to update a userachievement.
     */
    data: XOR<userachievementUpdateInput, userachievementUncheckedUpdateInput>
    /**
     * Choose, which userachievement to update.
     */
    where: userachievementWhereUniqueInput
  }

  /**
   * userachievement updateMany
   */
  export type userachievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userachievements.
     */
    data: XOR<userachievementUpdateManyMutationInput, userachievementUncheckedUpdateManyInput>
    /**
     * Filter which userachievements to update
     */
    where?: userachievementWhereInput
    /**
     * Limit how many userachievements to update.
     */
    limit?: number
  }

  /**
   * userachievement updateManyAndReturn
   */
  export type userachievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * The data used to update userachievements.
     */
    data: XOR<userachievementUpdateManyMutationInput, userachievementUncheckedUpdateManyInput>
    /**
     * Filter which userachievements to update
     */
    where?: userachievementWhereInput
    /**
     * Limit how many userachievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userachievement upsert
   */
  export type userachievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * The filter to search for the userachievement to update in case it exists.
     */
    where: userachievementWhereUniqueInput
    /**
     * In case the userachievement found by the `where` argument doesn't exist, create a new userachievement with this data.
     */
    create: XOR<userachievementCreateInput, userachievementUncheckedCreateInput>
    /**
     * In case the userachievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userachievementUpdateInput, userachievementUncheckedUpdateInput>
  }

  /**
   * userachievement delete
   */
  export type userachievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter which userachievement to delete.
     */
    where: userachievementWhereUniqueInput
  }

  /**
   * userachievement deleteMany
   */
  export type userachievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userachievements to delete
     */
    where?: userachievementWhereInput
    /**
     * Limit how many userachievements to delete.
     */
    limit?: number
  }

  /**
   * userachievement without action
   */
  export type userachievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
  }


  /**
   * Model RainBet
   */

  export type AggregateRainBet = {
    _count: RainBetCountAggregateOutputType | null
    _avg: RainBetAvgAggregateOutputType | null
    _sum: RainBetSumAggregateOutputType | null
    _min: RainBetMinAggregateOutputType | null
    _max: RainBetMaxAggregateOutputType | null
  }

  export type RainBetAvgAggregateOutputType = {
    betAmount: number | null
    odds: number | null
  }

  export type RainBetSumAggregateOutputType = {
    betAmount: number | null
    odds: number | null
  }

  export type RainBetMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    betAmount: number | null
    odds: number | null
    outcome: string | null
    settledAt: Date | null
  }

  export type RainBetMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    betAmount: number | null
    odds: number | null
    outcome: string | null
    settledAt: Date | null
  }

  export type RainBetCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    betAmount: number
    odds: number
    outcome: number
    settledAt: number
    _all: number
  }


  export type RainBetAvgAggregateInputType = {
    betAmount?: true
    odds?: true
  }

  export type RainBetSumAggregateInputType = {
    betAmount?: true
    odds?: true
  }

  export type RainBetMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
  }

  export type RainBetMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
  }

  export type RainBetCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
    _all?: true
  }

  export type RainBetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainBet to aggregate.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainBets
    **/
    _count?: true | RainBetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainBetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainBetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainBetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainBetMaxAggregateInputType
  }

  export type GetRainBetAggregateType<T extends RainBetAggregateArgs> = {
        [P in keyof T & keyof AggregateRainBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainBet[P]>
      : GetScalarType<T[P], AggregateRainBet[P]>
  }




  export type RainBetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithAggregationInput | RainBetOrderByWithAggregationInput[]
    by: RainBetScalarFieldEnum[] | RainBetScalarFieldEnum
    having?: RainBetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainBetCountAggregateInputType | true
    _avg?: RainBetAvgAggregateInputType
    _sum?: RainBetSumAggregateInputType
    _min?: RainBetMinAggregateInputType
    _max?: RainBetMaxAggregateInputType
  }

  export type RainBetGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    betAmount: number
    odds: number
    outcome: string | null
    settledAt: Date | null
    _count: RainBetCountAggregateOutputType | null
    _avg: RainBetAvgAggregateOutputType | null
    _sum: RainBetSumAggregateOutputType | null
    _min: RainBetMinAggregateOutputType | null
    _max: RainBetMaxAggregateOutputType | null
  }

  type GetRainBetGroupByPayload<T extends RainBetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainBetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainBetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainBetGroupByOutputType[P]>
            : GetScalarType<T[P], RainBetGroupByOutputType[P]>
        }
      >
    >


  export type RainBetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainBet"]>

  export type RainBetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainBet"]>

  export type RainBetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainBet"]>

  export type RainBetSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
  }

  export type RainBetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rainHistoryId" | "userId" | "betAmount" | "odds" | "outcome" | "settledAt", ExtArgs["result"]["rainBet"]>
  export type RainBetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainBetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainBetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RainBetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainBet"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      betAmount: number
      odds: number
      outcome: string | null
      settledAt: Date | null
    }, ExtArgs["result"]["rainBet"]>
    composites: {}
  }

  type RainBetGetPayload<S extends boolean | null | undefined | RainBetDefaultArgs> = $Result.GetResult<Prisma.$RainBetPayload, S>

  type RainBetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainBetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainBetCountAggregateInputType | true
    }

  export interface RainBetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainBet'], meta: { name: 'RainBet' } }
    /**
     * Find zero or one RainBet that matches the filter.
     * @param {RainBetFindUniqueArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainBetFindUniqueArgs>(args: SelectSubset<T, RainBetFindUniqueArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RainBet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainBetFindUniqueOrThrowArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainBetFindUniqueOrThrowArgs>(args: SelectSubset<T, RainBetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainBet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindFirstArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainBetFindFirstArgs>(args?: SelectSubset<T, RainBetFindFirstArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainBet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindFirstOrThrowArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainBetFindFirstOrThrowArgs>(args?: SelectSubset<T, RainBetFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RainBets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainBets
     * const rainBets = await prisma.rainBet.findMany()
     * 
     * // Get first 10 RainBets
     * const rainBets = await prisma.rainBet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainBetWithIdOnly = await prisma.rainBet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainBetFindManyArgs>(args?: SelectSubset<T, RainBetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RainBet.
     * @param {RainBetCreateArgs} args - Arguments to create a RainBet.
     * @example
     * // Create one RainBet
     * const RainBet = await prisma.rainBet.create({
     *   data: {
     *     // ... data to create a RainBet
     *   }
     * })
     * 
     */
    create<T extends RainBetCreateArgs>(args: SelectSubset<T, RainBetCreateArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RainBets.
     * @param {RainBetCreateManyArgs} args - Arguments to create many RainBets.
     * @example
     * // Create many RainBets
     * const rainBet = await prisma.rainBet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainBetCreateManyArgs>(args?: SelectSubset<T, RainBetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainBets and returns the data saved in the database.
     * @param {RainBetCreateManyAndReturnArgs} args - Arguments to create many RainBets.
     * @example
     * // Create many RainBets
     * const rainBet = await prisma.rainBet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainBets and only return the `id`
     * const rainBetWithIdOnly = await prisma.rainBet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainBetCreateManyAndReturnArgs>(args?: SelectSubset<T, RainBetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RainBet.
     * @param {RainBetDeleteArgs} args - Arguments to delete one RainBet.
     * @example
     * // Delete one RainBet
     * const RainBet = await prisma.rainBet.delete({
     *   where: {
     *     // ... filter to delete one RainBet
     *   }
     * })
     * 
     */
    delete<T extends RainBetDeleteArgs>(args: SelectSubset<T, RainBetDeleteArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RainBet.
     * @param {RainBetUpdateArgs} args - Arguments to update one RainBet.
     * @example
     * // Update one RainBet
     * const rainBet = await prisma.rainBet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainBetUpdateArgs>(args: SelectSubset<T, RainBetUpdateArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RainBets.
     * @param {RainBetDeleteManyArgs} args - Arguments to filter RainBets to delete.
     * @example
     * // Delete a few RainBets
     * const { count } = await prisma.rainBet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainBetDeleteManyArgs>(args?: SelectSubset<T, RainBetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainBets
     * const rainBet = await prisma.rainBet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainBetUpdateManyArgs>(args: SelectSubset<T, RainBetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainBets and returns the data updated in the database.
     * @param {RainBetUpdateManyAndReturnArgs} args - Arguments to update many RainBets.
     * @example
     * // Update many RainBets
     * const rainBet = await prisma.rainBet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RainBets and only return the `id`
     * const rainBetWithIdOnly = await prisma.rainBet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RainBetUpdateManyAndReturnArgs>(args: SelectSubset<T, RainBetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RainBet.
     * @param {RainBetUpsertArgs} args - Arguments to update or create a RainBet.
     * @example
     * // Update or create a RainBet
     * const rainBet = await prisma.rainBet.upsert({
     *   create: {
     *     // ... data to create a RainBet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainBet we want to update
     *   }
     * })
     */
    upsert<T extends RainBetUpsertArgs>(args: SelectSubset<T, RainBetUpsertArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RainBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetCountArgs} args - Arguments to filter RainBets to count.
     * @example
     * // Count the number of RainBets
     * const count = await prisma.rainBet.count({
     *   where: {
     *     // ... the filter for the RainBets we want to count
     *   }
     * })
    **/
    count<T extends RainBetCountArgs>(
      args?: Subset<T, RainBetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainBetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainBetAggregateArgs>(args: Subset<T, RainBetAggregateArgs>): Prisma.PrismaPromise<GetRainBetAggregateType<T>>

    /**
     * Group by RainBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainBetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainBetGroupByArgs['orderBy'] }
        : { orderBy?: RainBetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainBetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainBet model
   */
  readonly fields: RainBetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainBet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainBetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainBet model
   */
  interface RainBetFieldRefs {
    readonly id: FieldRef<"RainBet", 'String'>
    readonly rainHistoryId: FieldRef<"RainBet", 'String'>
    readonly userId: FieldRef<"RainBet", 'String'>
    readonly betAmount: FieldRef<"RainBet", 'Int'>
    readonly odds: FieldRef<"RainBet", 'Int'>
    readonly outcome: FieldRef<"RainBet", 'String'>
    readonly settledAt: FieldRef<"RainBet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainBet findUnique
   */
  export type RainBetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet findUniqueOrThrow
   */
  export type RainBetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet findFirst
   */
  export type RainBetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainBets.
     */
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet findFirstOrThrow
   */
  export type RainBetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainBets.
     */
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet findMany
   */
  export type RainBetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBets to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet create
   */
  export type RainBetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The data needed to create a RainBet.
     */
    data: XOR<RainBetCreateInput, RainBetUncheckedCreateInput>
  }

  /**
   * RainBet createMany
   */
  export type RainBetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainBets.
     */
    data: RainBetCreateManyInput | RainBetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainBet createManyAndReturn
   */
  export type RainBetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * The data used to create many RainBets.
     */
    data: RainBetCreateManyInput | RainBetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainBet update
   */
  export type RainBetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The data needed to update a RainBet.
     */
    data: XOR<RainBetUpdateInput, RainBetUncheckedUpdateInput>
    /**
     * Choose, which RainBet to update.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet updateMany
   */
  export type RainBetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainBets.
     */
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyInput>
    /**
     * Filter which RainBets to update
     */
    where?: RainBetWhereInput
    /**
     * Limit how many RainBets to update.
     */
    limit?: number
  }

  /**
   * RainBet updateManyAndReturn
   */
  export type RainBetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * The data used to update RainBets.
     */
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyInput>
    /**
     * Filter which RainBets to update
     */
    where?: RainBetWhereInput
    /**
     * Limit how many RainBets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainBet upsert
   */
  export type RainBetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The filter to search for the RainBet to update in case it exists.
     */
    where: RainBetWhereUniqueInput
    /**
     * In case the RainBet found by the `where` argument doesn't exist, create a new RainBet with this data.
     */
    create: XOR<RainBetCreateInput, RainBetUncheckedCreateInput>
    /**
     * In case the RainBet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainBetUpdateInput, RainBetUncheckedUpdateInput>
  }

  /**
   * RainBet delete
   */
  export type RainBetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter which RainBet to delete.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet deleteMany
   */
  export type RainBetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainBets to delete
     */
    where?: RainBetWhereInput
    /**
     * Limit how many RainBets to delete.
     */
    limit?: number
  }

  /**
   * RainBet without action
   */
  export type RainBetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
  }


  /**
   * Model RainHistory
   */

  export type AggregateRainHistory = {
    _count: RainHistoryCountAggregateOutputType | null
    _avg: RainHistoryAvgAggregateOutputType | null
    _sum: RainHistorySumAggregateOutputType | null
    _min: RainHistoryMinAggregateOutputType | null
    _max: RainHistoryMaxAggregateOutputType | null
  }

  export type RainHistoryAvgAggregateOutputType = {
    amount: number | null
  }

  export type RainHistorySumAggregateOutputType = {
    amount: number | null
  }

  export type RainHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    rainType: string | null
    createdAt: Date | null
  }

  export type RainHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    rainType: string | null
    createdAt: Date | null
  }

  export type RainHistoryCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    rainType: number
    createdAt: number
    _all: number
  }


  export type RainHistoryAvgAggregateInputType = {
    amount?: true
  }

  export type RainHistorySumAggregateInputType = {
    amount?: true
  }

  export type RainHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
  }

  export type RainHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
  }

  export type RainHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
    _all?: true
  }

  export type RainHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainHistory to aggregate.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainHistories
    **/
    _count?: true | RainHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainHistoryMaxAggregateInputType
  }

  export type GetRainHistoryAggregateType<T extends RainHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRainHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainHistory[P]>
      : GetScalarType<T[P], AggregateRainHistory[P]>
  }




  export type RainHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainHistoryWhereInput
    orderBy?: RainHistoryOrderByWithAggregationInput | RainHistoryOrderByWithAggregationInput[]
    by: RainHistoryScalarFieldEnum[] | RainHistoryScalarFieldEnum
    having?: RainHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainHistoryCountAggregateInputType | true
    _avg?: RainHistoryAvgAggregateInputType
    _sum?: RainHistorySumAggregateInputType
    _min?: RainHistoryMinAggregateInputType
    _max?: RainHistoryMaxAggregateInputType
  }

  export type RainHistoryGroupByOutputType = {
    id: string
    userId: string
    amount: number
    rainType: string
    createdAt: Date
    _count: RainHistoryCountAggregateOutputType | null
    _avg: RainHistoryAvgAggregateOutputType | null
    _sum: RainHistorySumAggregateOutputType | null
    _min: RainHistoryMinAggregateOutputType | null
    _max: RainHistoryMaxAggregateOutputType | null
  }

  type GetRainHistoryGroupByPayload<T extends RainHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], RainHistoryGroupByOutputType[P]>
        }
      >
    >


  export type RainHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
    RainBet?: boolean | RainHistory$RainBetArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    RainTip?: boolean | RainHistory$RainTipArgs<ExtArgs>
    RainWinner?: boolean | RainHistory$RainWinnerArgs<ExtArgs>
    _count?: boolean | RainHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainHistory"]>

  export type RainHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainHistory"]>

  export type RainHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainHistory"]>

  export type RainHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
  }

  export type RainHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "rainType" | "createdAt", ExtArgs["result"]["rainHistory"]>
  export type RainHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainBet?: boolean | RainHistory$RainBetArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    RainTip?: boolean | RainHistory$RainTipArgs<ExtArgs>
    RainWinner?: boolean | RainHistory$RainWinnerArgs<ExtArgs>
    _count?: boolean | RainHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RainHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RainHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainHistory"
    objects: {
      RainBet: Prisma.$RainBetPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      RainTip: Prisma.$RainTipPayload<ExtArgs>[]
      RainWinner: Prisma.$RainWinnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      rainType: string
      createdAt: Date
    }, ExtArgs["result"]["rainHistory"]>
    composites: {}
  }

  type RainHistoryGetPayload<S extends boolean | null | undefined | RainHistoryDefaultArgs> = $Result.GetResult<Prisma.$RainHistoryPayload, S>

  type RainHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainHistoryCountAggregateInputType | true
    }

  export interface RainHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainHistory'], meta: { name: 'RainHistory' } }
    /**
     * Find zero or one RainHistory that matches the filter.
     * @param {RainHistoryFindUniqueArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainHistoryFindUniqueArgs>(args: SelectSubset<T, RainHistoryFindUniqueArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RainHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainHistoryFindUniqueOrThrowArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RainHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindFirstArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainHistoryFindFirstArgs>(args?: SelectSubset<T, RainHistoryFindFirstArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindFirstOrThrowArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RainHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RainHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainHistories
     * const rainHistories = await prisma.rainHistory.findMany()
     * 
     * // Get first 10 RainHistories
     * const rainHistories = await prisma.rainHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainHistoryWithIdOnly = await prisma.rainHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainHistoryFindManyArgs>(args?: SelectSubset<T, RainHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RainHistory.
     * @param {RainHistoryCreateArgs} args - Arguments to create a RainHistory.
     * @example
     * // Create one RainHistory
     * const RainHistory = await prisma.rainHistory.create({
     *   data: {
     *     // ... data to create a RainHistory
     *   }
     * })
     * 
     */
    create<T extends RainHistoryCreateArgs>(args: SelectSubset<T, RainHistoryCreateArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RainHistories.
     * @param {RainHistoryCreateManyArgs} args - Arguments to create many RainHistories.
     * @example
     * // Create many RainHistories
     * const rainHistory = await prisma.rainHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainHistoryCreateManyArgs>(args?: SelectSubset<T, RainHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainHistories and returns the data saved in the database.
     * @param {RainHistoryCreateManyAndReturnArgs} args - Arguments to create many RainHistories.
     * @example
     * // Create many RainHistories
     * const rainHistory = await prisma.rainHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainHistories and only return the `id`
     * const rainHistoryWithIdOnly = await prisma.rainHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RainHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RainHistory.
     * @param {RainHistoryDeleteArgs} args - Arguments to delete one RainHistory.
     * @example
     * // Delete one RainHistory
     * const RainHistory = await prisma.rainHistory.delete({
     *   where: {
     *     // ... filter to delete one RainHistory
     *   }
     * })
     * 
     */
    delete<T extends RainHistoryDeleteArgs>(args: SelectSubset<T, RainHistoryDeleteArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RainHistory.
     * @param {RainHistoryUpdateArgs} args - Arguments to update one RainHistory.
     * @example
     * // Update one RainHistory
     * const rainHistory = await prisma.rainHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainHistoryUpdateArgs>(args: SelectSubset<T, RainHistoryUpdateArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RainHistories.
     * @param {RainHistoryDeleteManyArgs} args - Arguments to filter RainHistories to delete.
     * @example
     * // Delete a few RainHistories
     * const { count } = await prisma.rainHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainHistoryDeleteManyArgs>(args?: SelectSubset<T, RainHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainHistories
     * const rainHistory = await prisma.rainHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainHistoryUpdateManyArgs>(args: SelectSubset<T, RainHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainHistories and returns the data updated in the database.
     * @param {RainHistoryUpdateManyAndReturnArgs} args - Arguments to update many RainHistories.
     * @example
     * // Update many RainHistories
     * const rainHistory = await prisma.rainHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RainHistories and only return the `id`
     * const rainHistoryWithIdOnly = await prisma.rainHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RainHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, RainHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RainHistory.
     * @param {RainHistoryUpsertArgs} args - Arguments to update or create a RainHistory.
     * @example
     * // Update or create a RainHistory
     * const rainHistory = await prisma.rainHistory.upsert({
     *   create: {
     *     // ... data to create a RainHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainHistory we want to update
     *   }
     * })
     */
    upsert<T extends RainHistoryUpsertArgs>(args: SelectSubset<T, RainHistoryUpsertArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RainHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryCountArgs} args - Arguments to filter RainHistories to count.
     * @example
     * // Count the number of RainHistories
     * const count = await prisma.rainHistory.count({
     *   where: {
     *     // ... the filter for the RainHistories we want to count
     *   }
     * })
    **/
    count<T extends RainHistoryCountArgs>(
      args?: Subset<T, RainHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainHistoryAggregateArgs>(args: Subset<T, RainHistoryAggregateArgs>): Prisma.PrismaPromise<GetRainHistoryAggregateType<T>>

    /**
     * Group by RainHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainHistoryGroupByArgs['orderBy'] }
        : { orderBy?: RainHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainHistory model
   */
  readonly fields: RainHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainBet<T extends RainHistory$RainBetArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainBetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RainTip<T extends RainHistory$RainTipArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainTipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainWinner<T extends RainHistory$RainWinnerArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainHistory model
   */
  interface RainHistoryFieldRefs {
    readonly id: FieldRef<"RainHistory", 'String'>
    readonly userId: FieldRef<"RainHistory", 'String'>
    readonly amount: FieldRef<"RainHistory", 'Int'>
    readonly rainType: FieldRef<"RainHistory", 'String'>
    readonly createdAt: FieldRef<"RainHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainHistory findUnique
   */
  export type RainHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory findUniqueOrThrow
   */
  export type RainHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory findFirst
   */
  export type RainHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainHistories.
     */
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory findFirstOrThrow
   */
  export type RainHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainHistories.
     */
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory findMany
   */
  export type RainHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistories to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory create
   */
  export type RainHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RainHistory.
     */
    data: XOR<RainHistoryCreateInput, RainHistoryUncheckedCreateInput>
  }

  /**
   * RainHistory createMany
   */
  export type RainHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainHistories.
     */
    data: RainHistoryCreateManyInput | RainHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainHistory createManyAndReturn
   */
  export type RainHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many RainHistories.
     */
    data: RainHistoryCreateManyInput | RainHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainHistory update
   */
  export type RainHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RainHistory.
     */
    data: XOR<RainHistoryUpdateInput, RainHistoryUncheckedUpdateInput>
    /**
     * Choose, which RainHistory to update.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory updateMany
   */
  export type RainHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainHistories.
     */
    data: XOR<RainHistoryUpdateManyMutationInput, RainHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RainHistories to update
     */
    where?: RainHistoryWhereInput
    /**
     * Limit how many RainHistories to update.
     */
    limit?: number
  }

  /**
   * RainHistory updateManyAndReturn
   */
  export type RainHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * The data used to update RainHistories.
     */
    data: XOR<RainHistoryUpdateManyMutationInput, RainHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RainHistories to update
     */
    where?: RainHistoryWhereInput
    /**
     * Limit how many RainHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainHistory upsert
   */
  export type RainHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RainHistory to update in case it exists.
     */
    where: RainHistoryWhereUniqueInput
    /**
     * In case the RainHistory found by the `where` argument doesn't exist, create a new RainHistory with this data.
     */
    create: XOR<RainHistoryCreateInput, RainHistoryUncheckedCreateInput>
    /**
     * In case the RainHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainHistoryUpdateInput, RainHistoryUncheckedUpdateInput>
  }

  /**
   * RainHistory delete
   */
  export type RainHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter which RainHistory to delete.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory deleteMany
   */
  export type RainHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainHistories to delete
     */
    where?: RainHistoryWhereInput
    /**
     * Limit how many RainHistories to delete.
     */
    limit?: number
  }

  /**
   * RainHistory.RainBet
   */
  export type RainHistory$RainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    cursor?: RainBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainHistory.RainTip
   */
  export type RainHistory$RainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    cursor?: RainTipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainHistory.RainWinner
   */
  export type RainHistory$RainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    cursor?: RainWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainHistory without action
   */
  export type RainHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
  }


  /**
   * Model RainTip
   */

  export type AggregateRainTip = {
    _count: RainTipCountAggregateOutputType | null
    _avg: RainTipAvgAggregateOutputType | null
    _sum: RainTipSumAggregateOutputType | null
    _min: RainTipMinAggregateOutputType | null
    _max: RainTipMaxAggregateOutputType | null
  }

  export type RainTipAvgAggregateOutputType = {
    tipAmount: number | null
  }

  export type RainTipSumAggregateOutputType = {
    tipAmount: number | null
  }

  export type RainTipMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    tipAmount: number | null
    tippedAt: Date | null
  }

  export type RainTipMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    tipAmount: number | null
    tippedAt: Date | null
  }

  export type RainTipCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    tipAmount: number
    tippedAt: number
    _all: number
  }


  export type RainTipAvgAggregateInputType = {
    tipAmount?: true
  }

  export type RainTipSumAggregateInputType = {
    tipAmount?: true
  }

  export type RainTipMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
  }

  export type RainTipMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
  }

  export type RainTipCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
    _all?: true
  }

  export type RainTipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainTip to aggregate.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainTips
    **/
    _count?: true | RainTipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainTipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainTipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainTipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainTipMaxAggregateInputType
  }

  export type GetRainTipAggregateType<T extends RainTipAggregateArgs> = {
        [P in keyof T & keyof AggregateRainTip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainTip[P]>
      : GetScalarType<T[P], AggregateRainTip[P]>
  }




  export type RainTipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithAggregationInput | RainTipOrderByWithAggregationInput[]
    by: RainTipScalarFieldEnum[] | RainTipScalarFieldEnum
    having?: RainTipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainTipCountAggregateInputType | true
    _avg?: RainTipAvgAggregateInputType
    _sum?: RainTipSumAggregateInputType
    _min?: RainTipMinAggregateInputType
    _max?: RainTipMaxAggregateInputType
  }

  export type RainTipGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    tipAmount: number
    tippedAt: Date
    _count: RainTipCountAggregateOutputType | null
    _avg: RainTipAvgAggregateOutputType | null
    _sum: RainTipSumAggregateOutputType | null
    _min: RainTipMinAggregateOutputType | null
    _max: RainTipMaxAggregateOutputType | null
  }

  type GetRainTipGroupByPayload<T extends RainTipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainTipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainTipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainTipGroupByOutputType[P]>
            : GetScalarType<T[P], RainTipGroupByOutputType[P]>
        }
      >
    >


  export type RainTipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainTip"]>

  export type RainTipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainTip"]>

  export type RainTipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainTip"]>

  export type RainTipSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
  }

  export type RainTipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rainHistoryId" | "userId" | "tipAmount" | "tippedAt", ExtArgs["result"]["rainTip"]>
  export type RainTipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainTipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainTipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RainTipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainTip"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      tipAmount: number
      tippedAt: Date
    }, ExtArgs["result"]["rainTip"]>
    composites: {}
  }

  type RainTipGetPayload<S extends boolean | null | undefined | RainTipDefaultArgs> = $Result.GetResult<Prisma.$RainTipPayload, S>

  type RainTipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainTipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainTipCountAggregateInputType | true
    }

  export interface RainTipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainTip'], meta: { name: 'RainTip' } }
    /**
     * Find zero or one RainTip that matches the filter.
     * @param {RainTipFindUniqueArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainTipFindUniqueArgs>(args: SelectSubset<T, RainTipFindUniqueArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RainTip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainTipFindUniqueOrThrowArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainTipFindUniqueOrThrowArgs>(args: SelectSubset<T, RainTipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainTip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindFirstArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainTipFindFirstArgs>(args?: SelectSubset<T, RainTipFindFirstArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainTip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindFirstOrThrowArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainTipFindFirstOrThrowArgs>(args?: SelectSubset<T, RainTipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RainTips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainTips
     * const rainTips = await prisma.rainTip.findMany()
     * 
     * // Get first 10 RainTips
     * const rainTips = await prisma.rainTip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainTipWithIdOnly = await prisma.rainTip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainTipFindManyArgs>(args?: SelectSubset<T, RainTipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RainTip.
     * @param {RainTipCreateArgs} args - Arguments to create a RainTip.
     * @example
     * // Create one RainTip
     * const RainTip = await prisma.rainTip.create({
     *   data: {
     *     // ... data to create a RainTip
     *   }
     * })
     * 
     */
    create<T extends RainTipCreateArgs>(args: SelectSubset<T, RainTipCreateArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RainTips.
     * @param {RainTipCreateManyArgs} args - Arguments to create many RainTips.
     * @example
     * // Create many RainTips
     * const rainTip = await prisma.rainTip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainTipCreateManyArgs>(args?: SelectSubset<T, RainTipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainTips and returns the data saved in the database.
     * @param {RainTipCreateManyAndReturnArgs} args - Arguments to create many RainTips.
     * @example
     * // Create many RainTips
     * const rainTip = await prisma.rainTip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainTips and only return the `id`
     * const rainTipWithIdOnly = await prisma.rainTip.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainTipCreateManyAndReturnArgs>(args?: SelectSubset<T, RainTipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RainTip.
     * @param {RainTipDeleteArgs} args - Arguments to delete one RainTip.
     * @example
     * // Delete one RainTip
     * const RainTip = await prisma.rainTip.delete({
     *   where: {
     *     // ... filter to delete one RainTip
     *   }
     * })
     * 
     */
    delete<T extends RainTipDeleteArgs>(args: SelectSubset<T, RainTipDeleteArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RainTip.
     * @param {RainTipUpdateArgs} args - Arguments to update one RainTip.
     * @example
     * // Update one RainTip
     * const rainTip = await prisma.rainTip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainTipUpdateArgs>(args: SelectSubset<T, RainTipUpdateArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RainTips.
     * @param {RainTipDeleteManyArgs} args - Arguments to filter RainTips to delete.
     * @example
     * // Delete a few RainTips
     * const { count } = await prisma.rainTip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainTipDeleteManyArgs>(args?: SelectSubset<T, RainTipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainTips
     * const rainTip = await prisma.rainTip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainTipUpdateManyArgs>(args: SelectSubset<T, RainTipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainTips and returns the data updated in the database.
     * @param {RainTipUpdateManyAndReturnArgs} args - Arguments to update many RainTips.
     * @example
     * // Update many RainTips
     * const rainTip = await prisma.rainTip.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RainTips and only return the `id`
     * const rainTipWithIdOnly = await prisma.rainTip.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RainTipUpdateManyAndReturnArgs>(args: SelectSubset<T, RainTipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RainTip.
     * @param {RainTipUpsertArgs} args - Arguments to update or create a RainTip.
     * @example
     * // Update or create a RainTip
     * const rainTip = await prisma.rainTip.upsert({
     *   create: {
     *     // ... data to create a RainTip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainTip we want to update
     *   }
     * })
     */
    upsert<T extends RainTipUpsertArgs>(args: SelectSubset<T, RainTipUpsertArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RainTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipCountArgs} args - Arguments to filter RainTips to count.
     * @example
     * // Count the number of RainTips
     * const count = await prisma.rainTip.count({
     *   where: {
     *     // ... the filter for the RainTips we want to count
     *   }
     * })
    **/
    count<T extends RainTipCountArgs>(
      args?: Subset<T, RainTipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainTipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainTip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainTipAggregateArgs>(args: Subset<T, RainTipAggregateArgs>): Prisma.PrismaPromise<GetRainTipAggregateType<T>>

    /**
     * Group by RainTip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainTipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainTipGroupByArgs['orderBy'] }
        : { orderBy?: RainTipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainTipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainTipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainTip model
   */
  readonly fields: RainTipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainTip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainTipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainTip model
   */
  interface RainTipFieldRefs {
    readonly id: FieldRef<"RainTip", 'String'>
    readonly rainHistoryId: FieldRef<"RainTip", 'String'>
    readonly userId: FieldRef<"RainTip", 'String'>
    readonly tipAmount: FieldRef<"RainTip", 'Int'>
    readonly tippedAt: FieldRef<"RainTip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainTip findUnique
   */
  export type RainTipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip findUniqueOrThrow
   */
  export type RainTipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip findFirst
   */
  export type RainTipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainTips.
     */
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip findFirstOrThrow
   */
  export type RainTipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainTips.
     */
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip findMany
   */
  export type RainTipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTips to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip create
   */
  export type RainTipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The data needed to create a RainTip.
     */
    data: XOR<RainTipCreateInput, RainTipUncheckedCreateInput>
  }

  /**
   * RainTip createMany
   */
  export type RainTipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainTips.
     */
    data: RainTipCreateManyInput | RainTipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainTip createManyAndReturn
   */
  export type RainTipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * The data used to create many RainTips.
     */
    data: RainTipCreateManyInput | RainTipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainTip update
   */
  export type RainTipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The data needed to update a RainTip.
     */
    data: XOR<RainTipUpdateInput, RainTipUncheckedUpdateInput>
    /**
     * Choose, which RainTip to update.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip updateMany
   */
  export type RainTipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainTips.
     */
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyInput>
    /**
     * Filter which RainTips to update
     */
    where?: RainTipWhereInput
    /**
     * Limit how many RainTips to update.
     */
    limit?: number
  }

  /**
   * RainTip updateManyAndReturn
   */
  export type RainTipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * The data used to update RainTips.
     */
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyInput>
    /**
     * Filter which RainTips to update
     */
    where?: RainTipWhereInput
    /**
     * Limit how many RainTips to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainTip upsert
   */
  export type RainTipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The filter to search for the RainTip to update in case it exists.
     */
    where: RainTipWhereUniqueInput
    /**
     * In case the RainTip found by the `where` argument doesn't exist, create a new RainTip with this data.
     */
    create: XOR<RainTipCreateInput, RainTipUncheckedCreateInput>
    /**
     * In case the RainTip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainTipUpdateInput, RainTipUncheckedUpdateInput>
  }

  /**
   * RainTip delete
   */
  export type RainTipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter which RainTip to delete.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip deleteMany
   */
  export type RainTipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainTips to delete
     */
    where?: RainTipWhereInput
    /**
     * Limit how many RainTips to delete.
     */
    limit?: number
  }

  /**
   * RainTip without action
   */
  export type RainTipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
  }


  /**
   * Model RainWinner
   */

  export type AggregateRainWinner = {
    _count: RainWinnerCountAggregateOutputType | null
    _avg: RainWinnerAvgAggregateOutputType | null
    _sum: RainWinnerSumAggregateOutputType | null
    _min: RainWinnerMinAggregateOutputType | null
    _max: RainWinnerMaxAggregateOutputType | null
  }

  export type RainWinnerAvgAggregateOutputType = {
    wonAmount: number | null
  }

  export type RainWinnerSumAggregateOutputType = {
    wonAmount: number | null
  }

  export type RainWinnerMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    wonAmount: number | null
    wonAt: Date | null
  }

  export type RainWinnerMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    wonAmount: number | null
    wonAt: Date | null
  }

  export type RainWinnerCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    wonAmount: number
    wonAt: number
    _all: number
  }


  export type RainWinnerAvgAggregateInputType = {
    wonAmount?: true
  }

  export type RainWinnerSumAggregateInputType = {
    wonAmount?: true
  }

  export type RainWinnerMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
  }

  export type RainWinnerMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
  }

  export type RainWinnerCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
    _all?: true
  }

  export type RainWinnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainWinner to aggregate.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainWinners
    **/
    _count?: true | RainWinnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainWinnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainWinnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainWinnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainWinnerMaxAggregateInputType
  }

  export type GetRainWinnerAggregateType<T extends RainWinnerAggregateArgs> = {
        [P in keyof T & keyof AggregateRainWinner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainWinner[P]>
      : GetScalarType<T[P], AggregateRainWinner[P]>
  }




  export type RainWinnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithAggregationInput | RainWinnerOrderByWithAggregationInput[]
    by: RainWinnerScalarFieldEnum[] | RainWinnerScalarFieldEnum
    having?: RainWinnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainWinnerCountAggregateInputType | true
    _avg?: RainWinnerAvgAggregateInputType
    _sum?: RainWinnerSumAggregateInputType
    _min?: RainWinnerMinAggregateInputType
    _max?: RainWinnerMaxAggregateInputType
  }

  export type RainWinnerGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    wonAmount: number
    wonAt: Date
    _count: RainWinnerCountAggregateOutputType | null
    _avg: RainWinnerAvgAggregateOutputType | null
    _sum: RainWinnerSumAggregateOutputType | null
    _min: RainWinnerMinAggregateOutputType | null
    _max: RainWinnerMaxAggregateOutputType | null
  }

  type GetRainWinnerGroupByPayload<T extends RainWinnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainWinnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainWinnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainWinnerGroupByOutputType[P]>
            : GetScalarType<T[P], RainWinnerGroupByOutputType[P]>
        }
      >
    >


  export type RainWinnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainWinner"]>

  export type RainWinnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainWinner"]>

  export type RainWinnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainWinner"]>

  export type RainWinnerSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
  }

  export type RainWinnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rainHistoryId" | "userId" | "wonAmount" | "wonAt", ExtArgs["result"]["rainWinner"]>
  export type RainWinnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainWinnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RainWinnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RainWinnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainWinner"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      wonAmount: number
      wonAt: Date
    }, ExtArgs["result"]["rainWinner"]>
    composites: {}
  }

  type RainWinnerGetPayload<S extends boolean | null | undefined | RainWinnerDefaultArgs> = $Result.GetResult<Prisma.$RainWinnerPayload, S>

  type RainWinnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainWinnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainWinnerCountAggregateInputType | true
    }

  export interface RainWinnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainWinner'], meta: { name: 'RainWinner' } }
    /**
     * Find zero or one RainWinner that matches the filter.
     * @param {RainWinnerFindUniqueArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainWinnerFindUniqueArgs>(args: SelectSubset<T, RainWinnerFindUniqueArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RainWinner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainWinnerFindUniqueOrThrowArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainWinnerFindUniqueOrThrowArgs>(args: SelectSubset<T, RainWinnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainWinner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindFirstArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainWinnerFindFirstArgs>(args?: SelectSubset<T, RainWinnerFindFirstArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainWinner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindFirstOrThrowArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainWinnerFindFirstOrThrowArgs>(args?: SelectSubset<T, RainWinnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RainWinners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainWinners
     * const rainWinners = await prisma.rainWinner.findMany()
     * 
     * // Get first 10 RainWinners
     * const rainWinners = await prisma.rainWinner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainWinnerWithIdOnly = await prisma.rainWinner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainWinnerFindManyArgs>(args?: SelectSubset<T, RainWinnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RainWinner.
     * @param {RainWinnerCreateArgs} args - Arguments to create a RainWinner.
     * @example
     * // Create one RainWinner
     * const RainWinner = await prisma.rainWinner.create({
     *   data: {
     *     // ... data to create a RainWinner
     *   }
     * })
     * 
     */
    create<T extends RainWinnerCreateArgs>(args: SelectSubset<T, RainWinnerCreateArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RainWinners.
     * @param {RainWinnerCreateManyArgs} args - Arguments to create many RainWinners.
     * @example
     * // Create many RainWinners
     * const rainWinner = await prisma.rainWinner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainWinnerCreateManyArgs>(args?: SelectSubset<T, RainWinnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainWinners and returns the data saved in the database.
     * @param {RainWinnerCreateManyAndReturnArgs} args - Arguments to create many RainWinners.
     * @example
     * // Create many RainWinners
     * const rainWinner = await prisma.rainWinner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainWinners and only return the `id`
     * const rainWinnerWithIdOnly = await prisma.rainWinner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainWinnerCreateManyAndReturnArgs>(args?: SelectSubset<T, RainWinnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RainWinner.
     * @param {RainWinnerDeleteArgs} args - Arguments to delete one RainWinner.
     * @example
     * // Delete one RainWinner
     * const RainWinner = await prisma.rainWinner.delete({
     *   where: {
     *     // ... filter to delete one RainWinner
     *   }
     * })
     * 
     */
    delete<T extends RainWinnerDeleteArgs>(args: SelectSubset<T, RainWinnerDeleteArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RainWinner.
     * @param {RainWinnerUpdateArgs} args - Arguments to update one RainWinner.
     * @example
     * // Update one RainWinner
     * const rainWinner = await prisma.rainWinner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainWinnerUpdateArgs>(args: SelectSubset<T, RainWinnerUpdateArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RainWinners.
     * @param {RainWinnerDeleteManyArgs} args - Arguments to filter RainWinners to delete.
     * @example
     * // Delete a few RainWinners
     * const { count } = await prisma.rainWinner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainWinnerDeleteManyArgs>(args?: SelectSubset<T, RainWinnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainWinners
     * const rainWinner = await prisma.rainWinner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainWinnerUpdateManyArgs>(args: SelectSubset<T, RainWinnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainWinners and returns the data updated in the database.
     * @param {RainWinnerUpdateManyAndReturnArgs} args - Arguments to update many RainWinners.
     * @example
     * // Update many RainWinners
     * const rainWinner = await prisma.rainWinner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RainWinners and only return the `id`
     * const rainWinnerWithIdOnly = await prisma.rainWinner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RainWinnerUpdateManyAndReturnArgs>(args: SelectSubset<T, RainWinnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RainWinner.
     * @param {RainWinnerUpsertArgs} args - Arguments to update or create a RainWinner.
     * @example
     * // Update or create a RainWinner
     * const rainWinner = await prisma.rainWinner.upsert({
     *   create: {
     *     // ... data to create a RainWinner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainWinner we want to update
     *   }
     * })
     */
    upsert<T extends RainWinnerUpsertArgs>(args: SelectSubset<T, RainWinnerUpsertArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RainWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerCountArgs} args - Arguments to filter RainWinners to count.
     * @example
     * // Count the number of RainWinners
     * const count = await prisma.rainWinner.count({
     *   where: {
     *     // ... the filter for the RainWinners we want to count
     *   }
     * })
    **/
    count<T extends RainWinnerCountArgs>(
      args?: Subset<T, RainWinnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainWinnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainWinnerAggregateArgs>(args: Subset<T, RainWinnerAggregateArgs>): Prisma.PrismaPromise<GetRainWinnerAggregateType<T>>

    /**
     * Group by RainWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainWinnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainWinnerGroupByArgs['orderBy'] }
        : { orderBy?: RainWinnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainWinnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainWinnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainWinner model
   */
  readonly fields: RainWinnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainWinner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainWinnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainWinner model
   */
  interface RainWinnerFieldRefs {
    readonly id: FieldRef<"RainWinner", 'String'>
    readonly rainHistoryId: FieldRef<"RainWinner", 'String'>
    readonly userId: FieldRef<"RainWinner", 'String'>
    readonly wonAmount: FieldRef<"RainWinner", 'Int'>
    readonly wonAt: FieldRef<"RainWinner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainWinner findUnique
   */
  export type RainWinnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner findUniqueOrThrow
   */
  export type RainWinnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner findFirst
   */
  export type RainWinnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainWinners.
     */
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner findFirstOrThrow
   */
  export type RainWinnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainWinners.
     */
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner findMany
   */
  export type RainWinnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinners to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner create
   */
  export type RainWinnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The data needed to create a RainWinner.
     */
    data: XOR<RainWinnerCreateInput, RainWinnerUncheckedCreateInput>
  }

  /**
   * RainWinner createMany
   */
  export type RainWinnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainWinners.
     */
    data: RainWinnerCreateManyInput | RainWinnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainWinner createManyAndReturn
   */
  export type RainWinnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * The data used to create many RainWinners.
     */
    data: RainWinnerCreateManyInput | RainWinnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainWinner update
   */
  export type RainWinnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The data needed to update a RainWinner.
     */
    data: XOR<RainWinnerUpdateInput, RainWinnerUncheckedUpdateInput>
    /**
     * Choose, which RainWinner to update.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner updateMany
   */
  export type RainWinnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainWinners.
     */
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyInput>
    /**
     * Filter which RainWinners to update
     */
    where?: RainWinnerWhereInput
    /**
     * Limit how many RainWinners to update.
     */
    limit?: number
  }

  /**
   * RainWinner updateManyAndReturn
   */
  export type RainWinnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * The data used to update RainWinners.
     */
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyInput>
    /**
     * Filter which RainWinners to update
     */
    where?: RainWinnerWhereInput
    /**
     * Limit how many RainWinners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainWinner upsert
   */
  export type RainWinnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The filter to search for the RainWinner to update in case it exists.
     */
    where: RainWinnerWhereUniqueInput
    /**
     * In case the RainWinner found by the `where` argument doesn't exist, create a new RainWinner with this data.
     */
    create: XOR<RainWinnerCreateInput, RainWinnerUncheckedCreateInput>
    /**
     * In case the RainWinner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainWinnerUpdateInput, RainWinnerUncheckedUpdateInput>
  }

  /**
   * RainWinner delete
   */
  export type RainWinnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter which RainWinner to delete.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner deleteMany
   */
  export type RainWinnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainWinners to delete
     */
    where?: RainWinnerWhereInput
    /**
     * Limit how many RainWinners to delete.
     */
    limit?: number
  }

  /**
   * RainWinner without action
   */
  export type RainWinnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
  }


  /**
   * Model VipInfo
   */

  export type AggregateVipInfo = {
    _count: VipInfoCountAggregateOutputType | null
    _avg: VipInfoAvgAggregateOutputType | null
    _sum: VipInfoSumAggregateOutputType | null
    _min: VipInfoMinAggregateOutputType | null
    _max: VipInfoMaxAggregateOutputType | null
  }

  export type VipInfoAvgAggregateOutputType = {
    id: number | null
    level: number | null
    deposit_exp: number | null
    bet_exp: number | null
    rank_bet_exp: number | null
    rank_deposit_exp: number | null
    exp_switch_type: number | null
    protection_days: number | null
    protection_switch: number | null
    unprotection_days: number | null
    unprotection_switch: number | null
  }

  export type VipInfoSumAggregateOutputType = {
    id: number | null
    level: number | null
    deposit_exp: number | null
    bet_exp: number | null
    rank_bet_exp: number | null
    rank_deposit_exp: number | null
    exp_switch_type: number | null
    protection_days: number | null
    protection_switch: number | null
    unprotection_days: number | null
    unprotection_switch: number | null
  }

  export type VipInfoMinAggregateOutputType = {
    id: number | null
    level: number | null
    deposit_exp: number | null
    bet_exp: number | null
    rank_bet_exp: number | null
    rank_deposit_exp: number | null
    rank_name: string | null
    icon: string | null
    exp_switch_type: number | null
    now_deposit_exp: string | null
    level_deposit_exp: string | null
    now_bet_exp: string | null
    level_bet_exp: string | null
    telegram: string | null
    is_protection: boolean | null
    protection_deposit_exp: string | null
    protection_deposit_amount: string | null
    protection_bet_exp: string | null
    protection_bet_amount: string | null
    protection_days: number | null
    protection_switch: number | null
    cycle_award_switch: boolean | null
    level_award_switch: boolean | null
    signin_award_switch: boolean | null
    bet_award_switch: boolean | null
    withdrawal_award_switch: boolean | null
    unprotection_deposit_exp: string | null
    unprotection_deposit_amount: string | null
    unprotection_bet_exp: string | null
    unprotection_bet_amount: string | null
    unprotection_days: number | null
    unprotection_switch: number | null
    main_currency: string | null
    can_receive_level_award: boolean | null
    can_receive_rank_award: boolean | null
    can_receive_day_award: boolean | null
    can_receive_week_award: boolean | null
    can_receive_month_award: boolean | null
    can_receive_signin_award: boolean | null
    can_receive_bet_award: boolean | null
    can_receive_withdrawal_award: boolean | null
    userid: string | null
  }

  export type VipInfoMaxAggregateOutputType = {
    id: number | null
    level: number | null
    deposit_exp: number | null
    bet_exp: number | null
    rank_bet_exp: number | null
    rank_deposit_exp: number | null
    rank_name: string | null
    icon: string | null
    exp_switch_type: number | null
    now_deposit_exp: string | null
    level_deposit_exp: string | null
    now_bet_exp: string | null
    level_bet_exp: string | null
    telegram: string | null
    is_protection: boolean | null
    protection_deposit_exp: string | null
    protection_deposit_amount: string | null
    protection_bet_exp: string | null
    protection_bet_amount: string | null
    protection_days: number | null
    protection_switch: number | null
    cycle_award_switch: boolean | null
    level_award_switch: boolean | null
    signin_award_switch: boolean | null
    bet_award_switch: boolean | null
    withdrawal_award_switch: boolean | null
    unprotection_deposit_exp: string | null
    unprotection_deposit_amount: string | null
    unprotection_bet_exp: string | null
    unprotection_bet_amount: string | null
    unprotection_days: number | null
    unprotection_switch: number | null
    main_currency: string | null
    can_receive_level_award: boolean | null
    can_receive_rank_award: boolean | null
    can_receive_day_award: boolean | null
    can_receive_week_award: boolean | null
    can_receive_month_award: boolean | null
    can_receive_signin_award: boolean | null
    can_receive_bet_award: boolean | null
    can_receive_withdrawal_award: boolean | null
    userid: string | null
  }

  export type VipInfoCountAggregateOutputType = {
    id: number
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: number
    icon: number
    exp_switch_type: number
    now_deposit_exp: number
    level_deposit_exp: number
    now_bet_exp: number
    level_bet_exp: number
    telegram: number
    is_protection: number
    protection_deposit_exp: number
    protection_deposit_amount: number
    protection_bet_exp: number
    protection_bet_amount: number
    protection_days: number
    protection_switch: number
    cycle_award_switch: number
    level_award_switch: number
    signin_award_switch: number
    bet_award_switch: number
    withdrawal_award_switch: number
    unprotection_deposit_exp: number
    unprotection_deposit_amount: number
    unprotection_bet_exp: number
    unprotection_bet_amount: number
    unprotection_days: number
    unprotection_switch: number
    main_currency: number
    can_receive_level_award: number
    can_receive_rank_award: number
    can_receive_day_award: number
    can_receive_week_award: number
    can_receive_month_award: number
    can_receive_signin_award: number
    can_receive_bet_award: number
    can_receive_withdrawal_award: number
    userid: number
    _all: number
  }


  export type VipInfoAvgAggregateInputType = {
    id?: true
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    exp_switch_type?: true
    protection_days?: true
    protection_switch?: true
    unprotection_days?: true
    unprotection_switch?: true
  }

  export type VipInfoSumAggregateInputType = {
    id?: true
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    exp_switch_type?: true
    protection_days?: true
    protection_switch?: true
    unprotection_days?: true
    unprotection_switch?: true
  }

  export type VipInfoMinAggregateInputType = {
    id?: true
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    rank_name?: true
    icon?: true
    exp_switch_type?: true
    now_deposit_exp?: true
    level_deposit_exp?: true
    now_bet_exp?: true
    level_bet_exp?: true
    telegram?: true
    is_protection?: true
    protection_deposit_exp?: true
    protection_deposit_amount?: true
    protection_bet_exp?: true
    protection_bet_amount?: true
    protection_days?: true
    protection_switch?: true
    cycle_award_switch?: true
    level_award_switch?: true
    signin_award_switch?: true
    bet_award_switch?: true
    withdrawal_award_switch?: true
    unprotection_deposit_exp?: true
    unprotection_deposit_amount?: true
    unprotection_bet_exp?: true
    unprotection_bet_amount?: true
    unprotection_days?: true
    unprotection_switch?: true
    main_currency?: true
    can_receive_level_award?: true
    can_receive_rank_award?: true
    can_receive_day_award?: true
    can_receive_week_award?: true
    can_receive_month_award?: true
    can_receive_signin_award?: true
    can_receive_bet_award?: true
    can_receive_withdrawal_award?: true
    userid?: true
  }

  export type VipInfoMaxAggregateInputType = {
    id?: true
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    rank_name?: true
    icon?: true
    exp_switch_type?: true
    now_deposit_exp?: true
    level_deposit_exp?: true
    now_bet_exp?: true
    level_bet_exp?: true
    telegram?: true
    is_protection?: true
    protection_deposit_exp?: true
    protection_deposit_amount?: true
    protection_bet_exp?: true
    protection_bet_amount?: true
    protection_days?: true
    protection_switch?: true
    cycle_award_switch?: true
    level_award_switch?: true
    signin_award_switch?: true
    bet_award_switch?: true
    withdrawal_award_switch?: true
    unprotection_deposit_exp?: true
    unprotection_deposit_amount?: true
    unprotection_bet_exp?: true
    unprotection_bet_amount?: true
    unprotection_days?: true
    unprotection_switch?: true
    main_currency?: true
    can_receive_level_award?: true
    can_receive_rank_award?: true
    can_receive_day_award?: true
    can_receive_week_award?: true
    can_receive_month_award?: true
    can_receive_signin_award?: true
    can_receive_bet_award?: true
    can_receive_withdrawal_award?: true
    userid?: true
  }

  export type VipInfoCountAggregateInputType = {
    id?: true
    level?: true
    deposit_exp?: true
    bet_exp?: true
    rank_bet_exp?: true
    rank_deposit_exp?: true
    rank_name?: true
    icon?: true
    exp_switch_type?: true
    now_deposit_exp?: true
    level_deposit_exp?: true
    now_bet_exp?: true
    level_bet_exp?: true
    telegram?: true
    is_protection?: true
    protection_deposit_exp?: true
    protection_deposit_amount?: true
    protection_bet_exp?: true
    protection_bet_amount?: true
    protection_days?: true
    protection_switch?: true
    cycle_award_switch?: true
    level_award_switch?: true
    signin_award_switch?: true
    bet_award_switch?: true
    withdrawal_award_switch?: true
    unprotection_deposit_exp?: true
    unprotection_deposit_amount?: true
    unprotection_bet_exp?: true
    unprotection_bet_amount?: true
    unprotection_days?: true
    unprotection_switch?: true
    main_currency?: true
    can_receive_level_award?: true
    can_receive_rank_award?: true
    can_receive_day_award?: true
    can_receive_week_award?: true
    can_receive_month_award?: true
    can_receive_signin_award?: true
    can_receive_bet_award?: true
    can_receive_withdrawal_award?: true
    userid?: true
    _all?: true
  }

  export type VipInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VipInfo to aggregate.
     */
    where?: VipInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipInfos to fetch.
     */
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VipInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VipInfos
    **/
    _count?: true | VipInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VipInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VipInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VipInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VipInfoMaxAggregateInputType
  }

  export type GetVipInfoAggregateType<T extends VipInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateVipInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVipInfo[P]>
      : GetScalarType<T[P], AggregateVipInfo[P]>
  }




  export type VipInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VipInfoWhereInput
    orderBy?: VipInfoOrderByWithAggregationInput | VipInfoOrderByWithAggregationInput[]
    by: VipInfoScalarFieldEnum[] | VipInfoScalarFieldEnum
    having?: VipInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VipInfoCountAggregateInputType | true
    _avg?: VipInfoAvgAggregateInputType
    _sum?: VipInfoSumAggregateInputType
    _min?: VipInfoMinAggregateInputType
    _max?: VipInfoMaxAggregateInputType
  }

  export type VipInfoGroupByOutputType = {
    id: number
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: string
    icon: string
    exp_switch_type: number
    now_deposit_exp: string
    level_deposit_exp: string
    now_bet_exp: string
    level_bet_exp: string
    telegram: string
    is_protection: boolean
    protection_deposit_exp: string
    protection_deposit_amount: string
    protection_bet_exp: string
    protection_bet_amount: string
    protection_days: number
    protection_switch: number
    cycle_award_switch: boolean
    level_award_switch: boolean
    signin_award_switch: boolean
    bet_award_switch: boolean
    withdrawal_award_switch: boolean
    unprotection_deposit_exp: string
    unprotection_deposit_amount: string
    unprotection_bet_exp: string
    unprotection_bet_amount: string
    unprotection_days: number
    unprotection_switch: number
    main_currency: string
    can_receive_level_award: boolean
    can_receive_rank_award: boolean
    can_receive_day_award: boolean
    can_receive_week_award: boolean
    can_receive_month_award: boolean
    can_receive_signin_award: boolean
    can_receive_bet_award: boolean
    can_receive_withdrawal_award: boolean
    userid: string
    _count: VipInfoCountAggregateOutputType | null
    _avg: VipInfoAvgAggregateOutputType | null
    _sum: VipInfoSumAggregateOutputType | null
    _min: VipInfoMinAggregateOutputType | null
    _max: VipInfoMaxAggregateOutputType | null
  }

  type GetVipInfoGroupByPayload<T extends VipInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VipInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VipInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VipInfoGroupByOutputType[P]>
            : GetScalarType<T[P], VipInfoGroupByOutputType[P]>
        }
      >
    >


  export type VipInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    deposit_exp?: boolean
    bet_exp?: boolean
    rank_bet_exp?: boolean
    rank_deposit_exp?: boolean
    rank_name?: boolean
    icon?: boolean
    exp_switch_type?: boolean
    now_deposit_exp?: boolean
    level_deposit_exp?: boolean
    now_bet_exp?: boolean
    level_bet_exp?: boolean
    telegram?: boolean
    is_protection?: boolean
    protection_deposit_exp?: boolean
    protection_deposit_amount?: boolean
    protection_bet_exp?: boolean
    protection_bet_amount?: boolean
    protection_days?: boolean
    protection_switch?: boolean
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: boolean
    unprotection_deposit_amount?: boolean
    unprotection_bet_exp?: boolean
    unprotection_bet_amount?: boolean
    unprotection_days?: boolean
    unprotection_switch?: boolean
    main_currency?: boolean
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipInfo"]>

  export type VipInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    deposit_exp?: boolean
    bet_exp?: boolean
    rank_bet_exp?: boolean
    rank_deposit_exp?: boolean
    rank_name?: boolean
    icon?: boolean
    exp_switch_type?: boolean
    now_deposit_exp?: boolean
    level_deposit_exp?: boolean
    now_bet_exp?: boolean
    level_bet_exp?: boolean
    telegram?: boolean
    is_protection?: boolean
    protection_deposit_exp?: boolean
    protection_deposit_amount?: boolean
    protection_bet_exp?: boolean
    protection_bet_amount?: boolean
    protection_days?: boolean
    protection_switch?: boolean
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: boolean
    unprotection_deposit_amount?: boolean
    unprotection_bet_exp?: boolean
    unprotection_bet_amount?: boolean
    unprotection_days?: boolean
    unprotection_switch?: boolean
    main_currency?: boolean
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipInfo"]>

  export type VipInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    deposit_exp?: boolean
    bet_exp?: boolean
    rank_bet_exp?: boolean
    rank_deposit_exp?: boolean
    rank_name?: boolean
    icon?: boolean
    exp_switch_type?: boolean
    now_deposit_exp?: boolean
    level_deposit_exp?: boolean
    now_bet_exp?: boolean
    level_bet_exp?: boolean
    telegram?: boolean
    is_protection?: boolean
    protection_deposit_exp?: boolean
    protection_deposit_amount?: boolean
    protection_bet_exp?: boolean
    protection_bet_amount?: boolean
    protection_days?: boolean
    protection_switch?: boolean
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: boolean
    unprotection_deposit_amount?: boolean
    unprotection_bet_exp?: boolean
    unprotection_bet_amount?: boolean
    unprotection_days?: boolean
    unprotection_switch?: boolean
    main_currency?: boolean
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vipInfo"]>

  export type VipInfoSelectScalar = {
    id?: boolean
    level?: boolean
    deposit_exp?: boolean
    bet_exp?: boolean
    rank_bet_exp?: boolean
    rank_deposit_exp?: boolean
    rank_name?: boolean
    icon?: boolean
    exp_switch_type?: boolean
    now_deposit_exp?: boolean
    level_deposit_exp?: boolean
    now_bet_exp?: boolean
    level_bet_exp?: boolean
    telegram?: boolean
    is_protection?: boolean
    protection_deposit_exp?: boolean
    protection_deposit_amount?: boolean
    protection_bet_exp?: boolean
    protection_bet_amount?: boolean
    protection_days?: boolean
    protection_switch?: boolean
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp?: boolean
    unprotection_deposit_amount?: boolean
    unprotection_bet_exp?: boolean
    unprotection_bet_amount?: boolean
    unprotection_days?: boolean
    unprotection_switch?: boolean
    main_currency?: boolean
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid?: boolean
  }

  export type VipInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level" | "deposit_exp" | "bet_exp" | "rank_bet_exp" | "rank_deposit_exp" | "rank_name" | "icon" | "exp_switch_type" | "now_deposit_exp" | "level_deposit_exp" | "now_bet_exp" | "level_bet_exp" | "telegram" | "is_protection" | "protection_deposit_exp" | "protection_deposit_amount" | "protection_bet_exp" | "protection_bet_amount" | "protection_days" | "protection_switch" | "cycle_award_switch" | "level_award_switch" | "signin_award_switch" | "bet_award_switch" | "withdrawal_award_switch" | "unprotection_deposit_exp" | "unprotection_deposit_amount" | "unprotection_bet_exp" | "unprotection_bet_amount" | "unprotection_days" | "unprotection_switch" | "main_currency" | "can_receive_level_award" | "can_receive_rank_award" | "can_receive_day_award" | "can_receive_week_award" | "can_receive_month_award" | "can_receive_signin_award" | "can_receive_bet_award" | "can_receive_withdrawal_award" | "userid", ExtArgs["result"]["vipInfo"]>
  export type VipInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VipInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VipInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VipInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VipInfo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      level: number
      deposit_exp: number
      bet_exp: number
      rank_bet_exp: number
      rank_deposit_exp: number
      rank_name: string
      icon: string
      exp_switch_type: number
      now_deposit_exp: string
      level_deposit_exp: string
      now_bet_exp: string
      level_bet_exp: string
      telegram: string
      is_protection: boolean
      protection_deposit_exp: string
      protection_deposit_amount: string
      protection_bet_exp: string
      protection_bet_amount: string
      protection_days: number
      protection_switch: number
      cycle_award_switch: boolean
      level_award_switch: boolean
      signin_award_switch: boolean
      bet_award_switch: boolean
      withdrawal_award_switch: boolean
      unprotection_deposit_exp: string
      unprotection_deposit_amount: string
      unprotection_bet_exp: string
      unprotection_bet_amount: string
      unprotection_days: number
      unprotection_switch: number
      main_currency: string
      can_receive_level_award: boolean
      can_receive_rank_award: boolean
      can_receive_day_award: boolean
      can_receive_week_award: boolean
      can_receive_month_award: boolean
      can_receive_signin_award: boolean
      can_receive_bet_award: boolean
      can_receive_withdrawal_award: boolean
      userid: string
    }, ExtArgs["result"]["vipInfo"]>
    composites: {}
  }

  type VipInfoGetPayload<S extends boolean | null | undefined | VipInfoDefaultArgs> = $Result.GetResult<Prisma.$VipInfoPayload, S>

  type VipInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VipInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VipInfoCountAggregateInputType | true
    }

  export interface VipInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VipInfo'], meta: { name: 'VipInfo' } }
    /**
     * Find zero or one VipInfo that matches the filter.
     * @param {VipInfoFindUniqueArgs} args - Arguments to find a VipInfo
     * @example
     * // Get one VipInfo
     * const vipInfo = await prisma.vipInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VipInfoFindUniqueArgs>(args: SelectSubset<T, VipInfoFindUniqueArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VipInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VipInfoFindUniqueOrThrowArgs} args - Arguments to find a VipInfo
     * @example
     * // Get one VipInfo
     * const vipInfo = await prisma.vipInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VipInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, VipInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VipInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoFindFirstArgs} args - Arguments to find a VipInfo
     * @example
     * // Get one VipInfo
     * const vipInfo = await prisma.vipInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VipInfoFindFirstArgs>(args?: SelectSubset<T, VipInfoFindFirstArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VipInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoFindFirstOrThrowArgs} args - Arguments to find a VipInfo
     * @example
     * // Get one VipInfo
     * const vipInfo = await prisma.vipInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VipInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, VipInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VipInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VipInfos
     * const vipInfos = await prisma.vipInfo.findMany()
     * 
     * // Get first 10 VipInfos
     * const vipInfos = await prisma.vipInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vipInfoWithIdOnly = await prisma.vipInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VipInfoFindManyArgs>(args?: SelectSubset<T, VipInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VipInfo.
     * @param {VipInfoCreateArgs} args - Arguments to create a VipInfo.
     * @example
     * // Create one VipInfo
     * const VipInfo = await prisma.vipInfo.create({
     *   data: {
     *     // ... data to create a VipInfo
     *   }
     * })
     * 
     */
    create<T extends VipInfoCreateArgs>(args: SelectSubset<T, VipInfoCreateArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VipInfos.
     * @param {VipInfoCreateManyArgs} args - Arguments to create many VipInfos.
     * @example
     * // Create many VipInfos
     * const vipInfo = await prisma.vipInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VipInfoCreateManyArgs>(args?: SelectSubset<T, VipInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VipInfos and returns the data saved in the database.
     * @param {VipInfoCreateManyAndReturnArgs} args - Arguments to create many VipInfos.
     * @example
     * // Create many VipInfos
     * const vipInfo = await prisma.vipInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VipInfos and only return the `id`
     * const vipInfoWithIdOnly = await prisma.vipInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VipInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, VipInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VipInfo.
     * @param {VipInfoDeleteArgs} args - Arguments to delete one VipInfo.
     * @example
     * // Delete one VipInfo
     * const VipInfo = await prisma.vipInfo.delete({
     *   where: {
     *     // ... filter to delete one VipInfo
     *   }
     * })
     * 
     */
    delete<T extends VipInfoDeleteArgs>(args: SelectSubset<T, VipInfoDeleteArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VipInfo.
     * @param {VipInfoUpdateArgs} args - Arguments to update one VipInfo.
     * @example
     * // Update one VipInfo
     * const vipInfo = await prisma.vipInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VipInfoUpdateArgs>(args: SelectSubset<T, VipInfoUpdateArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VipInfos.
     * @param {VipInfoDeleteManyArgs} args - Arguments to filter VipInfos to delete.
     * @example
     * // Delete a few VipInfos
     * const { count } = await prisma.vipInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VipInfoDeleteManyArgs>(args?: SelectSubset<T, VipInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VipInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VipInfos
     * const vipInfo = await prisma.vipInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VipInfoUpdateManyArgs>(args: SelectSubset<T, VipInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VipInfos and returns the data updated in the database.
     * @param {VipInfoUpdateManyAndReturnArgs} args - Arguments to update many VipInfos.
     * @example
     * // Update many VipInfos
     * const vipInfo = await prisma.vipInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VipInfos and only return the `id`
     * const vipInfoWithIdOnly = await prisma.vipInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VipInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, VipInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VipInfo.
     * @param {VipInfoUpsertArgs} args - Arguments to update or create a VipInfo.
     * @example
     * // Update or create a VipInfo
     * const vipInfo = await prisma.vipInfo.upsert({
     *   create: {
     *     // ... data to create a VipInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VipInfo we want to update
     *   }
     * })
     */
    upsert<T extends VipInfoUpsertArgs>(args: SelectSubset<T, VipInfoUpsertArgs<ExtArgs>>): Prisma__VipInfoClient<$Result.GetResult<Prisma.$VipInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VipInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoCountArgs} args - Arguments to filter VipInfos to count.
     * @example
     * // Count the number of VipInfos
     * const count = await prisma.vipInfo.count({
     *   where: {
     *     // ... the filter for the VipInfos we want to count
     *   }
     * })
    **/
    count<T extends VipInfoCountArgs>(
      args?: Subset<T, VipInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VipInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VipInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VipInfoAggregateArgs>(args: Subset<T, VipInfoAggregateArgs>): Prisma.PrismaPromise<GetVipInfoAggregateType<T>>

    /**
     * Group by VipInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VipInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VipInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VipInfoGroupByArgs['orderBy'] }
        : { orderBy?: VipInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VipInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVipInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VipInfo model
   */
  readonly fields: VipInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VipInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VipInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VipInfo model
   */
  interface VipInfoFieldRefs {
    readonly id: FieldRef<"VipInfo", 'Int'>
    readonly level: FieldRef<"VipInfo", 'Int'>
    readonly deposit_exp: FieldRef<"VipInfo", 'Int'>
    readonly bet_exp: FieldRef<"VipInfo", 'Int'>
    readonly rank_bet_exp: FieldRef<"VipInfo", 'Int'>
    readonly rank_deposit_exp: FieldRef<"VipInfo", 'Int'>
    readonly rank_name: FieldRef<"VipInfo", 'String'>
    readonly icon: FieldRef<"VipInfo", 'String'>
    readonly exp_switch_type: FieldRef<"VipInfo", 'Int'>
    readonly now_deposit_exp: FieldRef<"VipInfo", 'String'>
    readonly level_deposit_exp: FieldRef<"VipInfo", 'String'>
    readonly now_bet_exp: FieldRef<"VipInfo", 'String'>
    readonly level_bet_exp: FieldRef<"VipInfo", 'String'>
    readonly telegram: FieldRef<"VipInfo", 'String'>
    readonly is_protection: FieldRef<"VipInfo", 'Boolean'>
    readonly protection_deposit_exp: FieldRef<"VipInfo", 'String'>
    readonly protection_deposit_amount: FieldRef<"VipInfo", 'String'>
    readonly protection_bet_exp: FieldRef<"VipInfo", 'String'>
    readonly protection_bet_amount: FieldRef<"VipInfo", 'String'>
    readonly protection_days: FieldRef<"VipInfo", 'Int'>
    readonly protection_switch: FieldRef<"VipInfo", 'Int'>
    readonly cycle_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly level_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly signin_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly bet_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly withdrawal_award_switch: FieldRef<"VipInfo", 'Boolean'>
    readonly unprotection_deposit_exp: FieldRef<"VipInfo", 'String'>
    readonly unprotection_deposit_amount: FieldRef<"VipInfo", 'String'>
    readonly unprotection_bet_exp: FieldRef<"VipInfo", 'String'>
    readonly unprotection_bet_amount: FieldRef<"VipInfo", 'String'>
    readonly unprotection_days: FieldRef<"VipInfo", 'Int'>
    readonly unprotection_switch: FieldRef<"VipInfo", 'Int'>
    readonly main_currency: FieldRef<"VipInfo", 'String'>
    readonly can_receive_level_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_rank_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_day_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_week_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_month_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_signin_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_bet_award: FieldRef<"VipInfo", 'Boolean'>
    readonly can_receive_withdrawal_award: FieldRef<"VipInfo", 'Boolean'>
    readonly userid: FieldRef<"VipInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VipInfo findUnique
   */
  export type VipInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfo to fetch.
     */
    where: VipInfoWhereUniqueInput
  }

  /**
   * VipInfo findUniqueOrThrow
   */
  export type VipInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfo to fetch.
     */
    where: VipInfoWhereUniqueInput
  }

  /**
   * VipInfo findFirst
   */
  export type VipInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfo to fetch.
     */
    where?: VipInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipInfos to fetch.
     */
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VipInfos.
     */
    cursor?: VipInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VipInfos.
     */
    distinct?: VipInfoScalarFieldEnum | VipInfoScalarFieldEnum[]
  }

  /**
   * VipInfo findFirstOrThrow
   */
  export type VipInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfo to fetch.
     */
    where?: VipInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipInfos to fetch.
     */
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VipInfos.
     */
    cursor?: VipInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VipInfos.
     */
    distinct?: VipInfoScalarFieldEnum | VipInfoScalarFieldEnum[]
  }

  /**
   * VipInfo findMany
   */
  export type VipInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter, which VipInfos to fetch.
     */
    where?: VipInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VipInfos to fetch.
     */
    orderBy?: VipInfoOrderByWithRelationInput | VipInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VipInfos.
     */
    cursor?: VipInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VipInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VipInfos.
     */
    skip?: number
    distinct?: VipInfoScalarFieldEnum | VipInfoScalarFieldEnum[]
  }

  /**
   * VipInfo create
   */
  export type VipInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a VipInfo.
     */
    data: XOR<VipInfoCreateInput, VipInfoUncheckedCreateInput>
  }

  /**
   * VipInfo createMany
   */
  export type VipInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VipInfos.
     */
    data: VipInfoCreateManyInput | VipInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VipInfo createManyAndReturn
   */
  export type VipInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * The data used to create many VipInfos.
     */
    data: VipInfoCreateManyInput | VipInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VipInfo update
   */
  export type VipInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a VipInfo.
     */
    data: XOR<VipInfoUpdateInput, VipInfoUncheckedUpdateInput>
    /**
     * Choose, which VipInfo to update.
     */
    where: VipInfoWhereUniqueInput
  }

  /**
   * VipInfo updateMany
   */
  export type VipInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VipInfos.
     */
    data: XOR<VipInfoUpdateManyMutationInput, VipInfoUncheckedUpdateManyInput>
    /**
     * Filter which VipInfos to update
     */
    where?: VipInfoWhereInput
    /**
     * Limit how many VipInfos to update.
     */
    limit?: number
  }

  /**
   * VipInfo updateManyAndReturn
   */
  export type VipInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * The data used to update VipInfos.
     */
    data: XOR<VipInfoUpdateManyMutationInput, VipInfoUncheckedUpdateManyInput>
    /**
     * Filter which VipInfos to update
     */
    where?: VipInfoWhereInput
    /**
     * Limit how many VipInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VipInfo upsert
   */
  export type VipInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the VipInfo to update in case it exists.
     */
    where: VipInfoWhereUniqueInput
    /**
     * In case the VipInfo found by the `where` argument doesn't exist, create a new VipInfo with this data.
     */
    create: XOR<VipInfoCreateInput, VipInfoUncheckedCreateInput>
    /**
     * In case the VipInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VipInfoUpdateInput, VipInfoUncheckedUpdateInput>
  }

  /**
   * VipInfo delete
   */
  export type VipInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
    /**
     * Filter which VipInfo to delete.
     */
    where: VipInfoWhereUniqueInput
  }

  /**
   * VipInfo deleteMany
   */
  export type VipInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VipInfos to delete
     */
    where?: VipInfoWhereInput
    /**
     * Limit how many VipInfos to delete.
     */
    limit?: number
  }

  /**
   * VipInfo without action
   */
  export type VipInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VipInfo
     */
    select?: VipInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VipInfo
     */
    omit?: VipInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VipInfoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    targetXp: 'targetXp',
    reward: 'reward',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    twoFactorEnabled: 'twoFactorEnabled',
    role: 'role',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires',
    username: 'username',
    passwordHash: 'passwordHash',
    totalXp: 'totalXp',
    balance: 'balance',
    isVerified: 'isVerified',
    active: 'active',
    lastLogin: 'lastLogin',
    lastDailySpin: 'lastDailySpin',
    verificationToken: 'verificationToken',
    avatar: 'avatar',
    activeProfileId: 'activeProfileId',
    vipInfoId: 'vipInfoId',
    gender: 'gender',
    status: 'status',
    cashtag: 'cashtag',
    phpId: 'phpId',
    accessToken: 'accessToken'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    activeGameId: 'activeGameId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    refreshToken: 'refreshToken',
    active: 'active',
    token: 'token',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const OperatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId',
    balance: 'balance'
  };

  export type OperatorScalarFieldEnum = (typeof OperatorScalarFieldEnum)[keyof typeof OperatorScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    xpEarned: 'xpEarned',
    isActive: 'isActive',
    lastPlayed: 'lastPlayed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phpId: 'phpId',
    userId: 'userId',
    currency: 'currency',
    shopId: 'shopId'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    title: 'title',
    temperature: 'temperature',
    developer: 'developer',
    vipLevel: 'vipLevel',
    isActive: 'isActive',
    device: 'device',
    featured: 'featured',
    gamebank: 'gamebank',
    bet: 'bet',
    denomination: 'denomination',
    categoryTemp: 'categoryTemp',
    originalId: 'originalId',
    bids: 'bids',
    statIn: 'statIn',
    statOut: 'statOut',
    currentRtp: 'currentRtp',
    rtpStatIn: 'rtpStatIn',
    rtpStatOut: 'rtpStatOut',
    standardRtp: 'standardRtp',
    popularity: 'popularity',
    chanceFirepot1: 'chanceFirepot1',
    chanceFirepot2: 'chanceFirepot2',
    chanceFirepot3: 'chanceFirepot3',
    fireCount1: 'fireCount1',
    fireCount2: 'fireCount2',
    fireCount3: 'fireCount3',
    linesPercentConfigSpin: 'linesPercentConfigSpin',
    linesPercentConfigSpinBonus: 'linesPercentConfigSpinBonus',
    linesPercentConfigBonus: 'linesPercentConfigBonus',
    linesPercentConfigBonusBonus: 'linesPercentConfigBonusBonus',
    rezerv: 'rezerv',
    cask: 'cask',
    advanced: 'advanced',
    scaleMode: 'scaleMode',
    slotViewState: 'slotViewState',
    view: 'view',
    categoryId: 'categoryId',
    operatorId: 'operatorId',
    providerId: 'providerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    category: 'category',
    jackpotGroupId: 'jackpotGroupId',
    active: 'active',
    password: 'password'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const OperatorgameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    thumbnail: 'thumbnail',
    minBet: 'minBet',
    maxBet: 'maxBet',
    xpMultiplier: 'xpMultiplier',
    isActive: 'isActive',
    isPromoted: 'isPromoted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    operatorId: 'operatorId'
  };

  export type OperatorgameScalarFieldEnum = (typeof OperatorgameScalarFieldEnum)[keyof typeof OperatorgameScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    email: 'email',
    role: 'role',
    status: 'status',
    expiresAt: 'expiresAt',
    inviterId: 'inviterId'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const TwoFactorScalarFieldEnum: {
    id: 'id',
    secret: 'secret',
    backupCodes: 'backupCodes',
    userId: 'userId'
  };

  export type TwoFactorScalarFieldEnum = (typeof TwoFactorScalarFieldEnum)[keyof typeof TwoFactorScalarFieldEnum]


  export const ChatmessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    channel: 'channel',
    metadata: 'metadata',
    createdAt: 'createdAt',
    userId: 'userId',
    roomId: 'roomId'
  };

  export type ChatmessageScalarFieldEnum = (typeof ChatmessageScalarFieldEnum)[keyof typeof ChatmessageScalarFieldEnum]


  export const ChatroomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isGameRoom: 'isGameRoom',
    createdAt: 'createdAt',
    gameSessionId: 'gameSessionId'
  };

  export type ChatroomScalarFieldEnum = (typeof ChatroomScalarFieldEnum)[keyof typeof ChatroomScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    friendId: 'friendId'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const GamesessionScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    betAmount: 'betAmount',
    winAmount: 'winAmount',
    xpEarned: 'xpEarned',
    metadata: 'metadata',
    gameId: 'gameId',
    tournamentId: 'tournamentId',
    active: 'active',
    profileId: 'profileId'
  };

  export type GamesessionScalarFieldEnum = (typeof GamesessionScalarFieldEnum)[keyof typeof GamesessionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url',
    type: 'type',
    bonusCode: 'bonusCode',
    bonusTotalInCredits: 'bonusTotalInCredits',
    priceInCents: 'priceInCents',
    amountToReceiveInCredits: 'amountToReceiveInCredits',
    bestValue: 'bestValue',
    discountInCents: 'discountInCents',
    bonusSpins: 'bonusSpins',
    isPromo: 'isPromo',
    totalDiscountInCents: 'totalDiscountInCents',
    shopId: 'shopId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    readAt: 'readAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const TournamentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    entryFee: 'entryFee',
    prizePool: 'prizePool',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    operatorId: 'operatorId',
    leaderboard: 'leaderboard'
  };

  export type TournamentScalarFieldEnum = (typeof TournamentScalarFieldEnum)[keyof typeof TournamentScalarFieldEnum]


  export const TournamententryScalarFieldEnum: {
    id: 'id',
    score: 'score',
    wagered: 'wagered',
    won: 'won',
    joinedAt: 'joinedAt',
    userId: 'userId',
    tournamentId: 'tournamentId',
    profileId: 'profileId'
  };

  export type TournamententryScalarFieldEnum = (typeof TournamententryScalarFieldEnum)[keyof typeof TournamententryScalarFieldEnum]


  export const TournamentgameScalarFieldEnum: {
    id: 'id',
    multiplier: 'multiplier',
    tournamentId: 'tournamentId',
    gameId: 'gameId'
  };

  export type TournamentgameScalarFieldEnum = (typeof TournamentgameScalarFieldEnum)[keyof typeof TournamentgameScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    reference: 'reference',
    status: 'status',
    metadata: 'metadata',
    isRealMoney: 'isRealMoney',
    paymentMethod: 'paymentMethod',
    paymentDetails: 'paymentDetails',
    createdAt: 'createdAt',
    processedAt: 'processedAt',
    gameSessionId: 'gameSessionId',
    profileId: 'profileId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UserachievementScalarFieldEnum: {
    id: 'id',
    progress: 'progress',
    isUnlocked: 'isUnlocked',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    achievementId: 'achievementId'
  };

  export type UserachievementScalarFieldEnum = (typeof UserachievementScalarFieldEnum)[keyof typeof UserachievementScalarFieldEnum]


  export const RainBetScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    betAmount: 'betAmount',
    odds: 'odds',
    outcome: 'outcome',
    settledAt: 'settledAt'
  };

  export type RainBetScalarFieldEnum = (typeof RainBetScalarFieldEnum)[keyof typeof RainBetScalarFieldEnum]


  export const RainHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    rainType: 'rainType',
    createdAt: 'createdAt'
  };

  export type RainHistoryScalarFieldEnum = (typeof RainHistoryScalarFieldEnum)[keyof typeof RainHistoryScalarFieldEnum]


  export const RainTipScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    tipAmount: 'tipAmount',
    tippedAt: 'tippedAt'
  };

  export type RainTipScalarFieldEnum = (typeof RainTipScalarFieldEnum)[keyof typeof RainTipScalarFieldEnum]


  export const RainWinnerScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    wonAmount: 'wonAmount',
    wonAt: 'wonAt'
  };

  export type RainWinnerScalarFieldEnum = (typeof RainWinnerScalarFieldEnum)[keyof typeof RainWinnerScalarFieldEnum]


  export const VipInfoScalarFieldEnum: {
    id: 'id',
    level: 'level',
    deposit_exp: 'deposit_exp',
    bet_exp: 'bet_exp',
    rank_bet_exp: 'rank_bet_exp',
    rank_deposit_exp: 'rank_deposit_exp',
    rank_name: 'rank_name',
    icon: 'icon',
    exp_switch_type: 'exp_switch_type',
    now_deposit_exp: 'now_deposit_exp',
    level_deposit_exp: 'level_deposit_exp',
    now_bet_exp: 'now_bet_exp',
    level_bet_exp: 'level_bet_exp',
    telegram: 'telegram',
    is_protection: 'is_protection',
    protection_deposit_exp: 'protection_deposit_exp',
    protection_deposit_amount: 'protection_deposit_amount',
    protection_bet_exp: 'protection_bet_exp',
    protection_bet_amount: 'protection_bet_amount',
    protection_days: 'protection_days',
    protection_switch: 'protection_switch',
    cycle_award_switch: 'cycle_award_switch',
    level_award_switch: 'level_award_switch',
    signin_award_switch: 'signin_award_switch',
    bet_award_switch: 'bet_award_switch',
    withdrawal_award_switch: 'withdrawal_award_switch',
    unprotection_deposit_exp: 'unprotection_deposit_exp',
    unprotection_deposit_amount: 'unprotection_deposit_amount',
    unprotection_bet_exp: 'unprotection_bet_exp',
    unprotection_bet_amount: 'unprotection_bet_amount',
    unprotection_days: 'unprotection_days',
    unprotection_switch: 'unprotection_switch',
    main_currency: 'main_currency',
    can_receive_level_award: 'can_receive_level_award',
    can_receive_rank_award: 'can_receive_rank_award',
    can_receive_day_award: 'can_receive_day_award',
    can_receive_week_award: 'can_receive_week_award',
    can_receive_month_award: 'can_receive_month_award',
    can_receive_signin_award: 'can_receive_signin_award',
    can_receive_bet_award: 'can_receive_bet_award',
    can_receive_withdrawal_award: 'can_receive_withdrawal_award',
    userid: 'userid'
  };

  export type VipInfoScalarFieldEnum = (typeof VipInfoScalarFieldEnum)[keyof typeof VipInfoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'GameCategory'
   */
  export type EnumGameCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameCategory'>
    


  /**
   * Reference to a field of type 'GameCategory[]'
   */
  export type ListEnumGameCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameCategory[]'>
    


  /**
   * Reference to a field of type 'ChatChannel'
   */
  export type EnumChatChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatChannel'>
    


  /**
   * Reference to a field of type 'ChatChannel[]'
   */
  export type ListEnumChatChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatChannel[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'FriendshipStatus'
   */
  export type EnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus'>
    


  /**
   * Reference to a field of type 'FriendshipStatus[]'
   */
  export type ListEnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type achievementWhereInput = {
    AND?: achievementWhereInput | achievementWhereInput[]
    OR?: achievementWhereInput[]
    NOT?: achievementWhereInput | achievementWhereInput[]
    id?: StringFilter<"achievement"> | string
    name?: StringFilter<"achievement"> | string
    description?: StringFilter<"achievement"> | string
    targetXp?: IntFilter<"achievement"> | number
    reward?: IntNullableFilter<"achievement"> | number | null
    isActive?: BoolFilter<"achievement"> | boolean
    createdAt?: DateTimeFilter<"achievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"achievement"> | Date | string | null
    userachievement?: UserachievementListRelationFilter
  }

  export type achievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userachievement?: userachievementOrderByRelationAggregateInput
  }

  export type achievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: achievementWhereInput | achievementWhereInput[]
    OR?: achievementWhereInput[]
    NOT?: achievementWhereInput | achievementWhereInput[]
    name?: StringFilter<"achievement"> | string
    description?: StringFilter<"achievement"> | string
    targetXp?: IntFilter<"achievement"> | number
    reward?: IntNullableFilter<"achievement"> | number | null
    isActive?: BoolFilter<"achievement"> | boolean
    createdAt?: DateTimeFilter<"achievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"achievement"> | Date | string | null
    userachievement?: UserachievementListRelationFilter
  }, "id">

  export type achievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: achievementCountOrderByAggregateInput
    _avg?: achievementAvgOrderByAggregateInput
    _max?: achievementMaxOrderByAggregateInput
    _min?: achievementMinOrderByAggregateInput
    _sum?: achievementSumOrderByAggregateInput
  }

  export type achievementScalarWhereWithAggregatesInput = {
    AND?: achievementScalarWhereWithAggregatesInput | achievementScalarWhereWithAggregatesInput[]
    OR?: achievementScalarWhereWithAggregatesInput[]
    NOT?: achievementScalarWhereWithAggregatesInput | achievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"achievement"> | string
    name?: StringWithAggregatesFilter<"achievement"> | string
    description?: StringWithAggregatesFilter<"achievement"> | string
    targetXp?: IntWithAggregatesFilter<"achievement"> | number
    reward?: IntNullableWithAggregatesFilter<"achievement"> | number | null
    isActive?: BoolWithAggregatesFilter<"achievement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"achievement"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"achievement"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolNullableFilter<"User"> | boolean | null
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    username?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    totalXp?: IntFilter<"User"> | number
    balance?: IntFilter<"User"> | number
    isVerified?: BoolFilter<"User"> | boolean
    active?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastDailySpin?: DateTimeNullableFilter<"User"> | Date | string | null
    verificationToken?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    activeProfileId?: StringNullableFilter<"User"> | string | null
    vipInfoId?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    status?: EnumUserStatusNullableFilter<"User"> | $Enums.UserStatus | null
    cashtag?: StringNullableFilter<"User"> | string | null
    phpId?: IntNullableFilter<"User"> | number | null
    accessToken?: StringNullableFilter<"User"> | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    members?: MemberListRelationFilter
    invitations?: InvitationListRelationFilter
    twofactors?: TwoFactorListRelationFilter
    RainBet?: RainBetListRelationFilter
    RainHistory?: RainHistoryListRelationFilter
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
    chatmessage?: ChatmessageListRelationFilter
    friendship_friendship_friendIdTouser?: FriendshipListRelationFilter
    friendship_friendship_userIdTouser?: FriendshipListRelationFilter
    notification?: NotificationListRelationFilter
    operator?: OperatorListRelationFilter
    activeProfile?: ProfileListRelationFilter
    tournamententry?: TournamententryListRelationFilter
    userachievement?: UserachievementListRelationFilter
    vipInfo?: VipInfoListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    username?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    lastDailySpin?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    activeProfileId?: SortOrderInput | SortOrder
    vipInfoId?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cashtag?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    members?: MemberOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
    twofactors?: TwoFactorOrderByRelationAggregateInput
    RainBet?: RainBetOrderByRelationAggregateInput
    RainHistory?: RainHistoryOrderByRelationAggregateInput
    RainTip?: RainTipOrderByRelationAggregateInput
    RainWinner?: RainWinnerOrderByRelationAggregateInput
    chatmessage?: chatmessageOrderByRelationAggregateInput
    friendship_friendship_friendIdTouser?: friendshipOrderByRelationAggregateInput
    friendship_friendship_userIdTouser?: friendshipOrderByRelationAggregateInput
    notification?: notificationOrderByRelationAggregateInput
    operator?: OperatorOrderByRelationAggregateInput
    activeProfile?: ProfileOrderByRelationAggregateInput
    tournamententry?: tournamententryOrderByRelationAggregateInput
    userachievement?: userachievementOrderByRelationAggregateInput
    vipInfo?: VipInfoOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    activeProfileId?: string
    vipInfoId?: string
    vipInfoId_id?: UserVipInfoIdIdCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolNullableFilter<"User"> | boolean | null
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolNullableFilter<"User"> | boolean | null
    role?: StringNullableFilter<"User"> | string | null
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    totalXp?: IntFilter<"User"> | number
    balance?: IntFilter<"User"> | number
    isVerified?: BoolFilter<"User"> | boolean
    active?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastDailySpin?: DateTimeNullableFilter<"User"> | Date | string | null
    verificationToken?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    status?: EnumUserStatusNullableFilter<"User"> | $Enums.UserStatus | null
    cashtag?: StringNullableFilter<"User"> | string | null
    phpId?: IntNullableFilter<"User"> | number | null
    accessToken?: StringNullableFilter<"User"> | string | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    members?: MemberListRelationFilter
    invitations?: InvitationListRelationFilter
    twofactors?: TwoFactorListRelationFilter
    RainBet?: RainBetListRelationFilter
    RainHistory?: RainHistoryListRelationFilter
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
    chatmessage?: ChatmessageListRelationFilter
    friendship_friendship_friendIdTouser?: FriendshipListRelationFilter
    friendship_friendship_userIdTouser?: FriendshipListRelationFilter
    notification?: NotificationListRelationFilter
    operator?: OperatorListRelationFilter
    activeProfile?: ProfileListRelationFilter
    tournamententry?: TournamententryListRelationFilter
    userachievement?: UserachievementListRelationFilter
    vipInfo?: VipInfoListRelationFilter
  }, "id" | "username" | "activeProfileId" | "vipInfoId" | "vipInfoId_id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    username?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    lastDailySpin?: SortOrderInput | SortOrder
    verificationToken?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    activeProfileId?: SortOrderInput | SortOrder
    vipInfoId?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cashtag?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    banned?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    banReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    totalXp?: IntWithAggregatesFilter<"User"> | number
    balance?: IntWithAggregatesFilter<"User"> | number
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    active?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastDailySpin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    activeProfileId?: StringNullableWithAggregatesFilter<"User"> | string | null
    vipInfoId?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    status?: EnumUserStatusNullableWithAggregatesFilter<"User"> | $Enums.UserStatus | null
    cashtag?: StringNullableWithAggregatesFilter<"User"> | string | null
    phpId?: IntNullableWithAggregatesFilter<"User"> | number | null
    accessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    activeGameId?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    active?: BoolFilter<"Session"> | boolean
    token?: StringFilter<"Session"> | string
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    activeGameId?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    active?: BoolFilter<"Session"> | boolean
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    activeGameId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    refreshToken?: StringNullableWithAggregatesFilter<"Session"> | string | null
    active?: BoolWithAggregatesFilter<"Session"> | boolean
    token?: StringWithAggregatesFilter<"Session"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type OperatorWhereInput = {
    AND?: OperatorWhereInput | OperatorWhereInput[]
    OR?: OperatorWhereInput[]
    NOT?: OperatorWhereInput | OperatorWhereInput[]
    id?: StringFilter<"Operator"> | string
    name?: StringFilter<"Operator"> | string
    slug?: StringFilter<"Operator"> | string
    logo?: StringNullableFilter<"Operator"> | string | null
    description?: StringNullableFilter<"Operator"> | string | null
    isActive?: BoolFilter<"Operator"> | boolean
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Operator"> | Date | string | null
    ownerId?: StringFilter<"Operator"> | string
    balance?: IntFilter<"Operator"> | number
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    games?: GameListRelationFilter
    profiles?: ProfileListRelationFilter
    tournaments?: TournamentListRelationFilter
    Product?: ProductListRelationFilter
  }

  export type OperatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
    owner?: UserOrderByWithRelationInput
    games?: GameOrderByRelationAggregateInput
    profiles?: ProfileOrderByRelationAggregateInput
    tournaments?: tournamentOrderByRelationAggregateInput
    Product?: ProductOrderByRelationAggregateInput
  }

  export type OperatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OperatorWhereInput | OperatorWhereInput[]
    OR?: OperatorWhereInput[]
    NOT?: OperatorWhereInput | OperatorWhereInput[]
    name?: StringFilter<"Operator"> | string
    logo?: StringNullableFilter<"Operator"> | string | null
    description?: StringNullableFilter<"Operator"> | string | null
    isActive?: BoolFilter<"Operator"> | boolean
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Operator"> | Date | string | null
    ownerId?: StringFilter<"Operator"> | string
    balance?: IntFilter<"Operator"> | number
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    games?: GameListRelationFilter
    profiles?: ProfileListRelationFilter
    tournaments?: TournamentListRelationFilter
    Product?: ProductListRelationFilter
  }, "id" | "slug">

  export type OperatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
    _count?: OperatorCountOrderByAggregateInput
    _avg?: OperatorAvgOrderByAggregateInput
    _max?: OperatorMaxOrderByAggregateInput
    _min?: OperatorMinOrderByAggregateInput
    _sum?: OperatorSumOrderByAggregateInput
  }

  export type OperatorScalarWhereWithAggregatesInput = {
    AND?: OperatorScalarWhereWithAggregatesInput | OperatorScalarWhereWithAggregatesInput[]
    OR?: OperatorScalarWhereWithAggregatesInput[]
    NOT?: OperatorScalarWhereWithAggregatesInput | OperatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Operator"> | string
    name?: StringWithAggregatesFilter<"Operator"> | string
    slug?: StringWithAggregatesFilter<"Operator"> | string
    logo?: StringNullableWithAggregatesFilter<"Operator"> | string | null
    description?: StringNullableWithAggregatesFilter<"Operator"> | string | null
    isActive?: BoolWithAggregatesFilter<"Operator"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Operator"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Operator"> | Date | string | null
    ownerId?: StringWithAggregatesFilter<"Operator"> | string
    balance?: IntWithAggregatesFilter<"Operator"> | number
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    authorId?: StringFilter<"Message"> | string
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    authorId?: StringFilter<"Message"> | string
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    authorId?: StringWithAggregatesFilter<"Message"> | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    balance?: IntFilter<"Profile"> | number
    xpEarned?: IntFilter<"Profile"> | number
    isActive?: BoolFilter<"Profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    phpId?: IntNullableFilter<"Profile"> | number | null
    userId?: StringFilter<"Profile"> | string
    currency?: StringFilter<"Profile"> | string
    shopId?: StringFilter<"Profile"> | string
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorScalarRelationFilter, OperatorWhereInput>
    user_profile_userIdTouser?: XOR<UserScalarRelationFilter, UserWhereInput>
    tournamententry?: TournamententryListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
    gamesession?: gamesessionOrderByRelationAggregateInput
    operator?: OperatorOrderByWithRelationInput
    user_profile_userIdTouser?: UserOrderByWithRelationInput
    tournamententry?: tournamententryOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phpId?: number
    userId_shopId?: ProfileUserIdShopIdCompoundUniqueInput
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    balance?: IntFilter<"Profile"> | number
    xpEarned?: IntFilter<"Profile"> | number
    isActive?: BoolFilter<"Profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    userId?: StringFilter<"Profile"> | string
    currency?: StringFilter<"Profile"> | string
    shopId?: StringFilter<"Profile"> | string
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorScalarRelationFilter, OperatorWhereInput>
    user_profile_userIdTouser?: XOR<UserScalarRelationFilter, UserWhereInput>
    tournamententry?: TournamententryListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id" | "phpId" | "userId_shopId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    balance?: IntWithAggregatesFilter<"Profile"> | number
    xpEarned?: IntWithAggregatesFilter<"Profile"> | number
    isActive?: BoolWithAggregatesFilter<"Profile"> | boolean
    lastPlayed?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    phpId?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    userId?: StringWithAggregatesFilter<"Profile"> | string
    currency?: StringWithAggregatesFilter<"Profile"> | string
    shopId?: StringWithAggregatesFilter<"Profile"> | string
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    title?: StringFilter<"Game"> | string
    temperature?: StringNullableFilter<"Game"> | string | null
    developer?: StringNullableFilter<"Game"> | string | null
    vipLevel?: IntNullableFilter<"Game"> | number | null
    isActive?: BoolNullableFilter<"Game"> | boolean | null
    device?: IntNullableFilter<"Game"> | number | null
    featured?: BoolNullableFilter<"Game"> | boolean | null
    gamebank?: StringNullableFilter<"Game"> | string | null
    bet?: FloatNullableFilter<"Game"> | number | null
    denomination?: FloatNullableFilter<"Game"> | number | null
    categoryTemp?: FloatNullableFilter<"Game"> | number | null
    originalId?: IntNullableFilter<"Game"> | number | null
    bids?: IntNullableFilter<"Game"> | number | null
    statIn?: FloatNullableFilter<"Game"> | number | null
    statOut?: FloatNullableFilter<"Game"> | number | null
    currentRtp?: FloatNullableFilter<"Game"> | number | null
    rtpStatIn?: FloatNullableFilter<"Game"> | number | null
    rtpStatOut?: FloatNullableFilter<"Game"> | number | null
    standardRtp?: FloatNullableFilter<"Game"> | number | null
    popularity?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot1?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot2?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot3?: FloatNullableFilter<"Game"> | number | null
    fireCount1?: FloatNullableFilter<"Game"> | number | null
    fireCount2?: FloatNullableFilter<"Game"> | number | null
    fireCount3?: FloatNullableFilter<"Game"> | number | null
    linesPercentConfigSpin?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigSpinBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonusBonus?: StringNullableFilter<"Game"> | string | null
    rezerv?: FloatNullableFilter<"Game"> | number | null
    cask?: FloatNullableFilter<"Game"> | number | null
    advanced?: StringNullableFilter<"Game"> | string | null
    scaleMode?: StringFilter<"Game"> | string
    slotViewState?: StringFilter<"Game"> | string
    view?: IntNullableFilter<"Game"> | number | null
    categoryId?: StringNullableFilter<"Game"> | string | null
    operatorId?: StringNullableFilter<"Game"> | string | null
    providerId?: StringNullableFilter<"Game"> | string | null
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    category?: EnumGameCategoryFilter<"Game"> | $Enums.GameCategory
    jackpotGroupId?: StringNullableFilter<"Game"> | string | null
    active?: BoolFilter<"Game"> | boolean
    password?: StringNullableFilter<"Game"> | string | null
    operator?: XOR<OperatorNullableScalarRelationFilter, OperatorWhereInput> | null
    gamesession?: GamesessionListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrderInput | SortOrder
    developer?: SortOrderInput | SortOrder
    vipLevel?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    featured?: SortOrderInput | SortOrder
    gamebank?: SortOrderInput | SortOrder
    bet?: SortOrderInput | SortOrder
    denomination?: SortOrderInput | SortOrder
    categoryTemp?: SortOrderInput | SortOrder
    originalId?: SortOrderInput | SortOrder
    bids?: SortOrderInput | SortOrder
    statIn?: SortOrderInput | SortOrder
    statOut?: SortOrderInput | SortOrder
    currentRtp?: SortOrderInput | SortOrder
    rtpStatIn?: SortOrderInput | SortOrder
    rtpStatOut?: SortOrderInput | SortOrder
    standardRtp?: SortOrderInput | SortOrder
    popularity?: SortOrderInput | SortOrder
    chanceFirepot1?: SortOrderInput | SortOrder
    chanceFirepot2?: SortOrderInput | SortOrder
    chanceFirepot3?: SortOrderInput | SortOrder
    fireCount1?: SortOrderInput | SortOrder
    fireCount2?: SortOrderInput | SortOrder
    fireCount3?: SortOrderInput | SortOrder
    linesPercentConfigSpin?: SortOrderInput | SortOrder
    linesPercentConfigSpinBonus?: SortOrderInput | SortOrder
    linesPercentConfigBonus?: SortOrderInput | SortOrder
    linesPercentConfigBonusBonus?: SortOrderInput | SortOrder
    rezerv?: SortOrderInput | SortOrder
    cask?: SortOrderInput | SortOrder
    advanced?: SortOrderInput | SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    operatorId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    jackpotGroupId?: SortOrderInput | SortOrder
    active?: SortOrder
    password?: SortOrderInput | SortOrder
    operator?: OperatorOrderByWithRelationInput
    gamesession?: gamesessionOrderByRelationAggregateInput
    tournamentgame?: tournamentgameOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    name?: StringFilter<"Game"> | string
    title?: StringFilter<"Game"> | string
    temperature?: StringNullableFilter<"Game"> | string | null
    developer?: StringNullableFilter<"Game"> | string | null
    vipLevel?: IntNullableFilter<"Game"> | number | null
    isActive?: BoolNullableFilter<"Game"> | boolean | null
    device?: IntNullableFilter<"Game"> | number | null
    featured?: BoolNullableFilter<"Game"> | boolean | null
    gamebank?: StringNullableFilter<"Game"> | string | null
    bet?: FloatNullableFilter<"Game"> | number | null
    denomination?: FloatNullableFilter<"Game"> | number | null
    categoryTemp?: FloatNullableFilter<"Game"> | number | null
    originalId?: IntNullableFilter<"Game"> | number | null
    bids?: IntNullableFilter<"Game"> | number | null
    statIn?: FloatNullableFilter<"Game"> | number | null
    statOut?: FloatNullableFilter<"Game"> | number | null
    currentRtp?: FloatNullableFilter<"Game"> | number | null
    rtpStatIn?: FloatNullableFilter<"Game"> | number | null
    rtpStatOut?: FloatNullableFilter<"Game"> | number | null
    standardRtp?: FloatNullableFilter<"Game"> | number | null
    popularity?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot1?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot2?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot3?: FloatNullableFilter<"Game"> | number | null
    fireCount1?: FloatNullableFilter<"Game"> | number | null
    fireCount2?: FloatNullableFilter<"Game"> | number | null
    fireCount3?: FloatNullableFilter<"Game"> | number | null
    linesPercentConfigSpin?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigSpinBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonusBonus?: StringNullableFilter<"Game"> | string | null
    rezerv?: FloatNullableFilter<"Game"> | number | null
    cask?: FloatNullableFilter<"Game"> | number | null
    advanced?: StringNullableFilter<"Game"> | string | null
    scaleMode?: StringFilter<"Game"> | string
    slotViewState?: StringFilter<"Game"> | string
    view?: IntNullableFilter<"Game"> | number | null
    categoryId?: StringNullableFilter<"Game"> | string | null
    operatorId?: StringNullableFilter<"Game"> | string | null
    providerId?: StringNullableFilter<"Game"> | string | null
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    category?: EnumGameCategoryFilter<"Game"> | $Enums.GameCategory
    jackpotGroupId?: StringNullableFilter<"Game"> | string | null
    active?: BoolFilter<"Game"> | boolean
    password?: StringNullableFilter<"Game"> | string | null
    operator?: XOR<OperatorNullableScalarRelationFilter, OperatorWhereInput> | null
    gamesession?: GamesessionListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }, "id">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrderInput | SortOrder
    developer?: SortOrderInput | SortOrder
    vipLevel?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    featured?: SortOrderInput | SortOrder
    gamebank?: SortOrderInput | SortOrder
    bet?: SortOrderInput | SortOrder
    denomination?: SortOrderInput | SortOrder
    categoryTemp?: SortOrderInput | SortOrder
    originalId?: SortOrderInput | SortOrder
    bids?: SortOrderInput | SortOrder
    statIn?: SortOrderInput | SortOrder
    statOut?: SortOrderInput | SortOrder
    currentRtp?: SortOrderInput | SortOrder
    rtpStatIn?: SortOrderInput | SortOrder
    rtpStatOut?: SortOrderInput | SortOrder
    standardRtp?: SortOrderInput | SortOrder
    popularity?: SortOrderInput | SortOrder
    chanceFirepot1?: SortOrderInput | SortOrder
    chanceFirepot2?: SortOrderInput | SortOrder
    chanceFirepot3?: SortOrderInput | SortOrder
    fireCount1?: SortOrderInput | SortOrder
    fireCount2?: SortOrderInput | SortOrder
    fireCount3?: SortOrderInput | SortOrder
    linesPercentConfigSpin?: SortOrderInput | SortOrder
    linesPercentConfigSpinBonus?: SortOrderInput | SortOrder
    linesPercentConfigBonus?: SortOrderInput | SortOrder
    linesPercentConfigBonusBonus?: SortOrderInput | SortOrder
    rezerv?: SortOrderInput | SortOrder
    cask?: SortOrderInput | SortOrder
    advanced?: SortOrderInput | SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    operatorId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    jackpotGroupId?: SortOrderInput | SortOrder
    active?: SortOrder
    password?: SortOrderInput | SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    name?: StringWithAggregatesFilter<"Game"> | string
    title?: StringWithAggregatesFilter<"Game"> | string
    temperature?: StringNullableWithAggregatesFilter<"Game"> | string | null
    developer?: StringNullableWithAggregatesFilter<"Game"> | string | null
    vipLevel?: IntNullableWithAggregatesFilter<"Game"> | number | null
    isActive?: BoolNullableWithAggregatesFilter<"Game"> | boolean | null
    device?: IntNullableWithAggregatesFilter<"Game"> | number | null
    featured?: BoolNullableWithAggregatesFilter<"Game"> | boolean | null
    gamebank?: StringNullableWithAggregatesFilter<"Game"> | string | null
    bet?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    denomination?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    categoryTemp?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    originalId?: IntNullableWithAggregatesFilter<"Game"> | number | null
    bids?: IntNullableWithAggregatesFilter<"Game"> | number | null
    statIn?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    statOut?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    currentRtp?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    rtpStatIn?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    rtpStatOut?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    standardRtp?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    popularity?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    chanceFirepot1?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    chanceFirepot2?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    chanceFirepot3?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    fireCount1?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    fireCount2?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    fireCount3?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    linesPercentConfigSpin?: StringNullableWithAggregatesFilter<"Game"> | string | null
    linesPercentConfigSpinBonus?: StringNullableWithAggregatesFilter<"Game"> | string | null
    linesPercentConfigBonus?: StringNullableWithAggregatesFilter<"Game"> | string | null
    linesPercentConfigBonusBonus?: StringNullableWithAggregatesFilter<"Game"> | string | null
    rezerv?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    cask?: FloatNullableWithAggregatesFilter<"Game"> | number | null
    advanced?: StringNullableWithAggregatesFilter<"Game"> | string | null
    scaleMode?: StringWithAggregatesFilter<"Game"> | string
    slotViewState?: StringWithAggregatesFilter<"Game"> | string
    view?: IntNullableWithAggregatesFilter<"Game"> | number | null
    categoryId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    operatorId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    providerId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    category?: EnumGameCategoryWithAggregatesFilter<"Game"> | $Enums.GameCategory
    jackpotGroupId?: StringNullableWithAggregatesFilter<"Game"> | string | null
    active?: BoolWithAggregatesFilter<"Game"> | boolean
    password?: StringNullableWithAggregatesFilter<"Game"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
  }

  export type operatorgameWhereInput = {
    AND?: operatorgameWhereInput | operatorgameWhereInput[]
    OR?: operatorgameWhereInput[]
    NOT?: operatorgameWhereInput | operatorgameWhereInput[]
    id?: StringFilter<"operatorgame"> | string
    name?: StringFilter<"operatorgame"> | string
    slug?: StringFilter<"operatorgame"> | string
    description?: StringNullableFilter<"operatorgame"> | string | null
    thumbnail?: StringNullableFilter<"operatorgame"> | string | null
    minBet?: IntNullableFilter<"operatorgame"> | number | null
    maxBet?: IntNullableFilter<"operatorgame"> | number | null
    xpMultiplier?: FloatFilter<"operatorgame"> | number
    isActive?: BoolFilter<"operatorgame"> | boolean
    isPromoted?: BoolFilter<"operatorgame"> | boolean
    createdAt?: DateTimeFilter<"operatorgame"> | Date | string
    updatedAt?: DateTimeNullableFilter<"operatorgame"> | Date | string | null
    operatorId?: StringFilter<"operatorgame"> | string
  }

  export type operatorgameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    minBet?: SortOrderInput | SortOrder
    maxBet?: SortOrderInput | SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operatorId?: SortOrder
  }

  export type operatorgameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: operatorgameWhereInput | operatorgameWhereInput[]
    OR?: operatorgameWhereInput[]
    NOT?: operatorgameWhereInput | operatorgameWhereInput[]
    name?: StringFilter<"operatorgame"> | string
    description?: StringNullableFilter<"operatorgame"> | string | null
    thumbnail?: StringNullableFilter<"operatorgame"> | string | null
    minBet?: IntNullableFilter<"operatorgame"> | number | null
    maxBet?: IntNullableFilter<"operatorgame"> | number | null
    xpMultiplier?: FloatFilter<"operatorgame"> | number
    isActive?: BoolFilter<"operatorgame"> | boolean
    isPromoted?: BoolFilter<"operatorgame"> | boolean
    createdAt?: DateTimeFilter<"operatorgame"> | Date | string
    updatedAt?: DateTimeNullableFilter<"operatorgame"> | Date | string | null
    operatorId?: StringFilter<"operatorgame"> | string
  }, "id" | "slug">

  export type operatorgameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    minBet?: SortOrderInput | SortOrder
    maxBet?: SortOrderInput | SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operatorId?: SortOrder
    _count?: operatorgameCountOrderByAggregateInput
    _avg?: operatorgameAvgOrderByAggregateInput
    _max?: operatorgameMaxOrderByAggregateInput
    _min?: operatorgameMinOrderByAggregateInput
    _sum?: operatorgameSumOrderByAggregateInput
  }

  export type operatorgameScalarWhereWithAggregatesInput = {
    AND?: operatorgameScalarWhereWithAggregatesInput | operatorgameScalarWhereWithAggregatesInput[]
    OR?: operatorgameScalarWhereWithAggregatesInput[]
    NOT?: operatorgameScalarWhereWithAggregatesInput | operatorgameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"operatorgame"> | string
    name?: StringWithAggregatesFilter<"operatorgame"> | string
    slug?: StringWithAggregatesFilter<"operatorgame"> | string
    description?: StringNullableWithAggregatesFilter<"operatorgame"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"operatorgame"> | string | null
    minBet?: IntNullableWithAggregatesFilter<"operatorgame"> | number | null
    maxBet?: IntNullableWithAggregatesFilter<"operatorgame"> | number | null
    xpMultiplier?: FloatWithAggregatesFilter<"operatorgame"> | number
    isActive?: BoolWithAggregatesFilter<"operatorgame"> | boolean
    isPromoted?: BoolWithAggregatesFilter<"operatorgame"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"operatorgame"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"operatorgame"> | Date | string | null
    operatorId?: StringWithAggregatesFilter<"operatorgame"> | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringNullableFilter<"Organization"> | string | null
    logo?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    metadata?: StringNullableFilter<"Organization"> | string | null
    members?: MemberListRelationFilter
    invitations?: InvitationListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    members?: MemberOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    logo?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    metadata?: StringNullableFilter<"Organization"> | string | null
    members?: MemberListRelationFilter
    invitations?: InvitationListRelationFilter
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"Organization"> | string | null
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: StringFilter<"Member"> | string
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Member"> | string
    organizationId?: StringWithAggregatesFilter<"Member"> | string
    userId?: StringWithAggregatesFilter<"Member"> | string
    role?: StringWithAggregatesFilter<"Member"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    organizationId?: StringWithAggregatesFilter<"Invitation"> | string
    email?: StringWithAggregatesFilter<"Invitation"> | string
    role?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    status?: StringWithAggregatesFilter<"Invitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    inviterId?: StringWithAggregatesFilter<"Invitation"> | string
  }

  export type TwoFactorWhereInput = {
    AND?: TwoFactorWhereInput | TwoFactorWhereInput[]
    OR?: TwoFactorWhereInput[]
    NOT?: TwoFactorWhereInput | TwoFactorWhereInput[]
    id?: StringFilter<"TwoFactor"> | string
    secret?: StringFilter<"TwoFactor"> | string
    backupCodes?: StringFilter<"TwoFactor"> | string
    userId?: StringFilter<"TwoFactor"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TwoFactorOrderByWithRelationInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TwoFactorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TwoFactorWhereInput | TwoFactorWhereInput[]
    OR?: TwoFactorWhereInput[]
    NOT?: TwoFactorWhereInput | TwoFactorWhereInput[]
    secret?: StringFilter<"TwoFactor"> | string
    backupCodes?: StringFilter<"TwoFactor"> | string
    userId?: StringFilter<"TwoFactor"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TwoFactorOrderByWithAggregationInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
    _count?: TwoFactorCountOrderByAggregateInput
    _max?: TwoFactorMaxOrderByAggregateInput
    _min?: TwoFactorMinOrderByAggregateInput
  }

  export type TwoFactorScalarWhereWithAggregatesInput = {
    AND?: TwoFactorScalarWhereWithAggregatesInput | TwoFactorScalarWhereWithAggregatesInput[]
    OR?: TwoFactorScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorScalarWhereWithAggregatesInput | TwoFactorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactor"> | string
    secret?: StringWithAggregatesFilter<"TwoFactor"> | string
    backupCodes?: StringWithAggregatesFilter<"TwoFactor"> | string
    userId?: StringWithAggregatesFilter<"TwoFactor"> | string
  }

  export type chatmessageWhereInput = {
    AND?: chatmessageWhereInput | chatmessageWhereInput[]
    OR?: chatmessageWhereInput[]
    NOT?: chatmessageWhereInput | chatmessageWhereInput[]
    id?: StringFilter<"chatmessage"> | string
    content?: StringFilter<"chatmessage"> | string
    channel?: EnumChatChannelFilter<"chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"chatmessage">
    createdAt?: DateTimeFilter<"chatmessage"> | Date | string
    userId?: StringFilter<"chatmessage"> | string
    roomId?: StringNullableFilter<"chatmessage"> | string | null
    chatroom?: XOR<ChatroomNullableScalarRelationFilter, chatroomWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type chatmessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    chatroom?: chatroomOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type chatmessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatmessageWhereInput | chatmessageWhereInput[]
    OR?: chatmessageWhereInput[]
    NOT?: chatmessageWhereInput | chatmessageWhereInput[]
    content?: StringFilter<"chatmessage"> | string
    channel?: EnumChatChannelFilter<"chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"chatmessage">
    createdAt?: DateTimeFilter<"chatmessage"> | Date | string
    userId?: StringFilter<"chatmessage"> | string
    roomId?: StringNullableFilter<"chatmessage"> | string | null
    chatroom?: XOR<ChatroomNullableScalarRelationFilter, chatroomWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type chatmessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    _count?: chatmessageCountOrderByAggregateInput
    _max?: chatmessageMaxOrderByAggregateInput
    _min?: chatmessageMinOrderByAggregateInput
  }

  export type chatmessageScalarWhereWithAggregatesInput = {
    AND?: chatmessageScalarWhereWithAggregatesInput | chatmessageScalarWhereWithAggregatesInput[]
    OR?: chatmessageScalarWhereWithAggregatesInput[]
    NOT?: chatmessageScalarWhereWithAggregatesInput | chatmessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chatmessage"> | string
    content?: StringWithAggregatesFilter<"chatmessage"> | string
    channel?: EnumChatChannelWithAggregatesFilter<"chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableWithAggregatesFilter<"chatmessage">
    createdAt?: DateTimeWithAggregatesFilter<"chatmessage"> | Date | string
    userId?: StringWithAggregatesFilter<"chatmessage"> | string
    roomId?: StringNullableWithAggregatesFilter<"chatmessage"> | string | null
  }

  export type chatroomWhereInput = {
    AND?: chatroomWhereInput | chatroomWhereInput[]
    OR?: chatroomWhereInput[]
    NOT?: chatroomWhereInput | chatroomWhereInput[]
    id?: StringFilter<"chatroom"> | string
    name?: StringFilter<"chatroom"> | string
    isGameRoom?: BoolFilter<"chatroom"> | boolean
    createdAt?: DateTimeFilter<"chatroom"> | Date | string
    gameSessionId?: StringNullableFilter<"chatroom"> | string | null
    chatmessage?: ChatmessageListRelationFilter
    gamesession?: XOR<GamesessionNullableScalarRelationFilter, gamesessionWhereInput> | null
  }

  export type chatroomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    chatmessage?: chatmessageOrderByRelationAggregateInput
    gamesession?: gamesessionOrderByWithRelationInput
  }

  export type chatroomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatroomWhereInput | chatroomWhereInput[]
    OR?: chatroomWhereInput[]
    NOT?: chatroomWhereInput | chatroomWhereInput[]
    name?: StringFilter<"chatroom"> | string
    isGameRoom?: BoolFilter<"chatroom"> | boolean
    createdAt?: DateTimeFilter<"chatroom"> | Date | string
    gameSessionId?: StringNullableFilter<"chatroom"> | string | null
    chatmessage?: ChatmessageListRelationFilter
    gamesession?: XOR<GamesessionNullableScalarRelationFilter, gamesessionWhereInput> | null
  }, "id">

  export type chatroomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    _count?: chatroomCountOrderByAggregateInput
    _max?: chatroomMaxOrderByAggregateInput
    _min?: chatroomMinOrderByAggregateInput
  }

  export type chatroomScalarWhereWithAggregatesInput = {
    AND?: chatroomScalarWhereWithAggregatesInput | chatroomScalarWhereWithAggregatesInput[]
    OR?: chatroomScalarWhereWithAggregatesInput[]
    NOT?: chatroomScalarWhereWithAggregatesInput | chatroomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chatroom"> | string
    name?: StringWithAggregatesFilter<"chatroom"> | string
    isGameRoom?: BoolWithAggregatesFilter<"chatroom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"chatroom"> | Date | string
    gameSessionId?: StringNullableWithAggregatesFilter<"chatroom"> | string | null
  }

  export type friendshipWhereInput = {
    AND?: friendshipWhereInput | friendshipWhereInput[]
    OR?: friendshipWhereInput[]
    NOT?: friendshipWhereInput | friendshipWhereInput[]
    id?: StringFilter<"friendship"> | string
    status?: EnumFriendshipStatusFilter<"friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeNullableFilter<"friendship"> | Date | string | null
    userId?: StringFilter<"friendship"> | string
    friendId?: StringFilter<"friendship"> | string
    user_friendship_friendIdTouser?: XOR<UserScalarRelationFilter, UserWhereInput>
    user_friendship_userIdTouser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type friendshipOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    user_friendship_friendIdTouser?: UserOrderByWithRelationInput
    user_friendship_userIdTouser?: UserOrderByWithRelationInput
  }

  export type friendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_friendId?: friendshipUserIdFriendIdCompoundUniqueInput
    AND?: friendshipWhereInput | friendshipWhereInput[]
    OR?: friendshipWhereInput[]
    NOT?: friendshipWhereInput | friendshipWhereInput[]
    status?: EnumFriendshipStatusFilter<"friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeNullableFilter<"friendship"> | Date | string | null
    userId?: StringFilter<"friendship"> | string
    friendId?: StringFilter<"friendship"> | string
    user_friendship_friendIdTouser?: XOR<UserScalarRelationFilter, UserWhereInput>
    user_friendship_userIdTouser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_friendId">

  export type friendshipOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    _count?: friendshipCountOrderByAggregateInput
    _max?: friendshipMaxOrderByAggregateInput
    _min?: friendshipMinOrderByAggregateInput
  }

  export type friendshipScalarWhereWithAggregatesInput = {
    AND?: friendshipScalarWhereWithAggregatesInput | friendshipScalarWhereWithAggregatesInput[]
    OR?: friendshipScalarWhereWithAggregatesInput[]
    NOT?: friendshipScalarWhereWithAggregatesInput | friendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"friendship"> | string
    status?: EnumFriendshipStatusWithAggregatesFilter<"friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeWithAggregatesFilter<"friendship"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"friendship"> | Date | string | null
    userId?: StringWithAggregatesFilter<"friendship"> | string
    friendId?: StringWithAggregatesFilter<"friendship"> | string
  }

  export type gamesessionWhereInput = {
    AND?: gamesessionWhereInput | gamesessionWhereInput[]
    OR?: gamesessionWhereInput[]
    NOT?: gamesessionWhereInput | gamesessionWhereInput[]
    id?: StringFilter<"gamesession"> | string
    startTime?: DateTimeFilter<"gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"gamesession"> | Date | string | null
    betAmount?: IntNullableFilter<"gamesession"> | number | null
    winAmount?: IntNullableFilter<"gamesession"> | number | null
    xpEarned?: IntFilter<"gamesession"> | number
    metadata?: JsonNullableFilter<"gamesession">
    gameId?: StringFilter<"gamesession"> | string
    tournamentId?: StringNullableFilter<"gamesession"> | string | null
    active?: BoolFilter<"gamesession"> | boolean
    profileId?: StringFilter<"gamesession"> | string
    chatroom?: ChatroomListRelationFilter
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    tournament?: XOR<TournamentNullableScalarRelationFilter, tournamentWhereInput> | null
    Transaction?: TransactionListRelationFilter
  }

  export type gamesessionOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    betAmount?: SortOrderInput | SortOrder
    winAmount?: SortOrderInput | SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrderInput | SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    active?: SortOrder
    profileId?: SortOrder
    chatroom?: chatroomOrderByRelationAggregateInput
    game?: GameOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    tournament?: tournamentOrderByWithRelationInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type gamesessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: gamesessionWhereInput | gamesessionWhereInput[]
    OR?: gamesessionWhereInput[]
    NOT?: gamesessionWhereInput | gamesessionWhereInput[]
    startTime?: DateTimeFilter<"gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"gamesession"> | Date | string | null
    betAmount?: IntNullableFilter<"gamesession"> | number | null
    winAmount?: IntNullableFilter<"gamesession"> | number | null
    xpEarned?: IntFilter<"gamesession"> | number
    metadata?: JsonNullableFilter<"gamesession">
    gameId?: StringFilter<"gamesession"> | string
    tournamentId?: StringNullableFilter<"gamesession"> | string | null
    active?: BoolFilter<"gamesession"> | boolean
    profileId?: StringFilter<"gamesession"> | string
    chatroom?: ChatroomListRelationFilter
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    tournament?: XOR<TournamentNullableScalarRelationFilter, tournamentWhereInput> | null
    Transaction?: TransactionListRelationFilter
  }, "id">

  export type gamesessionOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    betAmount?: SortOrderInput | SortOrder
    winAmount?: SortOrderInput | SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrderInput | SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    active?: SortOrder
    profileId?: SortOrder
    _count?: gamesessionCountOrderByAggregateInput
    _avg?: gamesessionAvgOrderByAggregateInput
    _max?: gamesessionMaxOrderByAggregateInput
    _min?: gamesessionMinOrderByAggregateInput
    _sum?: gamesessionSumOrderByAggregateInput
  }

  export type gamesessionScalarWhereWithAggregatesInput = {
    AND?: gamesessionScalarWhereWithAggregatesInput | gamesessionScalarWhereWithAggregatesInput[]
    OR?: gamesessionScalarWhereWithAggregatesInput[]
    NOT?: gamesessionScalarWhereWithAggregatesInput | gamesessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"gamesession"> | string
    startTime?: DateTimeWithAggregatesFilter<"gamesession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"gamesession"> | Date | string | null
    betAmount?: IntNullableWithAggregatesFilter<"gamesession"> | number | null
    winAmount?: IntNullableWithAggregatesFilter<"gamesession"> | number | null
    xpEarned?: IntWithAggregatesFilter<"gamesession"> | number
    metadata?: JsonNullableWithAggregatesFilter<"gamesession">
    gameId?: StringWithAggregatesFilter<"gamesession"> | string
    tournamentId?: StringNullableWithAggregatesFilter<"gamesession"> | string | null
    active?: BoolWithAggregatesFilter<"gamesession"> | boolean
    profileId?: StringWithAggregatesFilter<"gamesession"> | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    url?: StringFilter<"Product"> | string
    type?: StringFilter<"Product"> | string
    bonusCode?: StringNullableFilter<"Product"> | string | null
    bonusTotalInCredits?: IntNullableFilter<"Product"> | number | null
    priceInCents?: IntFilter<"Product"> | number
    amountToReceiveInCredits?: IntFilter<"Product"> | number
    bestValue?: IntFilter<"Product"> | number
    discountInCents?: IntFilter<"Product"> | number
    bonusSpins?: IntNullableFilter<"Product"> | number | null
    isPromo?: BoolNullableFilter<"Product"> | boolean | null
    totalDiscountInCents?: IntFilter<"Product"> | number
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    operator?: XOR<OperatorNullableScalarRelationFilter, OperatorWhereInput> | null
    transactions?: TransactionListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrderInput | SortOrder
    bonusTotalInCredits?: SortOrderInput | SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrderInput | SortOrder
    isPromo?: SortOrderInput | SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operator?: OperatorOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    url?: StringFilter<"Product"> | string
    type?: StringFilter<"Product"> | string
    bonusCode?: StringNullableFilter<"Product"> | string | null
    bonusTotalInCredits?: IntNullableFilter<"Product"> | number | null
    priceInCents?: IntFilter<"Product"> | number
    amountToReceiveInCredits?: IntFilter<"Product"> | number
    bestValue?: IntFilter<"Product"> | number
    discountInCents?: IntFilter<"Product"> | number
    bonusSpins?: IntNullableFilter<"Product"> | number | null
    isPromo?: BoolNullableFilter<"Product"> | boolean | null
    totalDiscountInCents?: IntFilter<"Product"> | number
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    operator?: XOR<OperatorNullableScalarRelationFilter, OperatorWhereInput> | null
    transactions?: TransactionListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrderInput | SortOrder
    bonusTotalInCredits?: SortOrderInput | SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrderInput | SortOrder
    isPromo?: SortOrderInput | SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    url?: StringWithAggregatesFilter<"Product"> | string
    type?: StringWithAggregatesFilter<"Product"> | string
    bonusCode?: StringNullableWithAggregatesFilter<"Product"> | string | null
    bonusTotalInCredits?: IntNullableWithAggregatesFilter<"Product"> | number | null
    priceInCents?: IntWithAggregatesFilter<"Product"> | number
    amountToReceiveInCredits?: IntWithAggregatesFilter<"Product"> | number
    bestValue?: IntWithAggregatesFilter<"Product"> | number
    discountInCents?: IntWithAggregatesFilter<"Product"> | number
    bonusSpins?: IntNullableWithAggregatesFilter<"Product"> | number | null
    isPromo?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
    totalDiscountInCents?: IntWithAggregatesFilter<"Product"> | number
    shopId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: StringFilter<"notification"> | string
    type?: EnumNotificationTypeFilter<"notification"> | $Enums.NotificationType
    title?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    readAt?: DateTimeNullableFilter<"notification"> | Date | string | null
    metadata?: JsonNullableFilter<"notification">
    createdAt?: DateTimeFilter<"notification"> | Date | string
    userId?: StringFilter<"notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    type?: EnumNotificationTypeFilter<"notification"> | $Enums.NotificationType
    title?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    readAt?: DateTimeNullableFilter<"notification"> | Date | string | null
    metadata?: JsonNullableFilter<"notification">
    createdAt?: DateTimeFilter<"notification"> | Date | string
    userId?: StringFilter<"notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"notification"> | string
    message?: StringWithAggregatesFilter<"notification"> | string
    isRead?: BoolWithAggregatesFilter<"notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"notification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"notification">
    createdAt?: DateTimeWithAggregatesFilter<"notification"> | Date | string
    userId?: StringWithAggregatesFilter<"notification"> | string
  }

  export type tournamentWhereInput = {
    AND?: tournamentWhereInput | tournamentWhereInput[]
    OR?: tournamentWhereInput[]
    NOT?: tournamentWhereInput | tournamentWhereInput[]
    id?: StringFilter<"tournament"> | string
    name?: StringFilter<"tournament"> | string
    description?: StringNullableFilter<"tournament"> | string | null
    startTime?: DateTimeFilter<"tournament"> | Date | string
    endTime?: DateTimeFilter<"tournament"> | Date | string
    entryFee?: IntNullableFilter<"tournament"> | number | null
    prizePool?: IntFilter<"tournament"> | number
    isActive?: BoolFilter<"tournament"> | boolean
    createdAt?: DateTimeFilter<"tournament"> | Date | string
    updatedAt?: DateTimeNullableFilter<"tournament"> | Date | string | null
    operatorId?: StringFilter<"tournament"> | string
    leaderboard?: JsonNullableFilter<"tournament">
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorScalarRelationFilter, OperatorWhereInput>
    tournamententry?: TournamententryListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }

  export type tournamentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrderInput | SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrderInput | SortOrder
    gamesession?: gamesessionOrderByRelationAggregateInput
    operator?: OperatorOrderByWithRelationInput
    tournamententry?: tournamententryOrderByRelationAggregateInput
    tournamentgame?: tournamentgameOrderByRelationAggregateInput
  }

  export type tournamentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tournamentWhereInput | tournamentWhereInput[]
    OR?: tournamentWhereInput[]
    NOT?: tournamentWhereInput | tournamentWhereInput[]
    name?: StringFilter<"tournament"> | string
    description?: StringNullableFilter<"tournament"> | string | null
    startTime?: DateTimeFilter<"tournament"> | Date | string
    endTime?: DateTimeFilter<"tournament"> | Date | string
    entryFee?: IntNullableFilter<"tournament"> | number | null
    prizePool?: IntFilter<"tournament"> | number
    isActive?: BoolFilter<"tournament"> | boolean
    createdAt?: DateTimeFilter<"tournament"> | Date | string
    updatedAt?: DateTimeNullableFilter<"tournament"> | Date | string | null
    operatorId?: StringFilter<"tournament"> | string
    leaderboard?: JsonNullableFilter<"tournament">
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorScalarRelationFilter, OperatorWhereInput>
    tournamententry?: TournamententryListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }, "id">

  export type tournamentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrderInput | SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrderInput | SortOrder
    _count?: tournamentCountOrderByAggregateInput
    _avg?: tournamentAvgOrderByAggregateInput
    _max?: tournamentMaxOrderByAggregateInput
    _min?: tournamentMinOrderByAggregateInput
    _sum?: tournamentSumOrderByAggregateInput
  }

  export type tournamentScalarWhereWithAggregatesInput = {
    AND?: tournamentScalarWhereWithAggregatesInput | tournamentScalarWhereWithAggregatesInput[]
    OR?: tournamentScalarWhereWithAggregatesInput[]
    NOT?: tournamentScalarWhereWithAggregatesInput | tournamentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournament"> | string
    name?: StringWithAggregatesFilter<"tournament"> | string
    description?: StringNullableWithAggregatesFilter<"tournament"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"tournament"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"tournament"> | Date | string
    entryFee?: IntNullableWithAggregatesFilter<"tournament"> | number | null
    prizePool?: IntWithAggregatesFilter<"tournament"> | number
    isActive?: BoolWithAggregatesFilter<"tournament"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tournament"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"tournament"> | Date | string | null
    operatorId?: StringWithAggregatesFilter<"tournament"> | string
    leaderboard?: JsonNullableWithAggregatesFilter<"tournament">
  }

  export type tournamententryWhereInput = {
    AND?: tournamententryWhereInput | tournamententryWhereInput[]
    OR?: tournamententryWhereInput[]
    NOT?: tournamententryWhereInput | tournamententryWhereInput[]
    id?: StringFilter<"tournamententry"> | string
    score?: IntFilter<"tournamententry"> | number
    wagered?: IntFilter<"tournamententry"> | number
    won?: IntFilter<"tournamententry"> | number
    joinedAt?: DateTimeFilter<"tournamententry"> | Date | string
    userId?: StringFilter<"tournamententry"> | string
    tournamentId?: StringFilter<"tournamententry"> | string
    profileId?: StringFilter<"tournamententry"> | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    tournament?: XOR<TournamentScalarRelationFilter, tournamentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type tournamententryOrderByWithRelationInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    tournament?: tournamentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type tournamententryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tournamentId?: tournamententryUserIdTournamentIdCompoundUniqueInput
    AND?: tournamententryWhereInput | tournamententryWhereInput[]
    OR?: tournamententryWhereInput[]
    NOT?: tournamententryWhereInput | tournamententryWhereInput[]
    score?: IntFilter<"tournamententry"> | number
    wagered?: IntFilter<"tournamententry"> | number
    won?: IntFilter<"tournamententry"> | number
    joinedAt?: DateTimeFilter<"tournamententry"> | Date | string
    userId?: StringFilter<"tournamententry"> | string
    tournamentId?: StringFilter<"tournamententry"> | string
    profileId?: StringFilter<"tournamententry"> | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    tournament?: XOR<TournamentScalarRelationFilter, tournamentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_tournamentId">

  export type tournamententryOrderByWithAggregationInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
    _count?: tournamententryCountOrderByAggregateInput
    _avg?: tournamententryAvgOrderByAggregateInput
    _max?: tournamententryMaxOrderByAggregateInput
    _min?: tournamententryMinOrderByAggregateInput
    _sum?: tournamententrySumOrderByAggregateInput
  }

  export type tournamententryScalarWhereWithAggregatesInput = {
    AND?: tournamententryScalarWhereWithAggregatesInput | tournamententryScalarWhereWithAggregatesInput[]
    OR?: tournamententryScalarWhereWithAggregatesInput[]
    NOT?: tournamententryScalarWhereWithAggregatesInput | tournamententryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournamententry"> | string
    score?: IntWithAggregatesFilter<"tournamententry"> | number
    wagered?: IntWithAggregatesFilter<"tournamententry"> | number
    won?: IntWithAggregatesFilter<"tournamententry"> | number
    joinedAt?: DateTimeWithAggregatesFilter<"tournamententry"> | Date | string
    userId?: StringWithAggregatesFilter<"tournamententry"> | string
    tournamentId?: StringWithAggregatesFilter<"tournamententry"> | string
    profileId?: StringWithAggregatesFilter<"tournamententry"> | string
  }

  export type tournamentgameWhereInput = {
    AND?: tournamentgameWhereInput | tournamentgameWhereInput[]
    OR?: tournamentgameWhereInput[]
    NOT?: tournamentgameWhereInput | tournamentgameWhereInput[]
    id?: StringFilter<"tournamentgame"> | string
    multiplier?: FloatFilter<"tournamentgame"> | number
    tournamentId?: StringFilter<"tournamentgame"> | string
    gameId?: StringFilter<"tournamentgame"> | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    tournament?: XOR<TournamentScalarRelationFilter, tournamentWhereInput>
  }

  export type tournamentgameOrderByWithRelationInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
    game?: GameOrderByWithRelationInput
    tournament?: tournamentOrderByWithRelationInput
  }

  export type tournamentgameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tournamentId_gameId?: tournamentgameTournamentIdGameIdCompoundUniqueInput
    AND?: tournamentgameWhereInput | tournamentgameWhereInput[]
    OR?: tournamentgameWhereInput[]
    NOT?: tournamentgameWhereInput | tournamentgameWhereInput[]
    multiplier?: FloatFilter<"tournamentgame"> | number
    tournamentId?: StringFilter<"tournamentgame"> | string
    gameId?: StringFilter<"tournamentgame"> | string
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    tournament?: XOR<TournamentScalarRelationFilter, tournamentWhereInput>
  }, "id" | "tournamentId_gameId">

  export type tournamentgameOrderByWithAggregationInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
    _count?: tournamentgameCountOrderByAggregateInput
    _avg?: tournamentgameAvgOrderByAggregateInput
    _max?: tournamentgameMaxOrderByAggregateInput
    _min?: tournamentgameMinOrderByAggregateInput
    _sum?: tournamentgameSumOrderByAggregateInput
  }

  export type tournamentgameScalarWhereWithAggregatesInput = {
    AND?: tournamentgameScalarWhereWithAggregatesInput | tournamentgameScalarWhereWithAggregatesInput[]
    OR?: tournamentgameScalarWhereWithAggregatesInput[]
    NOT?: tournamentgameScalarWhereWithAggregatesInput | tournamentgameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournamentgame"> | string
    multiplier?: FloatWithAggregatesFilter<"tournamentgame"> | number
    tournamentId?: StringWithAggregatesFilter<"tournamentgame"> | string
    gameId?: StringWithAggregatesFilter<"tournamentgame"> | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    reference?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    isRealMoney?: BoolFilter<"Transaction"> | boolean
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"Transaction"> | string | null
    profileId?: StringFilter<"Transaction"> | string
    gamesession?: XOR<GamesessionNullableScalarRelationFilter, gamesessionWhereInput> | null
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    Product?: ProductListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    profileId?: SortOrder
    gamesession?: gamesessionOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    Product?: ProductOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    reference?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    isRealMoney?: BoolFilter<"Transaction"> | boolean
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"Transaction"> | string | null
    profileId?: StringFilter<"Transaction"> | string
    gamesession?: XOR<GamesessionNullableScalarRelationFilter, gamesessionWhereInput> | null
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    Product?: ProductListRelationFilter
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    profileId?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntWithAggregatesFilter<"Transaction"> | number
    reference?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableWithAggregatesFilter<"Transaction">
    isRealMoney?: BoolWithAggregatesFilter<"Transaction"> | boolean
    paymentMethod?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentDetails?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    gameSessionId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    profileId?: StringWithAggregatesFilter<"Transaction"> | string
  }

  export type userachievementWhereInput = {
    AND?: userachievementWhereInput | userachievementWhereInput[]
    OR?: userachievementWhereInput[]
    NOT?: userachievementWhereInput | userachievementWhereInput[]
    id?: StringFilter<"userachievement"> | string
    progress?: IntFilter<"userachievement"> | number
    isUnlocked?: BoolFilter<"userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"userachievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    userId?: StringFilter<"userachievement"> | string
    achievementId?: StringFilter<"userachievement"> | string
    achievement?: XOR<AchievementScalarRelationFilter, achievementWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type userachievementOrderByWithRelationInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    achievement?: achievementOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type userachievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: userachievementUserIdAchievementIdCompoundUniqueInput
    AND?: userachievementWhereInput | userachievementWhereInput[]
    OR?: userachievementWhereInput[]
    NOT?: userachievementWhereInput | userachievementWhereInput[]
    progress?: IntFilter<"userachievement"> | number
    isUnlocked?: BoolFilter<"userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"userachievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    userId?: StringFilter<"userachievement"> | string
    achievementId?: StringFilter<"userachievement"> | string
    achievement?: XOR<AchievementScalarRelationFilter, achievementWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_achievementId">

  export type userachievementOrderByWithAggregationInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    _count?: userachievementCountOrderByAggregateInput
    _avg?: userachievementAvgOrderByAggregateInput
    _max?: userachievementMaxOrderByAggregateInput
    _min?: userachievementMinOrderByAggregateInput
    _sum?: userachievementSumOrderByAggregateInput
  }

  export type userachievementScalarWhereWithAggregatesInput = {
    AND?: userachievementScalarWhereWithAggregatesInput | userachievementScalarWhereWithAggregatesInput[]
    OR?: userachievementScalarWhereWithAggregatesInput[]
    NOT?: userachievementScalarWhereWithAggregatesInput | userachievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"userachievement"> | string
    progress?: IntWithAggregatesFilter<"userachievement"> | number
    isUnlocked?: BoolWithAggregatesFilter<"userachievement"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"userachievement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"userachievement"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"userachievement"> | Date | string | null
    userId?: StringWithAggregatesFilter<"userachievement"> | string
    achievementId?: StringWithAggregatesFilter<"userachievement"> | string
  }

  export type RainBetWhereInput = {
    AND?: RainBetWhereInput | RainBetWhereInput[]
    OR?: RainBetWhereInput[]
    NOT?: RainBetWhereInput | RainBetWhereInput[]
    id?: StringFilter<"RainBet"> | string
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: IntFilter<"RainBet"> | number
    odds?: IntFilter<"RainBet"> | number
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RainBetOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrderInput | SortOrder
    settledAt?: SortOrderInput | SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RainBetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainBetWhereInput | RainBetWhereInput[]
    OR?: RainBetWhereInput[]
    NOT?: RainBetWhereInput | RainBetWhereInput[]
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: IntFilter<"RainBet"> | number
    odds?: IntFilter<"RainBet"> | number
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RainBetOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrderInput | SortOrder
    settledAt?: SortOrderInput | SortOrder
    _count?: RainBetCountOrderByAggregateInput
    _avg?: RainBetAvgOrderByAggregateInput
    _max?: RainBetMaxOrderByAggregateInput
    _min?: RainBetMinOrderByAggregateInput
    _sum?: RainBetSumOrderByAggregateInput
  }

  export type RainBetScalarWhereWithAggregatesInput = {
    AND?: RainBetScalarWhereWithAggregatesInput | RainBetScalarWhereWithAggregatesInput[]
    OR?: RainBetScalarWhereWithAggregatesInput[]
    NOT?: RainBetScalarWhereWithAggregatesInput | RainBetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainBet"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainBet"> | string
    userId?: StringWithAggregatesFilter<"RainBet"> | string
    betAmount?: IntWithAggregatesFilter<"RainBet"> | number
    odds?: IntWithAggregatesFilter<"RainBet"> | number
    outcome?: StringNullableWithAggregatesFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableWithAggregatesFilter<"RainBet"> | Date | string | null
  }

  export type RainHistoryWhereInput = {
    AND?: RainHistoryWhereInput | RainHistoryWhereInput[]
    OR?: RainHistoryWhereInput[]
    NOT?: RainHistoryWhereInput | RainHistoryWhereInput[]
    id?: StringFilter<"RainHistory"> | string
    userId?: StringFilter<"RainHistory"> | string
    amount?: IntFilter<"RainHistory"> | number
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
    RainBet?: RainBetListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
  }

  export type RainHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
    RainBet?: RainBetOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    RainTip?: RainTipOrderByRelationAggregateInput
    RainWinner?: RainWinnerOrderByRelationAggregateInput
  }

  export type RainHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainHistoryWhereInput | RainHistoryWhereInput[]
    OR?: RainHistoryWhereInput[]
    NOT?: RainHistoryWhereInput | RainHistoryWhereInput[]
    userId?: StringFilter<"RainHistory"> | string
    amount?: IntFilter<"RainHistory"> | number
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
    RainBet?: RainBetListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
  }, "id">

  export type RainHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
    _count?: RainHistoryCountOrderByAggregateInput
    _avg?: RainHistoryAvgOrderByAggregateInput
    _max?: RainHistoryMaxOrderByAggregateInput
    _min?: RainHistoryMinOrderByAggregateInput
    _sum?: RainHistorySumOrderByAggregateInput
  }

  export type RainHistoryScalarWhereWithAggregatesInput = {
    AND?: RainHistoryScalarWhereWithAggregatesInput | RainHistoryScalarWhereWithAggregatesInput[]
    OR?: RainHistoryScalarWhereWithAggregatesInput[]
    NOT?: RainHistoryScalarWhereWithAggregatesInput | RainHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainHistory"> | string
    userId?: StringWithAggregatesFilter<"RainHistory"> | string
    amount?: IntWithAggregatesFilter<"RainHistory"> | number
    rainType?: StringWithAggregatesFilter<"RainHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RainHistory"> | Date | string
  }

  export type RainTipWhereInput = {
    AND?: RainTipWhereInput | RainTipWhereInput[]
    OR?: RainTipWhereInput[]
    NOT?: RainTipWhereInput | RainTipWhereInput[]
    id?: StringFilter<"RainTip"> | string
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: IntFilter<"RainTip"> | number
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RainTipOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RainTipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainTipWhereInput | RainTipWhereInput[]
    OR?: RainTipWhereInput[]
    NOT?: RainTipWhereInput | RainTipWhereInput[]
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: IntFilter<"RainTip"> | number
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RainTipOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
    _count?: RainTipCountOrderByAggregateInput
    _avg?: RainTipAvgOrderByAggregateInput
    _max?: RainTipMaxOrderByAggregateInput
    _min?: RainTipMinOrderByAggregateInput
    _sum?: RainTipSumOrderByAggregateInput
  }

  export type RainTipScalarWhereWithAggregatesInput = {
    AND?: RainTipScalarWhereWithAggregatesInput | RainTipScalarWhereWithAggregatesInput[]
    OR?: RainTipScalarWhereWithAggregatesInput[]
    NOT?: RainTipScalarWhereWithAggregatesInput | RainTipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainTip"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainTip"> | string
    userId?: StringWithAggregatesFilter<"RainTip"> | string
    tipAmount?: IntWithAggregatesFilter<"RainTip"> | number
    tippedAt?: DateTimeWithAggregatesFilter<"RainTip"> | Date | string
  }

  export type RainWinnerWhereInput = {
    AND?: RainWinnerWhereInput | RainWinnerWhereInput[]
    OR?: RainWinnerWhereInput[]
    NOT?: RainWinnerWhereInput | RainWinnerWhereInput[]
    id?: StringFilter<"RainWinner"> | string
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: IntFilter<"RainWinner"> | number
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RainWinnerOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RainWinnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainWinnerWhereInput | RainWinnerWhereInput[]
    OR?: RainWinnerWhereInput[]
    NOT?: RainWinnerWhereInput | RainWinnerWhereInput[]
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: IntFilter<"RainWinner"> | number
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RainWinnerOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
    _count?: RainWinnerCountOrderByAggregateInput
    _avg?: RainWinnerAvgOrderByAggregateInput
    _max?: RainWinnerMaxOrderByAggregateInput
    _min?: RainWinnerMinOrderByAggregateInput
    _sum?: RainWinnerSumOrderByAggregateInput
  }

  export type RainWinnerScalarWhereWithAggregatesInput = {
    AND?: RainWinnerScalarWhereWithAggregatesInput | RainWinnerScalarWhereWithAggregatesInput[]
    OR?: RainWinnerScalarWhereWithAggregatesInput[]
    NOT?: RainWinnerScalarWhereWithAggregatesInput | RainWinnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainWinner"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainWinner"> | string
    userId?: StringWithAggregatesFilter<"RainWinner"> | string
    wonAmount?: IntWithAggregatesFilter<"RainWinner"> | number
    wonAt?: DateTimeWithAggregatesFilter<"RainWinner"> | Date | string
  }

  export type VipInfoWhereInput = {
    AND?: VipInfoWhereInput | VipInfoWhereInput[]
    OR?: VipInfoWhereInput[]
    NOT?: VipInfoWhereInput | VipInfoWhereInput[]
    id?: IntFilter<"VipInfo"> | number
    level?: IntFilter<"VipInfo"> | number
    deposit_exp?: IntFilter<"VipInfo"> | number
    bet_exp?: IntFilter<"VipInfo"> | number
    rank_bet_exp?: IntFilter<"VipInfo"> | number
    rank_deposit_exp?: IntFilter<"VipInfo"> | number
    rank_name?: StringFilter<"VipInfo"> | string
    icon?: StringFilter<"VipInfo"> | string
    exp_switch_type?: IntFilter<"VipInfo"> | number
    now_deposit_exp?: StringFilter<"VipInfo"> | string
    level_deposit_exp?: StringFilter<"VipInfo"> | string
    now_bet_exp?: StringFilter<"VipInfo"> | string
    level_bet_exp?: StringFilter<"VipInfo"> | string
    telegram?: StringFilter<"VipInfo"> | string
    is_protection?: BoolFilter<"VipInfo"> | boolean
    protection_deposit_exp?: StringFilter<"VipInfo"> | string
    protection_deposit_amount?: StringFilter<"VipInfo"> | string
    protection_bet_exp?: StringFilter<"VipInfo"> | string
    protection_bet_amount?: StringFilter<"VipInfo"> | string
    protection_days?: IntFilter<"VipInfo"> | number
    protection_switch?: IntFilter<"VipInfo"> | number
    cycle_award_switch?: BoolFilter<"VipInfo"> | boolean
    level_award_switch?: BoolFilter<"VipInfo"> | boolean
    signin_award_switch?: BoolFilter<"VipInfo"> | boolean
    bet_award_switch?: BoolFilter<"VipInfo"> | boolean
    withdrawal_award_switch?: BoolFilter<"VipInfo"> | boolean
    unprotection_deposit_exp?: StringFilter<"VipInfo"> | string
    unprotection_deposit_amount?: StringFilter<"VipInfo"> | string
    unprotection_bet_exp?: StringFilter<"VipInfo"> | string
    unprotection_bet_amount?: StringFilter<"VipInfo"> | string
    unprotection_days?: IntFilter<"VipInfo"> | number
    unprotection_switch?: IntFilter<"VipInfo"> | number
    main_currency?: StringFilter<"VipInfo"> | string
    can_receive_level_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_rank_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_day_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_week_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_month_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_signin_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_bet_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_withdrawal_award?: BoolFilter<"VipInfo"> | boolean
    userid?: StringFilter<"VipInfo"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VipInfoOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrder
    icon?: SortOrder
    exp_switch_type?: SortOrder
    now_deposit_exp?: SortOrder
    level_deposit_exp?: SortOrder
    now_bet_exp?: SortOrder
    level_bet_exp?: SortOrder
    telegram?: SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrder
    protection_deposit_amount?: SortOrder
    protection_bet_exp?: SortOrder
    protection_bet_amount?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrder
    unprotection_deposit_amount?: SortOrder
    unprotection_bet_exp?: SortOrder
    unprotection_bet_amount?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    main_currency?: SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VipInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userid?: string
    AND?: VipInfoWhereInput | VipInfoWhereInput[]
    OR?: VipInfoWhereInput[]
    NOT?: VipInfoWhereInput | VipInfoWhereInput[]
    level?: IntFilter<"VipInfo"> | number
    deposit_exp?: IntFilter<"VipInfo"> | number
    bet_exp?: IntFilter<"VipInfo"> | number
    rank_bet_exp?: IntFilter<"VipInfo"> | number
    rank_deposit_exp?: IntFilter<"VipInfo"> | number
    rank_name?: StringFilter<"VipInfo"> | string
    icon?: StringFilter<"VipInfo"> | string
    exp_switch_type?: IntFilter<"VipInfo"> | number
    now_deposit_exp?: StringFilter<"VipInfo"> | string
    level_deposit_exp?: StringFilter<"VipInfo"> | string
    now_bet_exp?: StringFilter<"VipInfo"> | string
    level_bet_exp?: StringFilter<"VipInfo"> | string
    telegram?: StringFilter<"VipInfo"> | string
    is_protection?: BoolFilter<"VipInfo"> | boolean
    protection_deposit_exp?: StringFilter<"VipInfo"> | string
    protection_deposit_amount?: StringFilter<"VipInfo"> | string
    protection_bet_exp?: StringFilter<"VipInfo"> | string
    protection_bet_amount?: StringFilter<"VipInfo"> | string
    protection_days?: IntFilter<"VipInfo"> | number
    protection_switch?: IntFilter<"VipInfo"> | number
    cycle_award_switch?: BoolFilter<"VipInfo"> | boolean
    level_award_switch?: BoolFilter<"VipInfo"> | boolean
    signin_award_switch?: BoolFilter<"VipInfo"> | boolean
    bet_award_switch?: BoolFilter<"VipInfo"> | boolean
    withdrawal_award_switch?: BoolFilter<"VipInfo"> | boolean
    unprotection_deposit_exp?: StringFilter<"VipInfo"> | string
    unprotection_deposit_amount?: StringFilter<"VipInfo"> | string
    unprotection_bet_exp?: StringFilter<"VipInfo"> | string
    unprotection_bet_amount?: StringFilter<"VipInfo"> | string
    unprotection_days?: IntFilter<"VipInfo"> | number
    unprotection_switch?: IntFilter<"VipInfo"> | number
    main_currency?: StringFilter<"VipInfo"> | string
    can_receive_level_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_rank_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_day_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_week_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_month_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_signin_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_bet_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_withdrawal_award?: BoolFilter<"VipInfo"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userid">

  export type VipInfoOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrder
    icon?: SortOrder
    exp_switch_type?: SortOrder
    now_deposit_exp?: SortOrder
    level_deposit_exp?: SortOrder
    now_bet_exp?: SortOrder
    level_bet_exp?: SortOrder
    telegram?: SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrder
    protection_deposit_amount?: SortOrder
    protection_bet_exp?: SortOrder
    protection_bet_amount?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrder
    unprotection_deposit_amount?: SortOrder
    unprotection_bet_exp?: SortOrder
    unprotection_bet_amount?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    main_currency?: SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrder
    _count?: VipInfoCountOrderByAggregateInput
    _avg?: VipInfoAvgOrderByAggregateInput
    _max?: VipInfoMaxOrderByAggregateInput
    _min?: VipInfoMinOrderByAggregateInput
    _sum?: VipInfoSumOrderByAggregateInput
  }

  export type VipInfoScalarWhereWithAggregatesInput = {
    AND?: VipInfoScalarWhereWithAggregatesInput | VipInfoScalarWhereWithAggregatesInput[]
    OR?: VipInfoScalarWhereWithAggregatesInput[]
    NOT?: VipInfoScalarWhereWithAggregatesInput | VipInfoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VipInfo"> | number
    level?: IntWithAggregatesFilter<"VipInfo"> | number
    deposit_exp?: IntWithAggregatesFilter<"VipInfo"> | number
    bet_exp?: IntWithAggregatesFilter<"VipInfo"> | number
    rank_bet_exp?: IntWithAggregatesFilter<"VipInfo"> | number
    rank_deposit_exp?: IntWithAggregatesFilter<"VipInfo"> | number
    rank_name?: StringWithAggregatesFilter<"VipInfo"> | string
    icon?: StringWithAggregatesFilter<"VipInfo"> | string
    exp_switch_type?: IntWithAggregatesFilter<"VipInfo"> | number
    now_deposit_exp?: StringWithAggregatesFilter<"VipInfo"> | string
    level_deposit_exp?: StringWithAggregatesFilter<"VipInfo"> | string
    now_bet_exp?: StringWithAggregatesFilter<"VipInfo"> | string
    level_bet_exp?: StringWithAggregatesFilter<"VipInfo"> | string
    telegram?: StringWithAggregatesFilter<"VipInfo"> | string
    is_protection?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    protection_deposit_exp?: StringWithAggregatesFilter<"VipInfo"> | string
    protection_deposit_amount?: StringWithAggregatesFilter<"VipInfo"> | string
    protection_bet_exp?: StringWithAggregatesFilter<"VipInfo"> | string
    protection_bet_amount?: StringWithAggregatesFilter<"VipInfo"> | string
    protection_days?: IntWithAggregatesFilter<"VipInfo"> | number
    protection_switch?: IntWithAggregatesFilter<"VipInfo"> | number
    cycle_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    level_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    signin_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    bet_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    withdrawal_award_switch?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    unprotection_deposit_exp?: StringWithAggregatesFilter<"VipInfo"> | string
    unprotection_deposit_amount?: StringWithAggregatesFilter<"VipInfo"> | string
    unprotection_bet_exp?: StringWithAggregatesFilter<"VipInfo"> | string
    unprotection_bet_amount?: StringWithAggregatesFilter<"VipInfo"> | string
    unprotection_days?: IntWithAggregatesFilter<"VipInfo"> | number
    unprotection_switch?: IntWithAggregatesFilter<"VipInfo"> | number
    main_currency?: StringWithAggregatesFilter<"VipInfo"> | string
    can_receive_level_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_rank_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_day_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_week_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_month_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_signin_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_bet_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    can_receive_withdrawal_award?: BoolWithAggregatesFilter<"VipInfo"> | boolean
    userid?: StringWithAggregatesFilter<"VipInfo"> | string
  }

  export type achievementCreateInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userachievement?: userachievementCreateNestedManyWithoutAchievementInput
  }

  export type achievementUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userachievement?: userachievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type achievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userachievement?: userachievementUpdateManyWithoutAchievementNestedInput
  }

  export type achievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userachievement?: userachievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type achievementCreateManyInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type achievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type achievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperatorCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentCreateNestedManyWithoutOperatorInput
    Product?: ProductCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    ownerId: string
    balance?: number
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
    Product?: ProductUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUpdateManyWithoutOperatorNestedInput
    Product?: ProductUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorCreateManyInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    ownerId: string
    balance?: number
  }

  export type OperatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
  }

  export type OperatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    operator: OperatorCreateNestedOneWithoutProfilesInput
    user_profile_userIdTouser: UserCreateNestedOneWithoutActiveProfileInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    user_profile_userIdTouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type GameCreateInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    operator?: OperatorCreateNestedOneWithoutGamesInput
    gamesession?: gamesessionCreateNestedManyWithoutGameInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    operatorId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutGameInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    operator?: OperatorUpdateOneWithoutGamesNestedInput
    gamesession?: gamesessionUpdateManyWithoutGameNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: gamesessionUncheckedUpdateManyWithoutGameNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    operatorId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type operatorgameCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: number | null
    maxBet?: number | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
  }

  export type operatorgameUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: number | null
    maxBet?: number | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
  }

  export type operatorgameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableIntFieldUpdateOperationsInput | number | null
    maxBet?: NullableIntFieldUpdateOperationsInput | number | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type operatorgameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableIntFieldUpdateOperationsInput | number | null
    maxBet?: NullableIntFieldUpdateOperationsInput | number | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type operatorgameCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: number | null
    maxBet?: number | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
  }

  export type operatorgameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableIntFieldUpdateOperationsInput | number | null
    maxBet?: NullableIntFieldUpdateOperationsInput | number | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type operatorgameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableIntFieldUpdateOperationsInput | number | null
    maxBet?: NullableIntFieldUpdateOperationsInput | number | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MemberCreateInput = {
    id?: string
    role: string
    createdAt: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateInput = {
    id?: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date | string
  }

  export type MemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateManyInput = {
    id?: string
    organizationId: string
    userId: string
    role: string
    createdAt: Date | string
  }

  export type MemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
    user: UserCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
    user?: UserUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type InvitationCreateManyInput = {
    id?: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorCreateInput = {
    id?: string
    secret: string
    backupCodes: string
    user: UserCreateNestedOneWithoutTwofactorsInput
  }

  export type TwoFactorUncheckedCreateInput = {
    id?: string
    secret: string
    backupCodes: string
    userId: string
  }

  export type TwoFactorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutTwofactorsNestedInput
  }

  export type TwoFactorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorCreateManyInput = {
    id?: string
    secret: string
    backupCodes: string
    userId: string
  }

  export type TwoFactorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type chatmessageCreateInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatroom?: chatroomCreateNestedOneWithoutChatmessageInput
    user: UserCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
    roomId?: string | null
  }

  export type chatmessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom?: chatroomUpdateOneWithoutChatmessageNestedInput
    user?: UserUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatmessageCreateManyInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
    roomId?: string | null
  }

  export type chatmessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatroomCreateInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: chatmessageCreateNestedManyWithoutChatroomInput
    gamesession?: gamesessionCreateNestedOneWithoutChatroomInput
  }

  export type chatroomUncheckedCreateInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type chatroomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: chatmessageUpdateManyWithoutChatroomNestedInput
    gamesession?: gamesessionUpdateOneWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: chatmessageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomCreateManyInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
  }

  export type chatroomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatroomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type friendshipCreateInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user_friendship_friendIdTouser: UserCreateNestedOneWithoutFriendship_friendship_friendIdTouserInput
    user_friendship_userIdTouser: UserCreateNestedOneWithoutFriendship_friendship_userIdTouserInput
  }

  export type friendshipUncheckedCreateInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
    friendId: string
  }

  export type friendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_friendship_friendIdTouser?: UserUpdateOneRequiredWithoutFriendship_friendship_friendIdTouserNestedInput
    user_friendship_userIdTouser?: UserUpdateOneRequiredWithoutFriendship_friendship_userIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type friendshipCreateManyInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
    friendId: string
  }

  export type friendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type friendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type gamesessionCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionCreateManyInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
  }

  export type gamesessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type gamesessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    title: string
    description: string
    url: string
    type: string
    bonusCode?: string | null
    bonusTotalInCredits?: number | null
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number | null
    isPromo?: boolean | null
    totalDiscountInCents: number
    createdAt?: Date | string
    updatedAt?: Date | string
    operator?: OperatorCreateNestedOneWithoutProductInput
    transactions?: TransactionCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    url: string
    type: string
    bonusCode?: string | null
    bonusTotalInCredits?: number | null
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number | null
    isPromo?: boolean | null
    totalDiscountInCents: number
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operator?: OperatorUpdateOneWithoutProductNestedInput
    transactions?: TransactionUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    title: string
    description: string
    url: string
    type: string
    bonusCode?: string | null
    bonusTotalInCredits?: number | null
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number | null
    isPromo?: boolean | null
    totalDiscountInCents: number
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type notificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type notificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type notificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentCreateInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionCreateNestedManyWithoutTournamentInput
    operator: OperatorCreateNestedOneWithoutTournamentsInput
    tournamententry?: tournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUpdateManyWithoutTournamentNestedInput
    operator?: OperatorUpdateOneRequiredWithoutTournamentsNestedInput
    tournamententry?: tournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tournamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tournamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tournamententryCreateInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTournamententryInput
    tournament: tournamentCreateNestedOneWithoutTournamententryInput
    user: UserCreateNestedOneWithoutTournamententryInput
  }

  export type tournamententryUncheckedCreateInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    tournamentId: string
    profileId: string
  }

  export type tournamententryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTournamententryNestedInput
    tournament?: tournamentUpdateOneRequiredWithoutTournamententryNestedInput
    user?: UserUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type tournamententryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryCreateManyInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    tournamentId: string
    profileId: string
  }

  export type tournamententryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamententryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameCreateInput = {
    id?: string
    multiplier?: number
    game: GameCreateNestedOneWithoutTournamentgameInput
    tournament: tournamentCreateNestedOneWithoutTournamentgameInput
  }

  export type tournamentgameUncheckedCreateInput = {
    id?: string
    multiplier?: number
    tournamentId: string
    gameId: string
  }

  export type tournamentgameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutTournamentgameNestedInput
    tournament?: tournamentUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type tournamentgameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameCreateManyInput = {
    id?: string
    multiplier?: number
    tournamentId: string
    gameId: string
  }

  export type tournamentgameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type tournamentgameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gamesession?: gamesessionCreateNestedOneWithoutTransactionInput
    profile: ProfileCreateNestedOneWithoutTransactionsInput
    Product?: ProductCreateNestedManyWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId: string
    Product?: ProductUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesession?: gamesessionUpdateOneWithoutTransactionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutTransactionsNestedInput
    Product?: ProductUpdateManyWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
    Product?: ProductUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId: string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementCreateInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    achievement: achievementCreateNestedOneWithoutUserachievementInput
    user: UserCreateNestedOneWithoutUserachievementInput
  }

  export type userachievementUncheckedCreateInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
    achievementId: string
  }

  export type userachievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievement?: achievementUpdateOneRequiredWithoutUserachievementNestedInput
    user?: UserUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type userachievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementCreateManyInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
    achievementId: string
  }

  export type userachievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userachievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type RainBetCreateInput = {
    id?: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
    RainHistory: RainHistoryCreateNestedOneWithoutRainBetInput
    user: UserCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateInput = {
    id?: string
    rainHistoryId: string
    userId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainBetNestedInput
    user?: UserUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetCreateManyInput = {
    id?: string
    rainHistoryId: string
    userId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainHistoryCreateInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: UserCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryCreateManyInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
  }

  export type RainHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipCreateInput = {
    id?: string
    tipAmount: number
    tippedAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainTipInput
    user: UserCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateInput = {
    id?: string
    rainHistoryId: string
    userId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainTipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainTipNestedInput
    user?: UserUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipCreateManyInput = {
    id?: string
    rainHistoryId: string
    userId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainTipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerCreateInput = {
    id?: string
    wonAmount: number
    wonAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainWinnerInput
    user: UserCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateInput = {
    id?: string
    rainHistoryId: string
    userId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainWinnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput
    user?: UserUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerCreateManyInput = {
    id?: string
    rainHistoryId: string
    userId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainWinnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VipInfoCreateInput = {
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: string
    icon: string
    exp_switch_type: number
    now_deposit_exp: string
    level_deposit_exp: string
    now_bet_exp: string
    level_bet_exp: string
    telegram: string
    is_protection?: boolean
    protection_deposit_exp: string
    protection_deposit_amount: string
    protection_bet_exp: string
    protection_bet_amount: string
    protection_days: number
    protection_switch: number
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp: string
    unprotection_deposit_amount: string
    unprotection_bet_exp: string
    unprotection_bet_amount: string
    unprotection_days: number
    unprotection_switch: number
    main_currency: string
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    user: UserCreateNestedOneWithoutVipInfoInput
  }

  export type VipInfoUncheckedCreateInput = {
    id?: number
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: string
    icon: string
    exp_switch_type: number
    now_deposit_exp: string
    level_deposit_exp: string
    now_bet_exp: string
    level_bet_exp: string
    telegram: string
    is_protection?: boolean
    protection_deposit_exp: string
    protection_deposit_amount: string
    protection_bet_exp: string
    protection_bet_amount: string
    protection_days: number
    protection_switch: number
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp: string
    unprotection_deposit_amount: string
    unprotection_bet_exp: string
    unprotection_bet_amount: string
    unprotection_days: number
    unprotection_switch: number
    main_currency: string
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid: string
  }

  export type VipInfoUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    exp_switch_type?: IntFieldUpdateOperationsInput | number
    now_deposit_exp?: StringFieldUpdateOperationsInput | string
    level_deposit_exp?: StringFieldUpdateOperationsInput | string
    now_bet_exp?: StringFieldUpdateOperationsInput | string
    level_bet_exp?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: StringFieldUpdateOperationsInput | string
    protection_deposit_amount?: StringFieldUpdateOperationsInput | string
    protection_bet_exp?: StringFieldUpdateOperationsInput | string
    protection_bet_amount?: StringFieldUpdateOperationsInput | string
    protection_days?: IntFieldUpdateOperationsInput | number
    protection_switch?: IntFieldUpdateOperationsInput | number
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: StringFieldUpdateOperationsInput | string
    unprotection_deposit_amount?: StringFieldUpdateOperationsInput | string
    unprotection_bet_exp?: StringFieldUpdateOperationsInput | string
    unprotection_bet_amount?: StringFieldUpdateOperationsInput | string
    unprotection_days?: IntFieldUpdateOperationsInput | number
    unprotection_switch?: IntFieldUpdateOperationsInput | number
    main_currency?: StringFieldUpdateOperationsInput | string
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutVipInfoNestedInput
  }

  export type VipInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    exp_switch_type?: IntFieldUpdateOperationsInput | number
    now_deposit_exp?: StringFieldUpdateOperationsInput | string
    level_deposit_exp?: StringFieldUpdateOperationsInput | string
    now_bet_exp?: StringFieldUpdateOperationsInput | string
    level_bet_exp?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: StringFieldUpdateOperationsInput | string
    protection_deposit_amount?: StringFieldUpdateOperationsInput | string
    protection_bet_exp?: StringFieldUpdateOperationsInput | string
    protection_bet_amount?: StringFieldUpdateOperationsInput | string
    protection_days?: IntFieldUpdateOperationsInput | number
    protection_switch?: IntFieldUpdateOperationsInput | number
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: StringFieldUpdateOperationsInput | string
    unprotection_deposit_amount?: StringFieldUpdateOperationsInput | string
    unprotection_bet_exp?: StringFieldUpdateOperationsInput | string
    unprotection_bet_amount?: StringFieldUpdateOperationsInput | string
    unprotection_days?: IntFieldUpdateOperationsInput | number
    unprotection_switch?: IntFieldUpdateOperationsInput | number
    main_currency?: StringFieldUpdateOperationsInput | string
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    userid?: StringFieldUpdateOperationsInput | string
  }

  export type VipInfoCreateManyInput = {
    id?: number
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: string
    icon: string
    exp_switch_type: number
    now_deposit_exp: string
    level_deposit_exp: string
    now_bet_exp: string
    level_bet_exp: string
    telegram: string
    is_protection?: boolean
    protection_deposit_exp: string
    protection_deposit_amount: string
    protection_bet_exp: string
    protection_bet_amount: string
    protection_days: number
    protection_switch: number
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp: string
    unprotection_deposit_amount: string
    unprotection_bet_exp: string
    unprotection_bet_amount: string
    unprotection_days: number
    unprotection_switch: number
    main_currency: string
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
    userid: string
  }

  export type VipInfoUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    exp_switch_type?: IntFieldUpdateOperationsInput | number
    now_deposit_exp?: StringFieldUpdateOperationsInput | string
    level_deposit_exp?: StringFieldUpdateOperationsInput | string
    now_bet_exp?: StringFieldUpdateOperationsInput | string
    level_bet_exp?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: StringFieldUpdateOperationsInput | string
    protection_deposit_amount?: StringFieldUpdateOperationsInput | string
    protection_bet_exp?: StringFieldUpdateOperationsInput | string
    protection_bet_amount?: StringFieldUpdateOperationsInput | string
    protection_days?: IntFieldUpdateOperationsInput | number
    protection_switch?: IntFieldUpdateOperationsInput | number
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: StringFieldUpdateOperationsInput | string
    unprotection_deposit_amount?: StringFieldUpdateOperationsInput | string
    unprotection_bet_exp?: StringFieldUpdateOperationsInput | string
    unprotection_bet_amount?: StringFieldUpdateOperationsInput | string
    unprotection_days?: IntFieldUpdateOperationsInput | number
    unprotection_switch?: IntFieldUpdateOperationsInput | number
    main_currency?: StringFieldUpdateOperationsInput | string
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VipInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    exp_switch_type?: IntFieldUpdateOperationsInput | number
    now_deposit_exp?: StringFieldUpdateOperationsInput | string
    level_deposit_exp?: StringFieldUpdateOperationsInput | string
    now_bet_exp?: StringFieldUpdateOperationsInput | string
    level_bet_exp?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: StringFieldUpdateOperationsInput | string
    protection_deposit_amount?: StringFieldUpdateOperationsInput | string
    protection_bet_exp?: StringFieldUpdateOperationsInput | string
    protection_bet_amount?: StringFieldUpdateOperationsInput | string
    protection_days?: IntFieldUpdateOperationsInput | number
    protection_switch?: IntFieldUpdateOperationsInput | number
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: StringFieldUpdateOperationsInput | string
    unprotection_deposit_amount?: StringFieldUpdateOperationsInput | string
    unprotection_bet_exp?: StringFieldUpdateOperationsInput | string
    unprotection_bet_amount?: StringFieldUpdateOperationsInput | string
    unprotection_days?: IntFieldUpdateOperationsInput | number
    unprotection_switch?: IntFieldUpdateOperationsInput | number
    main_currency?: StringFieldUpdateOperationsInput | string
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
    userid?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserachievementListRelationFilter = {
    every?: userachievementWhereInput
    some?: userachievementWhereInput
    none?: userachievementWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type userachievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type achievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type achievementAvgOrderByAggregateInput = {
    targetXp?: SortOrder
    reward?: SortOrder
  }

  export type achievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type achievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type achievementSumOrderByAggregateInput = {
    targetXp?: SortOrder
    reward?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumUserStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableFilter<$PrismaModel> | $Enums.UserStatus | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type TwoFactorListRelationFilter = {
    every?: TwoFactorWhereInput
    some?: TwoFactorWhereInput
    none?: TwoFactorWhereInput
  }

  export type RainBetListRelationFilter = {
    every?: RainBetWhereInput
    some?: RainBetWhereInput
    none?: RainBetWhereInput
  }

  export type RainHistoryListRelationFilter = {
    every?: RainHistoryWhereInput
    some?: RainHistoryWhereInput
    none?: RainHistoryWhereInput
  }

  export type RainTipListRelationFilter = {
    every?: RainTipWhereInput
    some?: RainTipWhereInput
    none?: RainTipWhereInput
  }

  export type RainWinnerListRelationFilter = {
    every?: RainWinnerWhereInput
    some?: RainWinnerWhereInput
    none?: RainWinnerWhereInput
  }

  export type ChatmessageListRelationFilter = {
    every?: chatmessageWhereInput
    some?: chatmessageWhereInput
    none?: chatmessageWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: friendshipWhereInput
    some?: friendshipWhereInput
    none?: friendshipWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type OperatorListRelationFilter = {
    every?: OperatorWhereInput
    some?: OperatorWhereInput
    none?: OperatorWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type TournamententryListRelationFilter = {
    every?: tournamententryWhereInput
    some?: tournamententryWhereInput
    none?: tournamententryWhereInput
  }

  export type VipInfoListRelationFilter = {
    every?: VipInfoWhereInput
    some?: VipInfoWhereInput
    none?: VipInfoWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwoFactorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainBetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainTipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainWinnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatmessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type friendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournamententryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VipInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserVipInfoIdIdCompoundUniqueInput = {
    vipInfoId: string
    id: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrder
    lastDailySpin?: SortOrder
    verificationToken?: SortOrder
    avatar?: SortOrder
    activeProfileId?: SortOrder
    vipInfoId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    totalXp?: SortOrder
    balance?: SortOrder
    phpId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrder
    lastDailySpin?: SortOrder
    verificationToken?: SortOrder
    avatar?: SortOrder
    activeProfileId?: SortOrder
    vipInfoId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    twoFactorEnabled?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    isVerified?: SortOrder
    active?: SortOrder
    lastLogin?: SortOrder
    lastDailySpin?: SortOrder
    verificationToken?: SortOrder
    avatar?: SortOrder
    activeProfileId?: SortOrder
    vipInfoId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    totalXp?: SortOrder
    balance?: SortOrder
    phpId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserStatusNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
    token?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type TournamentListRelationFilter = {
    every?: tournamentWhereInput
    some?: tournamentWhereInput
    none?: tournamentWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournamentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
  }

  export type OperatorAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type OperatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
  }

  export type OperatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    balance?: SortOrder
  }

  export type OperatorSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type GamesessionListRelationFilter = {
    every?: gamesessionWhereInput
    some?: gamesessionWhereInput
    none?: gamesessionWhereInput
  }

  export type OperatorScalarRelationFilter = {
    is?: OperatorWhereInput
    isNot?: OperatorWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type gamesessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileUserIdShopIdCompoundUniqueInput = {
    userId: string
    shopId: string
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    balance?: SortOrder
    xpEarned?: SortOrder
    phpId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    currency?: SortOrder
    shopId?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    balance?: SortOrder
    xpEarned?: SortOrder
    phpId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumGameCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.GameCategory | EnumGameCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGameCategoryFilter<$PrismaModel> | $Enums.GameCategory
  }

  export type OperatorNullableScalarRelationFilter = {
    is?: OperatorWhereInput | null
    isNot?: OperatorWhereInput | null
  }

  export type TournamentgameListRelationFilter = {
    every?: tournamentgameWhereInput
    some?: tournamentgameWhereInput
    none?: tournamentgameWhereInput
  }

  export type tournamentgameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrder
    developer?: SortOrder
    vipLevel?: SortOrder
    isActive?: SortOrder
    device?: SortOrder
    featured?: SortOrder
    gamebank?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    linesPercentConfigSpin?: SortOrder
    linesPercentConfigSpinBonus?: SortOrder
    linesPercentConfigBonus?: SortOrder
    linesPercentConfigBonusBonus?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    advanced?: SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrder
    categoryId?: SortOrder
    operatorId?: SortOrder
    providerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    jackpotGroupId?: SortOrder
    active?: SortOrder
    password?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    vipLevel?: SortOrder
    device?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    view?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrder
    developer?: SortOrder
    vipLevel?: SortOrder
    isActive?: SortOrder
    device?: SortOrder
    featured?: SortOrder
    gamebank?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    linesPercentConfigSpin?: SortOrder
    linesPercentConfigSpinBonus?: SortOrder
    linesPercentConfigBonus?: SortOrder
    linesPercentConfigBonusBonus?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    advanced?: SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrder
    categoryId?: SortOrder
    operatorId?: SortOrder
    providerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    jackpotGroupId?: SortOrder
    active?: SortOrder
    password?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    title?: SortOrder
    temperature?: SortOrder
    developer?: SortOrder
    vipLevel?: SortOrder
    isActive?: SortOrder
    device?: SortOrder
    featured?: SortOrder
    gamebank?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    linesPercentConfigSpin?: SortOrder
    linesPercentConfigSpinBonus?: SortOrder
    linesPercentConfigBonus?: SortOrder
    linesPercentConfigBonusBonus?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    advanced?: SortOrder
    scaleMode?: SortOrder
    slotViewState?: SortOrder
    view?: SortOrder
    categoryId?: SortOrder
    operatorId?: SortOrder
    providerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: SortOrder
    jackpotGroupId?: SortOrder
    active?: SortOrder
    password?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    vipLevel?: SortOrder
    device?: SortOrder
    bet?: SortOrder
    denomination?: SortOrder
    categoryTemp?: SortOrder
    originalId?: SortOrder
    bids?: SortOrder
    statIn?: SortOrder
    statOut?: SortOrder
    currentRtp?: SortOrder
    rtpStatIn?: SortOrder
    rtpStatOut?: SortOrder
    standardRtp?: SortOrder
    popularity?: SortOrder
    chanceFirepot1?: SortOrder
    chanceFirepot2?: SortOrder
    chanceFirepot3?: SortOrder
    fireCount1?: SortOrder
    fireCount2?: SortOrder
    fireCount3?: SortOrder
    rezerv?: SortOrder
    cask?: SortOrder
    view?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumGameCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameCategory | EnumGameCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGameCategoryWithAggregatesFilter<$PrismaModel> | $Enums.GameCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameCategoryFilter<$PrismaModel>
    _max?: NestedEnumGameCategoryFilter<$PrismaModel>
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type operatorgameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type operatorgameAvgOrderByAggregateInput = {
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
  }

  export type operatorgameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type operatorgameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type operatorgameSumOrderByAggregateInput = {
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    inviterId?: SortOrder
  }

  export type TwoFactorCountOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorMaxOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
  }

  export type TwoFactorMinOrderByAggregateInput = {
    id?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    userId?: SortOrder
  }

  export type EnumChatChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelFilter<$PrismaModel> | $Enums.ChatChannel
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ChatroomNullableScalarRelationFilter = {
    is?: chatroomWhereInput | null
    isNot?: chatroomWhereInput | null
  }

  export type chatmessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type chatmessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type chatmessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type EnumChatChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelWithAggregatesFilter<$PrismaModel> | $Enums.ChatChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatChannelFilter<$PrismaModel>
    _max?: NestedEnumChatChannelFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type GamesessionNullableScalarRelationFilter = {
    is?: gamesessionWhereInput | null
    isNot?: gamesessionWhereInput | null
  }

  export type chatroomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type chatroomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type chatroomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type EnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type friendshipUserIdFriendIdCompoundUniqueInput = {
    userId: string
    friendId: string
  }

  export type friendshipCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type friendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type friendshipMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type EnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type ChatroomListRelationFilter = {
    every?: chatroomWhereInput
    some?: chatroomWhereInput
    none?: chatroomWhereInput
  }

  export type GameScalarRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type TournamentNullableScalarRelationFilter = {
    is?: tournamentWhereInput | null
    isNot?: tournamentWhereInput | null
  }

  export type chatroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gamesessionCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
  }

  export type gamesessionAvgOrderByAggregateInput = {
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
  }

  export type gamesessionMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
  }

  export type gamesessionMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
  }

  export type gamesessionSumOrderByAggregateInput = {
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrder
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    isPromo?: SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    totalDiscountInCents?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrder
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    isPromo?: SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    type?: SortOrder
    bonusCode?: SortOrder
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    isPromo?: SortOrder
    totalDiscountInCents?: SortOrder
    shopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    bonusTotalInCredits?: SortOrder
    priceInCents?: SortOrder
    amountToReceiveInCredits?: SortOrder
    bestValue?: SortOrder
    discountInCents?: SortOrder
    bonusSpins?: SortOrder
    totalDiscountInCents?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type tournamentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrder
  }

  export type tournamentAvgOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
  }

  export type tournamentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type tournamentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type tournamentSumOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
  }

  export type TournamentScalarRelationFilter = {
    is?: tournamentWhereInput
    isNot?: tournamentWhereInput
  }

  export type tournamententryUserIdTournamentIdCompoundUniqueInput = {
    userId: string
    tournamentId: string
  }

  export type tournamententryCountOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type tournamententryAvgOrderByAggregateInput = {
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
  }

  export type tournamententryMaxOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type tournamententryMinOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type tournamententrySumOrderByAggregateInput = {
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
  }

  export type tournamentgameTournamentIdGameIdCompoundUniqueInput = {
    tournamentId: string
    gameId: string
  }

  export type tournamentgameCountOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type tournamentgameAvgOrderByAggregateInput = {
    multiplier?: SortOrder
  }

  export type tournamentgameMaxOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type tournamentgameMinOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type tournamentgameSumOrderByAggregateInput = {
    multiplier?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    paymentDetails?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type AchievementScalarRelationFilter = {
    is?: achievementWhereInput
    isNot?: achievementWhereInput
  }

  export type userachievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type userachievementCountOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type userachievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type userachievementMaxOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type userachievementMinOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type userachievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type RainHistoryScalarRelationFilter = {
    is?: RainHistoryWhereInput
    isNot?: RainHistoryWhereInput
  }

  export type RainBetCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetAvgOrderByAggregateInput = {
    betAmount?: SortOrder
    odds?: SortOrder
  }

  export type RainBetMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetSumOrderByAggregateInput = {
    betAmount?: SortOrder
    odds?: SortOrder
  }

  export type RainHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistoryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RainHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistorySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RainTipCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipAvgOrderByAggregateInput = {
    tipAmount?: SortOrder
  }

  export type RainTipMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipSumOrderByAggregateInput = {
    tipAmount?: SortOrder
  }

  export type RainWinnerCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerAvgOrderByAggregateInput = {
    wonAmount?: SortOrder
  }

  export type RainWinnerMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerSumOrderByAggregateInput = {
    wonAmount?: SortOrder
  }

  export type VipInfoCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrder
    icon?: SortOrder
    exp_switch_type?: SortOrder
    now_deposit_exp?: SortOrder
    level_deposit_exp?: SortOrder
    now_bet_exp?: SortOrder
    level_bet_exp?: SortOrder
    telegram?: SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrder
    protection_deposit_amount?: SortOrder
    protection_bet_exp?: SortOrder
    protection_bet_amount?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrder
    unprotection_deposit_amount?: SortOrder
    unprotection_bet_exp?: SortOrder
    unprotection_bet_amount?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    main_currency?: SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrder
  }

  export type VipInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    exp_switch_type?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
  }

  export type VipInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrder
    icon?: SortOrder
    exp_switch_type?: SortOrder
    now_deposit_exp?: SortOrder
    level_deposit_exp?: SortOrder
    now_bet_exp?: SortOrder
    level_bet_exp?: SortOrder
    telegram?: SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrder
    protection_deposit_amount?: SortOrder
    protection_bet_exp?: SortOrder
    protection_bet_amount?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrder
    unprotection_deposit_amount?: SortOrder
    unprotection_bet_exp?: SortOrder
    unprotection_bet_amount?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    main_currency?: SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrder
  }

  export type VipInfoMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    rank_name?: SortOrder
    icon?: SortOrder
    exp_switch_type?: SortOrder
    now_deposit_exp?: SortOrder
    level_deposit_exp?: SortOrder
    now_bet_exp?: SortOrder
    level_bet_exp?: SortOrder
    telegram?: SortOrder
    is_protection?: SortOrder
    protection_deposit_exp?: SortOrder
    protection_deposit_amount?: SortOrder
    protection_bet_exp?: SortOrder
    protection_bet_amount?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    cycle_award_switch?: SortOrder
    level_award_switch?: SortOrder
    signin_award_switch?: SortOrder
    bet_award_switch?: SortOrder
    withdrawal_award_switch?: SortOrder
    unprotection_deposit_exp?: SortOrder
    unprotection_deposit_amount?: SortOrder
    unprotection_bet_exp?: SortOrder
    unprotection_bet_amount?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
    main_currency?: SortOrder
    can_receive_level_award?: SortOrder
    can_receive_rank_award?: SortOrder
    can_receive_day_award?: SortOrder
    can_receive_week_award?: SortOrder
    can_receive_month_award?: SortOrder
    can_receive_signin_award?: SortOrder
    can_receive_bet_award?: SortOrder
    can_receive_withdrawal_award?: SortOrder
    userid?: SortOrder
  }

  export type VipInfoSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    deposit_exp?: SortOrder
    bet_exp?: SortOrder
    rank_bet_exp?: SortOrder
    rank_deposit_exp?: SortOrder
    exp_switch_type?: SortOrder
    protection_days?: SortOrder
    protection_switch?: SortOrder
    unprotection_days?: SortOrder
    unprotection_switch?: SortOrder
  }

  export type userachievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput> | userachievementCreateWithoutAchievementInput[] | userachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutAchievementInput | userachievementCreateOrConnectWithoutAchievementInput[]
    createMany?: userachievementCreateManyAchievementInputEnvelope
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
  }

  export type userachievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput> | userachievementCreateWithoutAchievementInput[] | userachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutAchievementInput | userachievementCreateOrConnectWithoutAchievementInput[]
    createMany?: userachievementCreateManyAchievementInputEnvelope
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userachievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput> | userachievementCreateWithoutAchievementInput[] | userachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutAchievementInput | userachievementCreateOrConnectWithoutAchievementInput[]
    upsert?: userachievementUpsertWithWhereUniqueWithoutAchievementInput | userachievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: userachievementCreateManyAchievementInputEnvelope
    set?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    disconnect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    delete?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    update?: userachievementUpdateWithWhereUniqueWithoutAchievementInput | userachievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: userachievementUpdateManyWithWhereWithoutAchievementInput | userachievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
  }

  export type userachievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput> | userachievementCreateWithoutAchievementInput[] | userachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutAchievementInput | userachievementCreateOrConnectWithoutAchievementInput[]
    upsert?: userachievementUpsertWithWhereUniqueWithoutAchievementInput | userachievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: userachievementCreateManyAchievementInputEnvelope
    set?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    disconnect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    delete?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    update?: userachievementUpdateWithWhereUniqueWithoutAchievementInput | userachievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: userachievementUpdateManyWithWhereWithoutAchievementInput | userachievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutUserInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type TwoFactorCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
  }

  export type RainBetCreateNestedManyWithoutUserInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
  }

  export type RainTipCreateNestedManyWithoutUserInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerCreateNestedManyWithoutUserInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type chatmessageCreateNestedManyWithoutUserInput = {
    create?: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput> | chatmessageCreateWithoutUserInput[] | chatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUserInput | chatmessageCreateOrConnectWithoutUserInput[]
    createMany?: chatmessageCreateManyUserInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput> | friendshipCreateWithoutUser_friendship_friendIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput> | friendshipCreateWithoutUser_friendship_userIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_userIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type notificationCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type OperatorCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput> | OperatorCreateWithoutOwnerInput[] | OperatorUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutOwnerInput | OperatorCreateOrConnectWithoutOwnerInput[]
    createMany?: OperatorCreateManyOwnerInputEnvelope
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput = {
    create?: XOR<ProfileCreateWithoutUser_profile_userIdTouserInput, ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput> | ProfileCreateWithoutUser_profile_userIdTouserInput[] | ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput | ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput[]
    createMany?: ProfileCreateManyUser_profile_userIdTouserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type tournamententryCreateNestedManyWithoutUserInput = {
    create?: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput> | tournamententryCreateWithoutUserInput[] | tournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutUserInput | tournamententryCreateOrConnectWithoutUserInput[]
    createMany?: tournamententryCreateManyUserInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type userachievementCreateNestedManyWithoutUserInput = {
    create?: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput> | userachievementCreateWithoutUserInput[] | userachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutUserInput | userachievementCreateOrConnectWithoutUserInput[]
    createMany?: userachievementCreateManyUserInputEnvelope
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
  }

  export type VipInfoCreateNestedManyWithoutUserInput = {
    create?: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput> | VipInfoCreateWithoutUserInput[] | VipInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VipInfoCreateOrConnectWithoutUserInput | VipInfoCreateOrConnectWithoutUserInput[]
    createMany?: VipInfoCreateManyUserInputEnvelope
    connect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type TwoFactorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
  }

  export type RainBetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
  }

  export type RainTipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type chatmessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput> | chatmessageCreateWithoutUserInput[] | chatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUserInput | chatmessageCreateOrConnectWithoutUserInput[]
    createMany?: chatmessageCreateManyUserInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput> | friendshipCreateWithoutUser_friendship_friendIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput> | friendshipCreateWithoutUser_friendship_userIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_userIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type OperatorUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput> | OperatorCreateWithoutOwnerInput[] | OperatorUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutOwnerInput | OperatorCreateOrConnectWithoutOwnerInput[]
    createMany?: OperatorCreateManyOwnerInputEnvelope
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput = {
    create?: XOR<ProfileCreateWithoutUser_profile_userIdTouserInput, ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput> | ProfileCreateWithoutUser_profile_userIdTouserInput[] | ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput | ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput[]
    createMany?: ProfileCreateManyUser_profile_userIdTouserInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type tournamententryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput> | tournamententryCreateWithoutUserInput[] | tournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutUserInput | tournamententryCreateOrConnectWithoutUserInput[]
    createMany?: tournamententryCreateManyUserInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type userachievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput> | userachievementCreateWithoutUserInput[] | userachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutUserInput | userachievementCreateOrConnectWithoutUserInput[]
    createMany?: userachievementCreateManyUserInputEnvelope
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
  }

  export type VipInfoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput> | VipInfoCreateWithoutUserInput[] | VipInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VipInfoCreateOrConnectWithoutUserInput | VipInfoCreateOrConnectWithoutUserInput[]
    createMany?: VipInfoCreateManyUserInputEnvelope
    connect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableEnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus | null
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutUserInput | InvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutUserInput | InvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutUserInput | InvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type TwoFactorUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorUpsertWithWhereUniqueWithoutUserInput | TwoFactorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    set?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    disconnect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    delete?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    update?: TwoFactorUpdateWithWhereUniqueWithoutUserInput | TwoFactorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorUpdateManyWithWhereWithoutUserInput | TwoFactorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
  }

  export type RainBetUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutUserInput | RainBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutUserInput | RainBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutUserInput | RainBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    upsert?: RainHistoryUpsertWithWhereUniqueWithoutUserInput | RainHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    set?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    disconnect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    delete?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    update?: RainHistoryUpdateWithWhereUniqueWithoutUserInput | RainHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainHistoryUpdateManyWithWhereWithoutUserInput | RainHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
  }

  export type RainTipUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutUserInput | RainTipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutUserInput | RainTipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutUserInput | RainTipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutUserInput | RainWinnerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutUserInput | RainWinnerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutUserInput | RainWinnerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type chatmessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput> | chatmessageCreateWithoutUserInput[] | chatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUserInput | chatmessageCreateOrConnectWithoutUserInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutUserInput | chatmessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chatmessageCreateManyUserInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutUserInput | chatmessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutUserInput | chatmessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput> | friendshipCreateWithoutUser_friendship_friendIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput> | friendshipCreateWithoutUser_friendship_userIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_userIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type notificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type OperatorUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput> | OperatorCreateWithoutOwnerInput[] | OperatorUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutOwnerInput | OperatorCreateOrConnectWithoutOwnerInput[]
    upsert?: OperatorUpsertWithWhereUniqueWithoutOwnerInput | OperatorUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OperatorCreateManyOwnerInputEnvelope
    set?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    disconnect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    delete?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    update?: OperatorUpdateWithWhereUniqueWithoutOwnerInput | OperatorUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OperatorUpdateManyWithWhereWithoutOwnerInput | OperatorUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput = {
    create?: XOR<ProfileCreateWithoutUser_profile_userIdTouserInput, ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput> | ProfileCreateWithoutUser_profile_userIdTouserInput[] | ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput | ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput | ProfileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput[]
    createMany?: ProfileCreateManyUser_profile_userIdTouserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput | ProfileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput | ProfileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type tournamententryUpdateManyWithoutUserNestedInput = {
    create?: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput> | tournamententryCreateWithoutUserInput[] | tournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutUserInput | tournamententryCreateOrConnectWithoutUserInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutUserInput | tournamententryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: tournamententryCreateManyUserInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutUserInput | tournamententryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutUserInput | tournamententryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type userachievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput> | userachievementCreateWithoutUserInput[] | userachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutUserInput | userachievementCreateOrConnectWithoutUserInput[]
    upsert?: userachievementUpsertWithWhereUniqueWithoutUserInput | userachievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userachievementCreateManyUserInputEnvelope
    set?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    disconnect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    delete?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    update?: userachievementUpdateWithWhereUniqueWithoutUserInput | userachievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userachievementUpdateManyWithWhereWithoutUserInput | userachievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
  }

  export type VipInfoUpdateManyWithoutUserNestedInput = {
    create?: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput> | VipInfoCreateWithoutUserInput[] | VipInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VipInfoCreateOrConnectWithoutUserInput | VipInfoCreateOrConnectWithoutUserInput[]
    upsert?: VipInfoUpsertWithWhereUniqueWithoutUserInput | VipInfoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VipInfoCreateManyUserInputEnvelope
    set?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    disconnect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    delete?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    connect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    update?: VipInfoUpdateWithWhereUniqueWithoutUserInput | VipInfoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VipInfoUpdateManyWithWhereWithoutUserInput | VipInfoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VipInfoScalarWhereInput | VipInfoScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput> | InvitationCreateWithoutUserInput[] | InvitationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutUserInput | InvitationCreateOrConnectWithoutUserInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutUserInput | InvitationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvitationCreateManyUserInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutUserInput | InvitationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutUserInput | InvitationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type TwoFactorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorUpsertWithWhereUniqueWithoutUserInput | TwoFactorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    set?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    disconnect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    delete?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    update?: TwoFactorUpdateWithWhereUniqueWithoutUserInput | TwoFactorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorUpdateManyWithWhereWithoutUserInput | TwoFactorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
  }

  export type RainBetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutUserInput | RainBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutUserInput | RainBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutUserInput | RainBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    upsert?: RainHistoryUpsertWithWhereUniqueWithoutUserInput | RainHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    set?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    disconnect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    delete?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    update?: RainHistoryUpdateWithWhereUniqueWithoutUserInput | RainHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainHistoryUpdateManyWithWhereWithoutUserInput | RainHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
  }

  export type RainTipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutUserInput | RainTipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutUserInput | RainTipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutUserInput | RainTipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutUserInput | RainWinnerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutUserInput | RainWinnerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutUserInput | RainWinnerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type chatmessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput> | chatmessageCreateWithoutUserInput[] | chatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUserInput | chatmessageCreateOrConnectWithoutUserInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutUserInput | chatmessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chatmessageCreateManyUserInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutUserInput | chatmessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutUserInput | chatmessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput> | friendshipCreateWithoutUser_friendship_friendIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput> | friendshipCreateWithoutUser_friendship_userIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_userIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type OperatorUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput> | OperatorCreateWithoutOwnerInput[] | OperatorUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OperatorCreateOrConnectWithoutOwnerInput | OperatorCreateOrConnectWithoutOwnerInput[]
    upsert?: OperatorUpsertWithWhereUniqueWithoutOwnerInput | OperatorUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OperatorCreateManyOwnerInputEnvelope
    set?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    disconnect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    delete?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    connect?: OperatorWhereUniqueInput | OperatorWhereUniqueInput[]
    update?: OperatorUpdateWithWhereUniqueWithoutOwnerInput | OperatorUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OperatorUpdateManyWithWhereWithoutOwnerInput | OperatorUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput = {
    create?: XOR<ProfileCreateWithoutUser_profile_userIdTouserInput, ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput> | ProfileCreateWithoutUser_profile_userIdTouserInput[] | ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput | ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput | ProfileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput[]
    createMany?: ProfileCreateManyUser_profile_userIdTouserInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput | ProfileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput | ProfileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type tournamententryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput> | tournamententryCreateWithoutUserInput[] | tournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutUserInput | tournamententryCreateOrConnectWithoutUserInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutUserInput | tournamententryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: tournamententryCreateManyUserInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutUserInput | tournamententryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutUserInput | tournamententryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type userachievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput> | userachievementCreateWithoutUserInput[] | userachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutUserInput | userachievementCreateOrConnectWithoutUserInput[]
    upsert?: userachievementUpsertWithWhereUniqueWithoutUserInput | userachievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userachievementCreateManyUserInputEnvelope
    set?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    disconnect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    delete?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    update?: userachievementUpdateWithWhereUniqueWithoutUserInput | userachievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userachievementUpdateManyWithWhereWithoutUserInput | userachievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
  }

  export type VipInfoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput> | VipInfoCreateWithoutUserInput[] | VipInfoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VipInfoCreateOrConnectWithoutUserInput | VipInfoCreateOrConnectWithoutUserInput[]
    upsert?: VipInfoUpsertWithWhereUniqueWithoutUserInput | VipInfoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VipInfoCreateManyUserInputEnvelope
    set?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    disconnect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    delete?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    connect?: VipInfoWhereUniqueInput | VipInfoWhereUniqueInput[]
    update?: VipInfoUpdateWithWhereUniqueWithoutUserInput | VipInfoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VipInfoUpdateManyWithWhereWithoutUserInput | VipInfoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VipInfoScalarWhereInput | VipInfoScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutOperatorInput = {
    create?: XOR<UserCreateWithoutOperatorInput, UserUncheckedCreateWithoutOperatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutOperatorInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedManyWithoutOperatorInput = {
    create?: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput> | GameCreateWithoutOperatorInput[] | GameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: GameCreateOrConnectWithoutOperatorInput | GameCreateOrConnectWithoutOperatorInput[]
    createMany?: GameCreateManyOperatorInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput> | ProfileCreateWithoutOperatorInput[] | ProfileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutOperatorInput | ProfileCreateOrConnectWithoutOperatorInput[]
    createMany?: ProfileCreateManyOperatorInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type tournamentCreateNestedManyWithoutOperatorInput = {
    create?: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput> | tournamentCreateWithoutOperatorInput[] | tournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: tournamentCreateOrConnectWithoutOperatorInput | tournamentCreateOrConnectWithoutOperatorInput[]
    createMany?: tournamentCreateManyOperatorInputEnvelope
    connect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput> | ProductCreateWithoutOperatorInput[] | ProductUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOperatorInput | ProductCreateOrConnectWithoutOperatorInput[]
    createMany?: ProductCreateManyOperatorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput> | GameCreateWithoutOperatorInput[] | GameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: GameCreateOrConnectWithoutOperatorInput | GameCreateOrConnectWithoutOperatorInput[]
    createMany?: GameCreateManyOperatorInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput> | ProfileCreateWithoutOperatorInput[] | ProfileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutOperatorInput | ProfileCreateOrConnectWithoutOperatorInput[]
    createMany?: ProfileCreateManyOperatorInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type tournamentUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput> | tournamentCreateWithoutOperatorInput[] | tournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: tournamentCreateOrConnectWithoutOperatorInput | tournamentCreateOrConnectWithoutOperatorInput[]
    createMany?: tournamentCreateManyOperatorInputEnvelope
    connect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput> | ProductCreateWithoutOperatorInput[] | ProductUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOperatorInput | ProductCreateOrConnectWithoutOperatorInput[]
    createMany?: ProductCreateManyOperatorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOperatorNestedInput = {
    create?: XOR<UserCreateWithoutOperatorInput, UserUncheckedCreateWithoutOperatorInput>
    connectOrCreate?: UserCreateOrConnectWithoutOperatorInput
    upsert?: UserUpsertWithoutOperatorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOperatorInput, UserUpdateWithoutOperatorInput>, UserUncheckedUpdateWithoutOperatorInput>
  }

  export type GameUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput> | GameCreateWithoutOperatorInput[] | GameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: GameCreateOrConnectWithoutOperatorInput | GameCreateOrConnectWithoutOperatorInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutOperatorInput | GameUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: GameCreateManyOperatorInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutOperatorInput | GameUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: GameUpdateManyWithWhereWithoutOperatorInput | GameUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput> | ProfileCreateWithoutOperatorInput[] | ProfileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutOperatorInput | ProfileCreateOrConnectWithoutOperatorInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutOperatorInput | ProfileUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ProfileCreateManyOperatorInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutOperatorInput | ProfileUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutOperatorInput | ProfileUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type tournamentUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput> | tournamentCreateWithoutOperatorInput[] | tournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: tournamentCreateOrConnectWithoutOperatorInput | tournamentCreateOrConnectWithoutOperatorInput[]
    upsert?: tournamentUpsertWithWhereUniqueWithoutOperatorInput | tournamentUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: tournamentCreateManyOperatorInputEnvelope
    set?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    disconnect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    delete?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    connect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    update?: tournamentUpdateWithWhereUniqueWithoutOperatorInput | tournamentUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: tournamentUpdateManyWithWhereWithoutOperatorInput | tournamentUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: tournamentScalarWhereInput | tournamentScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput> | ProductCreateWithoutOperatorInput[] | ProductUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOperatorInput | ProductCreateOrConnectWithoutOperatorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOperatorInput | ProductUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ProductCreateManyOperatorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOperatorInput | ProductUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOperatorInput | ProductUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput> | GameCreateWithoutOperatorInput[] | GameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: GameCreateOrConnectWithoutOperatorInput | GameCreateOrConnectWithoutOperatorInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutOperatorInput | GameUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: GameCreateManyOperatorInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutOperatorInput | GameUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: GameUpdateManyWithWhereWithoutOperatorInput | GameUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput> | ProfileCreateWithoutOperatorInput[] | ProfileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutOperatorInput | ProfileCreateOrConnectWithoutOperatorInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutOperatorInput | ProfileUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ProfileCreateManyOperatorInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutOperatorInput | ProfileUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutOperatorInput | ProfileUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type tournamentUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput> | tournamentCreateWithoutOperatorInput[] | tournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: tournamentCreateOrConnectWithoutOperatorInput | tournamentCreateOrConnectWithoutOperatorInput[]
    upsert?: tournamentUpsertWithWhereUniqueWithoutOperatorInput | tournamentUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: tournamentCreateManyOperatorInputEnvelope
    set?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    disconnect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    delete?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    connect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    update?: tournamentUpdateWithWhereUniqueWithoutOperatorInput | tournamentUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: tournamentUpdateManyWithWhereWithoutOperatorInput | tournamentUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: tournamentScalarWhereInput | tournamentScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput> | ProductCreateWithoutOperatorInput[] | ProductUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutOperatorInput | ProductCreateOrConnectWithoutOperatorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutOperatorInput | ProductUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: ProductCreateManyOperatorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutOperatorInput | ProductUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutOperatorInput | ProductUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type gamesessionCreateNestedManyWithoutProfileInput = {
    create?: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput> | gamesessionCreateWithoutProfileInput[] | gamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutProfileInput | gamesessionCreateOrConnectWithoutProfileInput[]
    createMany?: gamesessionCreateManyProfileInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type OperatorCreateNestedOneWithoutProfilesInput = {
    create?: XOR<OperatorCreateWithoutProfilesInput, OperatorUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutProfilesInput
    connect?: OperatorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActiveProfileInput = {
    create?: XOR<UserCreateWithoutActiveProfileInput, UserUncheckedCreateWithoutActiveProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutActiveProfileInput
    connect?: UserWhereUniqueInput
  }

  export type tournamententryCreateNestedManyWithoutProfileInput = {
    create?: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput> | tournamententryCreateWithoutProfileInput[] | tournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutProfileInput | tournamententryCreateOrConnectWithoutProfileInput[]
    createMany?: tournamententryCreateManyProfileInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput> | TransactionCreateWithoutProfileInput[] | TransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProfileInput | TransactionCreateOrConnectWithoutProfileInput[]
    createMany?: TransactionCreateManyProfileInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type gamesessionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput> | gamesessionCreateWithoutProfileInput[] | gamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutProfileInput | gamesessionCreateOrConnectWithoutProfileInput[]
    createMany?: gamesessionCreateManyProfileInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type tournamententryUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput> | tournamententryCreateWithoutProfileInput[] | tournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutProfileInput | tournamententryCreateOrConnectWithoutProfileInput[]
    createMany?: tournamententryCreateManyProfileInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput> | TransactionCreateWithoutProfileInput[] | TransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProfileInput | TransactionCreateOrConnectWithoutProfileInput[]
    createMany?: TransactionCreateManyProfileInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type gamesessionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput> | gamesessionCreateWithoutProfileInput[] | gamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutProfileInput | gamesessionCreateOrConnectWithoutProfileInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutProfileInput | gamesessionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: gamesessionCreateManyProfileInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutProfileInput | gamesessionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutProfileInput | gamesessionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type OperatorUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<OperatorCreateWithoutProfilesInput, OperatorUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutProfilesInput
    upsert?: OperatorUpsertWithoutProfilesInput
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutProfilesInput, OperatorUpdateWithoutProfilesInput>, OperatorUncheckedUpdateWithoutProfilesInput>
  }

  export type UserUpdateOneRequiredWithoutActiveProfileNestedInput = {
    create?: XOR<UserCreateWithoutActiveProfileInput, UserUncheckedCreateWithoutActiveProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutActiveProfileInput
    upsert?: UserUpsertWithoutActiveProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActiveProfileInput, UserUpdateWithoutActiveProfileInput>, UserUncheckedUpdateWithoutActiveProfileInput>
  }

  export type tournamententryUpdateManyWithoutProfileNestedInput = {
    create?: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput> | tournamententryCreateWithoutProfileInput[] | tournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutProfileInput | tournamententryCreateOrConnectWithoutProfileInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutProfileInput | tournamententryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: tournamententryCreateManyProfileInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutProfileInput | tournamententryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutProfileInput | tournamententryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput> | TransactionCreateWithoutProfileInput[] | TransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProfileInput | TransactionCreateOrConnectWithoutProfileInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProfileInput | TransactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TransactionCreateManyProfileInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProfileInput | TransactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProfileInput | TransactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type gamesessionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput> | gamesessionCreateWithoutProfileInput[] | gamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutProfileInput | gamesessionCreateOrConnectWithoutProfileInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutProfileInput | gamesessionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: gamesessionCreateManyProfileInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutProfileInput | gamesessionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutProfileInput | gamesessionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type tournamententryUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput> | tournamententryCreateWithoutProfileInput[] | tournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutProfileInput | tournamententryCreateOrConnectWithoutProfileInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutProfileInput | tournamententryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: tournamententryCreateManyProfileInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutProfileInput | tournamententryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutProfileInput | tournamententryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput> | TransactionCreateWithoutProfileInput[] | TransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProfileInput | TransactionCreateOrConnectWithoutProfileInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProfileInput | TransactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: TransactionCreateManyProfileInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProfileInput | TransactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProfileInput | TransactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type OperatorCreateNestedOneWithoutGamesInput = {
    create?: XOR<OperatorCreateWithoutGamesInput, OperatorUncheckedCreateWithoutGamesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutGamesInput
    connect?: OperatorWhereUniqueInput
  }

  export type gamesessionCreateNestedManyWithoutGameInput = {
    create?: XOR<gamesessionCreateWithoutGameInput, gamesessionUncheckedCreateWithoutGameInput> | gamesessionCreateWithoutGameInput[] | gamesessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutGameInput | gamesessionCreateOrConnectWithoutGameInput[]
    createMany?: gamesessionCreateManyGameInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type tournamentgameCreateNestedManyWithoutGameInput = {
    create?: XOR<tournamentgameCreateWithoutGameInput, tournamentgameUncheckedCreateWithoutGameInput> | tournamentgameCreateWithoutGameInput[] | tournamentgameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutGameInput | tournamentgameCreateOrConnectWithoutGameInput[]
    createMany?: tournamentgameCreateManyGameInputEnvelope
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
  }

  export type gamesessionUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<gamesessionCreateWithoutGameInput, gamesessionUncheckedCreateWithoutGameInput> | gamesessionCreateWithoutGameInput[] | gamesessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutGameInput | gamesessionCreateOrConnectWithoutGameInput[]
    createMany?: gamesessionCreateManyGameInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type tournamentgameUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<tournamentgameCreateWithoutGameInput, tournamentgameUncheckedCreateWithoutGameInput> | tournamentgameCreateWithoutGameInput[] | tournamentgameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutGameInput | tournamentgameCreateOrConnectWithoutGameInput[]
    createMany?: tournamentgameCreateManyGameInputEnvelope
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumGameCategoryFieldUpdateOperationsInput = {
    set?: $Enums.GameCategory
  }

  export type OperatorUpdateOneWithoutGamesNestedInput = {
    create?: XOR<OperatorCreateWithoutGamesInput, OperatorUncheckedCreateWithoutGamesInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutGamesInput
    upsert?: OperatorUpsertWithoutGamesInput
    disconnect?: OperatorWhereInput | boolean
    delete?: OperatorWhereInput | boolean
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutGamesInput, OperatorUpdateWithoutGamesInput>, OperatorUncheckedUpdateWithoutGamesInput>
  }

  export type gamesessionUpdateManyWithoutGameNestedInput = {
    create?: XOR<gamesessionCreateWithoutGameInput, gamesessionUncheckedCreateWithoutGameInput> | gamesessionCreateWithoutGameInput[] | gamesessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutGameInput | gamesessionCreateOrConnectWithoutGameInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutGameInput | gamesessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: gamesessionCreateManyGameInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutGameInput | gamesessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutGameInput | gamesessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type tournamentgameUpdateManyWithoutGameNestedInput = {
    create?: XOR<tournamentgameCreateWithoutGameInput, tournamentgameUncheckedCreateWithoutGameInput> | tournamentgameCreateWithoutGameInput[] | tournamentgameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutGameInput | tournamentgameCreateOrConnectWithoutGameInput[]
    upsert?: tournamentgameUpsertWithWhereUniqueWithoutGameInput | tournamentgameUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: tournamentgameCreateManyGameInputEnvelope
    set?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    disconnect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    delete?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    update?: tournamentgameUpdateWithWhereUniqueWithoutGameInput | tournamentgameUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: tournamentgameUpdateManyWithWhereWithoutGameInput | tournamentgameUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
  }

  export type gamesessionUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<gamesessionCreateWithoutGameInput, gamesessionUncheckedCreateWithoutGameInput> | gamesessionCreateWithoutGameInput[] | gamesessionUncheckedCreateWithoutGameInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutGameInput | gamesessionCreateOrConnectWithoutGameInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutGameInput | gamesessionUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: gamesessionCreateManyGameInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutGameInput | gamesessionUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutGameInput | gamesessionUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type tournamentgameUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<tournamentgameCreateWithoutGameInput, tournamentgameUncheckedCreateWithoutGameInput> | tournamentgameCreateWithoutGameInput[] | tournamentgameUncheckedCreateWithoutGameInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutGameInput | tournamentgameCreateOrConnectWithoutGameInput[]
    upsert?: tournamentgameUpsertWithWhereUniqueWithoutGameInput | tournamentgameUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: tournamentgameCreateManyGameInputEnvelope
    set?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    disconnect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    delete?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    update?: tournamentgameUpdateWithWhereUniqueWithoutGameInput | tournamentgameUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: tournamentgameUpdateManyWithWhereWithoutGameInput | tournamentgameUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutOrganizationInput | InvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutOrganizationInput | InvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutOrganizationInput | InvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput> | InvitationCreateWithoutOrganizationInput[] | InvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutOrganizationInput | InvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutOrganizationInput | InvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InvitationCreateManyOrganizationInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutOrganizationInput | InvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutOrganizationInput | InvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembersInput = {
    create?: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersInput
    upsert?: UserUpsertWithoutMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembersInput, UserUpdateWithoutMembersInput>, UserUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    upsert?: OrganizationUpsertWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvitationsInput, OrganizationUpdateWithoutInvitationsInput>, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    upsert?: UserUpsertWithoutInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsInput, UserUpdateWithoutInvitationsInput>, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutTwofactorsInput = {
    create?: XOR<UserCreateWithoutTwofactorsInput, UserUncheckedCreateWithoutTwofactorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwofactorsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwofactorsNestedInput = {
    create?: XOR<UserCreateWithoutTwofactorsInput, UserUncheckedCreateWithoutTwofactorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwofactorsInput
    upsert?: UserUpsertWithoutTwofactorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwofactorsInput, UserUpdateWithoutTwofactorsInput>, UserUncheckedUpdateWithoutTwofactorsInput>
  }

  export type chatroomCreateNestedOneWithoutChatmessageInput = {
    create?: XOR<chatroomCreateWithoutChatmessageInput, chatroomUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: chatroomCreateOrConnectWithoutChatmessageInput
    connect?: chatroomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatmessageInput = {
    create?: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatmessageInput
    connect?: UserWhereUniqueInput
  }

  export type EnumChatChannelFieldUpdateOperationsInput = {
    set?: $Enums.ChatChannel
  }

  export type chatroomUpdateOneWithoutChatmessageNestedInput = {
    create?: XOR<chatroomCreateWithoutChatmessageInput, chatroomUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: chatroomCreateOrConnectWithoutChatmessageInput
    upsert?: chatroomUpsertWithoutChatmessageInput
    disconnect?: chatroomWhereInput | boolean
    delete?: chatroomWhereInput | boolean
    connect?: chatroomWhereUniqueInput
    update?: XOR<XOR<chatroomUpdateToOneWithWhereWithoutChatmessageInput, chatroomUpdateWithoutChatmessageInput>, chatroomUncheckedUpdateWithoutChatmessageInput>
  }

  export type UserUpdateOneRequiredWithoutChatmessageNestedInput = {
    create?: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatmessageInput
    upsert?: UserUpsertWithoutChatmessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatmessageInput, UserUpdateWithoutChatmessageInput>, UserUncheckedUpdateWithoutChatmessageInput>
  }

  export type chatmessageCreateNestedManyWithoutChatroomInput = {
    create?: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput> | chatmessageCreateWithoutChatroomInput[] | chatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutChatroomInput | chatmessageCreateOrConnectWithoutChatroomInput[]
    createMany?: chatmessageCreateManyChatroomInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type gamesessionCreateNestedOneWithoutChatroomInput = {
    create?: XOR<gamesessionCreateWithoutChatroomInput, gamesessionUncheckedCreateWithoutChatroomInput>
    connectOrCreate?: gamesessionCreateOrConnectWithoutChatroomInput
    connect?: gamesessionWhereUniqueInput
  }

  export type chatmessageUncheckedCreateNestedManyWithoutChatroomInput = {
    create?: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput> | chatmessageCreateWithoutChatroomInput[] | chatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutChatroomInput | chatmessageCreateOrConnectWithoutChatroomInput[]
    createMany?: chatmessageCreateManyChatroomInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type chatmessageUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput> | chatmessageCreateWithoutChatroomInput[] | chatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutChatroomInput | chatmessageCreateOrConnectWithoutChatroomInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutChatroomInput | chatmessageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: chatmessageCreateManyChatroomInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutChatroomInput | chatmessageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutChatroomInput | chatmessageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type gamesessionUpdateOneWithoutChatroomNestedInput = {
    create?: XOR<gamesessionCreateWithoutChatroomInput, gamesessionUncheckedCreateWithoutChatroomInput>
    connectOrCreate?: gamesessionCreateOrConnectWithoutChatroomInput
    upsert?: gamesessionUpsertWithoutChatroomInput
    disconnect?: gamesessionWhereInput | boolean
    delete?: gamesessionWhereInput | boolean
    connect?: gamesessionWhereUniqueInput
    update?: XOR<XOR<gamesessionUpdateToOneWithWhereWithoutChatroomInput, gamesessionUpdateWithoutChatroomInput>, gamesessionUncheckedUpdateWithoutChatroomInput>
  }

  export type chatmessageUncheckedUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput> | chatmessageCreateWithoutChatroomInput[] | chatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutChatroomInput | chatmessageCreateOrConnectWithoutChatroomInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutChatroomInput | chatmessageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: chatmessageCreateManyChatroomInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutChatroomInput | chatmessageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutChatroomInput | chatmessageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFriendship_friendship_friendIdTouserInput = {
    create?: XOR<UserCreateWithoutFriendship_friendship_friendIdTouserInput, UserUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendship_friendship_friendIdTouserInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFriendship_friendship_userIdTouserInput = {
    create?: XOR<UserCreateWithoutFriendship_friendship_userIdTouserInput, UserUncheckedCreateWithoutFriendship_friendship_userIdTouserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendship_friendship_userIdTouserInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFriendshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendshipStatus
  }

  export type UserUpdateOneRequiredWithoutFriendship_friendship_friendIdTouserNestedInput = {
    create?: XOR<UserCreateWithoutFriendship_friendship_friendIdTouserInput, UserUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendship_friendship_friendIdTouserInput
    upsert?: UserUpsertWithoutFriendship_friendship_friendIdTouserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendship_friendship_friendIdTouserInput, UserUpdateWithoutFriendship_friendship_friendIdTouserInput>, UserUncheckedUpdateWithoutFriendship_friendship_friendIdTouserInput>
  }

  export type UserUpdateOneRequiredWithoutFriendship_friendship_userIdTouserNestedInput = {
    create?: XOR<UserCreateWithoutFriendship_friendship_userIdTouserInput, UserUncheckedCreateWithoutFriendship_friendship_userIdTouserInput>
    connectOrCreate?: UserCreateOrConnectWithoutFriendship_friendship_userIdTouserInput
    upsert?: UserUpsertWithoutFriendship_friendship_userIdTouserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriendship_friendship_userIdTouserInput, UserUpdateWithoutFriendship_friendship_userIdTouserInput>, UserUncheckedUpdateWithoutFriendship_friendship_userIdTouserInput>
  }

  export type chatroomCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput> | chatroomCreateWithoutGamesessionInput[] | chatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: chatroomCreateOrConnectWithoutGamesessionInput | chatroomCreateOrConnectWithoutGamesessionInput[]
    createMany?: chatroomCreateManyGamesessionInputEnvelope
    connect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
  }

  export type GameCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<GameCreateWithoutGamesessionInput, GameUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: GameCreateOrConnectWithoutGamesessionInput
    connect?: GameWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<ProfileCreateWithoutGamesessionInput, ProfileUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutGamesessionInput
    connect?: ProfileWhereUniqueInput
  }

  export type tournamentCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<tournamentCreateWithoutGamesessionInput, tournamentUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutGamesessionInput
    connect?: tournamentWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput> | TransactionCreateWithoutGamesessionInput[] | TransactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGamesessionInput | TransactionCreateOrConnectWithoutGamesessionInput[]
    createMany?: TransactionCreateManyGamesessionInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type chatroomUncheckedCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput> | chatroomCreateWithoutGamesessionInput[] | chatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: chatroomCreateOrConnectWithoutGamesessionInput | chatroomCreateOrConnectWithoutGamesessionInput[]
    createMany?: chatroomCreateManyGamesessionInputEnvelope
    connect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput> | TransactionCreateWithoutGamesessionInput[] | TransactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGamesessionInput | TransactionCreateOrConnectWithoutGamesessionInput[]
    createMany?: TransactionCreateManyGamesessionInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type chatroomUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput> | chatroomCreateWithoutGamesessionInput[] | chatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: chatroomCreateOrConnectWithoutGamesessionInput | chatroomCreateOrConnectWithoutGamesessionInput[]
    upsert?: chatroomUpsertWithWhereUniqueWithoutGamesessionInput | chatroomUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: chatroomCreateManyGamesessionInputEnvelope
    set?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    disconnect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    delete?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    connect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    update?: chatroomUpdateWithWhereUniqueWithoutGamesessionInput | chatroomUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: chatroomUpdateManyWithWhereWithoutGamesessionInput | chatroomUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: chatroomScalarWhereInput | chatroomScalarWhereInput[]
  }

  export type GameUpdateOneRequiredWithoutGamesessionNestedInput = {
    create?: XOR<GameCreateWithoutGamesessionInput, GameUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: GameCreateOrConnectWithoutGamesessionInput
    upsert?: GameUpsertWithoutGamesessionInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutGamesessionInput, GameUpdateWithoutGamesessionInput>, GameUncheckedUpdateWithoutGamesessionInput>
  }

  export type ProfileUpdateOneRequiredWithoutGamesessionNestedInput = {
    create?: XOR<ProfileCreateWithoutGamesessionInput, ProfileUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutGamesessionInput
    upsert?: ProfileUpsertWithoutGamesessionInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutGamesessionInput, ProfileUpdateWithoutGamesessionInput>, ProfileUncheckedUpdateWithoutGamesessionInput>
  }

  export type tournamentUpdateOneWithoutGamesessionNestedInput = {
    create?: XOR<tournamentCreateWithoutGamesessionInput, tournamentUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutGamesessionInput
    upsert?: tournamentUpsertWithoutGamesessionInput
    disconnect?: tournamentWhereInput | boolean
    delete?: tournamentWhereInput | boolean
    connect?: tournamentWhereUniqueInput
    update?: XOR<XOR<tournamentUpdateToOneWithWhereWithoutGamesessionInput, tournamentUpdateWithoutGamesessionInput>, tournamentUncheckedUpdateWithoutGamesessionInput>
  }

  export type TransactionUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput> | TransactionCreateWithoutGamesessionInput[] | TransactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGamesessionInput | TransactionCreateOrConnectWithoutGamesessionInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGamesessionInput | TransactionUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: TransactionCreateManyGamesessionInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGamesessionInput | TransactionUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGamesessionInput | TransactionUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type chatroomUncheckedUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput> | chatroomCreateWithoutGamesessionInput[] | chatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: chatroomCreateOrConnectWithoutGamesessionInput | chatroomCreateOrConnectWithoutGamesessionInput[]
    upsert?: chatroomUpsertWithWhereUniqueWithoutGamesessionInput | chatroomUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: chatroomCreateManyGamesessionInputEnvelope
    set?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    disconnect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    delete?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    connect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    update?: chatroomUpdateWithWhereUniqueWithoutGamesessionInput | chatroomUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: chatroomUpdateManyWithWhereWithoutGamesessionInput | chatroomUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: chatroomScalarWhereInput | chatroomScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput> | TransactionCreateWithoutGamesessionInput[] | TransactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGamesessionInput | TransactionCreateOrConnectWithoutGamesessionInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGamesessionInput | TransactionUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: TransactionCreateManyGamesessionInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGamesessionInput | TransactionUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGamesessionInput | TransactionUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type OperatorCreateNestedOneWithoutProductInput = {
    create?: XOR<OperatorCreateWithoutProductInput, OperatorUncheckedCreateWithoutProductInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutProductInput
    connect?: OperatorWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput> | TransactionCreateWithoutProductInput[] | TransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProductInput | TransactionCreateOrConnectWithoutProductInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput> | TransactionCreateWithoutProductInput[] | TransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProductInput | TransactionCreateOrConnectWithoutProductInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type OperatorUpdateOneWithoutProductNestedInput = {
    create?: XOR<OperatorCreateWithoutProductInput, OperatorUncheckedCreateWithoutProductInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutProductInput
    upsert?: OperatorUpsertWithoutProductInput
    disconnect?: OperatorWhereInput | boolean
    delete?: OperatorWhereInput | boolean
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutProductInput, OperatorUpdateWithoutProductInput>, OperatorUncheckedUpdateWithoutProductInput>
  }

  export type TransactionUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput> | TransactionCreateWithoutProductInput[] | TransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProductInput | TransactionCreateOrConnectWithoutProductInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProductInput | TransactionUpsertWithWhereUniqueWithoutProductInput[]
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProductInput | TransactionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProductInput | TransactionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput> | TransactionCreateWithoutProductInput[] | TransactionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutProductInput | TransactionCreateOrConnectWithoutProductInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutProductInput | TransactionUpsertWithWhereUniqueWithoutProductInput[]
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutProductInput | TransactionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutProductInput | TransactionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type gamesessionCreateNestedManyWithoutTournamentInput = {
    create?: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput> | gamesessionCreateWithoutTournamentInput[] | gamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutTournamentInput | gamesessionCreateOrConnectWithoutTournamentInput[]
    createMany?: gamesessionCreateManyTournamentInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type OperatorCreateNestedOneWithoutTournamentsInput = {
    create?: XOR<OperatorCreateWithoutTournamentsInput, OperatorUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutTournamentsInput
    connect?: OperatorWhereUniqueInput
  }

  export type tournamententryCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput> | tournamententryCreateWithoutTournamentInput[] | tournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutTournamentInput | tournamententryCreateOrConnectWithoutTournamentInput[]
    createMany?: tournamententryCreateManyTournamentInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type tournamentgameCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput> | tournamentgameCreateWithoutTournamentInput[] | tournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutTournamentInput | tournamentgameCreateOrConnectWithoutTournamentInput[]
    createMany?: tournamentgameCreateManyTournamentInputEnvelope
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
  }

  export type gamesessionUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput> | gamesessionCreateWithoutTournamentInput[] | gamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutTournamentInput | gamesessionCreateOrConnectWithoutTournamentInput[]
    createMany?: gamesessionCreateManyTournamentInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type tournamententryUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput> | tournamententryCreateWithoutTournamentInput[] | tournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutTournamentInput | tournamententryCreateOrConnectWithoutTournamentInput[]
    createMany?: tournamententryCreateManyTournamentInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type tournamentgameUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput> | tournamentgameCreateWithoutTournamentInput[] | tournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutTournamentInput | tournamentgameCreateOrConnectWithoutTournamentInput[]
    createMany?: tournamentgameCreateManyTournamentInputEnvelope
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
  }

  export type gamesessionUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput> | gamesessionCreateWithoutTournamentInput[] | gamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutTournamentInput | gamesessionCreateOrConnectWithoutTournamentInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutTournamentInput | gamesessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: gamesessionCreateManyTournamentInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutTournamentInput | gamesessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutTournamentInput | gamesessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type OperatorUpdateOneRequiredWithoutTournamentsNestedInput = {
    create?: XOR<OperatorCreateWithoutTournamentsInput, OperatorUncheckedCreateWithoutTournamentsInput>
    connectOrCreate?: OperatorCreateOrConnectWithoutTournamentsInput
    upsert?: OperatorUpsertWithoutTournamentsInput
    connect?: OperatorWhereUniqueInput
    update?: XOR<XOR<OperatorUpdateToOneWithWhereWithoutTournamentsInput, OperatorUpdateWithoutTournamentsInput>, OperatorUncheckedUpdateWithoutTournamentsInput>
  }

  export type tournamententryUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput> | tournamententryCreateWithoutTournamentInput[] | tournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutTournamentInput | tournamententryCreateOrConnectWithoutTournamentInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutTournamentInput | tournamententryUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournamententryCreateManyTournamentInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutTournamentInput | tournamententryUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutTournamentInput | tournamententryUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type tournamentgameUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput> | tournamentgameCreateWithoutTournamentInput[] | tournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutTournamentInput | tournamentgameCreateOrConnectWithoutTournamentInput[]
    upsert?: tournamentgameUpsertWithWhereUniqueWithoutTournamentInput | tournamentgameUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournamentgameCreateManyTournamentInputEnvelope
    set?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    disconnect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    delete?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    update?: tournamentgameUpdateWithWhereUniqueWithoutTournamentInput | tournamentgameUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournamentgameUpdateManyWithWhereWithoutTournamentInput | tournamentgameUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
  }

  export type gamesessionUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput> | gamesessionCreateWithoutTournamentInput[] | gamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutTournamentInput | gamesessionCreateOrConnectWithoutTournamentInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutTournamentInput | gamesessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: gamesessionCreateManyTournamentInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutTournamentInput | gamesessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutTournamentInput | gamesessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type tournamententryUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput> | tournamententryCreateWithoutTournamentInput[] | tournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutTournamentInput | tournamententryCreateOrConnectWithoutTournamentInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutTournamentInput | tournamententryUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournamententryCreateManyTournamentInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutTournamentInput | tournamententryUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutTournamentInput | tournamententryUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput> | tournamentgameCreateWithoutTournamentInput[] | tournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutTournamentInput | tournamentgameCreateOrConnectWithoutTournamentInput[]
    upsert?: tournamentgameUpsertWithWhereUniqueWithoutTournamentInput | tournamentgameUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournamentgameCreateManyTournamentInputEnvelope
    set?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    disconnect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    delete?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    update?: tournamentgameUpdateWithWhereUniqueWithoutTournamentInput | tournamentgameUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournamentgameUpdateManyWithWhereWithoutTournamentInput | tournamentgameUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<ProfileCreateWithoutTournamententryInput, ProfileUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTournamententryInput
    connect?: ProfileWhereUniqueInput
  }

  export type tournamentCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<tournamentCreateWithoutTournamententryInput, tournamentUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutTournamententryInput
    connect?: tournamentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<UserCreateWithoutTournamententryInput, UserUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamententryInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<ProfileCreateWithoutTournamententryInput, ProfileUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTournamententryInput
    upsert?: ProfileUpsertWithoutTournamententryInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTournamententryInput, ProfileUpdateWithoutTournamententryInput>, ProfileUncheckedUpdateWithoutTournamententryInput>
  }

  export type tournamentUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<tournamentCreateWithoutTournamententryInput, tournamentUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutTournamententryInput
    upsert?: tournamentUpsertWithoutTournamententryInput
    connect?: tournamentWhereUniqueInput
    update?: XOR<XOR<tournamentUpdateToOneWithWhereWithoutTournamententryInput, tournamentUpdateWithoutTournamententryInput>, tournamentUncheckedUpdateWithoutTournamententryInput>
  }

  export type UserUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<UserCreateWithoutTournamententryInput, UserUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamententryInput
    upsert?: UserUpsertWithoutTournamententryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTournamententryInput, UserUpdateWithoutTournamententryInput>, UserUncheckedUpdateWithoutTournamententryInput>
  }

  export type GameCreateNestedOneWithoutTournamentgameInput = {
    create?: XOR<GameCreateWithoutTournamentgameInput, GameUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: GameCreateOrConnectWithoutTournamentgameInput
    connect?: GameWhereUniqueInput
  }

  export type tournamentCreateNestedOneWithoutTournamentgameInput = {
    create?: XOR<tournamentCreateWithoutTournamentgameInput, tournamentUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutTournamentgameInput
    connect?: tournamentWhereUniqueInput
  }

  export type GameUpdateOneRequiredWithoutTournamentgameNestedInput = {
    create?: XOR<GameCreateWithoutTournamentgameInput, GameUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: GameCreateOrConnectWithoutTournamentgameInput
    upsert?: GameUpsertWithoutTournamentgameInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutTournamentgameInput, GameUpdateWithoutTournamentgameInput>, GameUncheckedUpdateWithoutTournamentgameInput>
  }

  export type tournamentUpdateOneRequiredWithoutTournamentgameNestedInput = {
    create?: XOR<tournamentCreateWithoutTournamentgameInput, tournamentUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutTournamentgameInput
    upsert?: tournamentUpsertWithoutTournamentgameInput
    connect?: tournamentWhereUniqueInput
    update?: XOR<XOR<tournamentUpdateToOneWithWhereWithoutTournamentgameInput, tournamentUpdateWithoutTournamentgameInput>, tournamentUncheckedUpdateWithoutTournamentgameInput>
  }

  export type gamesessionCreateNestedOneWithoutTransactionInput = {
    create?: XOR<gamesessionCreateWithoutTransactionInput, gamesessionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: gamesessionCreateOrConnectWithoutTransactionInput
    connect?: gamesessionWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ProfileCreateWithoutTransactionsInput, ProfileUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTransactionsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput> | ProductCreateWithoutTransactionsInput[] | ProductUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionsInput | ProductCreateOrConnectWithoutTransactionsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput> | ProductCreateWithoutTransactionsInput[] | ProductUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionsInput | ProductCreateOrConnectWithoutTransactionsInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type gamesessionUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<gamesessionCreateWithoutTransactionInput, gamesessionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: gamesessionCreateOrConnectWithoutTransactionInput
    upsert?: gamesessionUpsertWithoutTransactionInput
    disconnect?: gamesessionWhereInput | boolean
    delete?: gamesessionWhereInput | boolean
    connect?: gamesessionWhereUniqueInput
    update?: XOR<XOR<gamesessionUpdateToOneWithWhereWithoutTransactionInput, gamesessionUpdateWithoutTransactionInput>, gamesessionUncheckedUpdateWithoutTransactionInput>
  }

  export type ProfileUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<ProfileCreateWithoutTransactionsInput, ProfileUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTransactionsInput
    upsert?: ProfileUpsertWithoutTransactionsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTransactionsInput, ProfileUpdateWithoutTransactionsInput>, ProfileUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProductUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput> | ProductCreateWithoutTransactionsInput[] | ProductUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionsInput | ProductCreateOrConnectWithoutTransactionsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTransactionsInput | ProductUpsertWithWhereUniqueWithoutTransactionsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTransactionsInput | ProductUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTransactionsInput | ProductUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput> | ProductCreateWithoutTransactionsInput[] | ProductUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTransactionsInput | ProductCreateOrConnectWithoutTransactionsInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTransactionsInput | ProductUpsertWithWhereUniqueWithoutTransactionsInput[]
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTransactionsInput | ProductUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTransactionsInput | ProductUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type achievementCreateNestedOneWithoutUserachievementInput = {
    create?: XOR<achievementCreateWithoutUserachievementInput, achievementUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: achievementCreateOrConnectWithoutUserachievementInput
    connect?: achievementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserachievementInput = {
    create?: XOR<UserCreateWithoutUserachievementInput, UserUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserachievementInput
    connect?: UserWhereUniqueInput
  }

  export type achievementUpdateOneRequiredWithoutUserachievementNestedInput = {
    create?: XOR<achievementCreateWithoutUserachievementInput, achievementUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: achievementCreateOrConnectWithoutUserachievementInput
    upsert?: achievementUpsertWithoutUserachievementInput
    connect?: achievementWhereUniqueInput
    update?: XOR<XOR<achievementUpdateToOneWithWhereWithoutUserachievementInput, achievementUpdateWithoutUserachievementInput>, achievementUncheckedUpdateWithoutUserachievementInput>
  }

  export type UserUpdateOneRequiredWithoutUserachievementNestedInput = {
    create?: XOR<UserCreateWithoutUserachievementInput, UserUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserachievementInput
    upsert?: UserUpsertWithoutUserachievementInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserachievementInput, UserUpdateWithoutUserachievementInput>, UserUncheckedUpdateWithoutUserachievementInput>
  }

  export type RainHistoryCreateNestedOneWithoutRainBetInput = {
    create?: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainBetInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRainBetInput = {
    create?: XOR<UserCreateWithoutRainBetInput, UserUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainBetInput
    connect?: UserWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainBetNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainBetInput
    upsert?: RainHistoryUpsertWithoutRainBetInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainBetInput, RainHistoryUpdateWithoutRainBetInput>, RainHistoryUncheckedUpdateWithoutRainBetInput>
  }

  export type UserUpdateOneRequiredWithoutRainBetNestedInput = {
    create?: XOR<UserCreateWithoutRainBetInput, UserUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainBetInput
    upsert?: UserUpsertWithoutRainBetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRainBetInput, UserUpdateWithoutRainBetInput>, UserUncheckedUpdateWithoutRainBetInput>
  }

  export type RainBetCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutRainHistoryInput = {
    create?: XOR<UserCreateWithoutRainHistoryInput, UserUncheckedCreateWithoutRainHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type RainTipCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type RainBetUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainTipUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type RainBetUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutRainHistoryInput | RainBetUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutRainHistoryInput | RainBetUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutRainHistoryInput | RainBetUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutRainHistoryNestedInput = {
    create?: XOR<UserCreateWithoutRainHistoryInput, UserUncheckedCreateWithoutRainHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainHistoryInput
    upsert?: UserUpsertWithoutRainHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRainHistoryInput, UserUpdateWithoutRainHistoryInput>, UserUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainTipUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutRainHistoryInput | RainTipUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutRainHistoryInput | RainTipUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutRainHistoryInput | RainTipUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutRainHistoryInput | RainWinnerUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutRainHistoryInput | RainBetUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutRainHistoryInput | RainBetUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutRainHistoryInput | RainBetUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutRainHistoryInput | RainTipUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutRainHistoryInput | RainTipUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutRainHistoryInput | RainTipUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutRainHistoryInput | RainWinnerUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type RainHistoryCreateNestedOneWithoutRainTipInput = {
    create?: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainTipInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRainTipInput = {
    create?: XOR<UserCreateWithoutRainTipInput, UserUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainTipInput
    connect?: UserWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainTipNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainTipInput
    upsert?: RainHistoryUpsertWithoutRainTipInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainTipInput, RainHistoryUpdateWithoutRainTipInput>, RainHistoryUncheckedUpdateWithoutRainTipInput>
  }

  export type UserUpdateOneRequiredWithoutRainTipNestedInput = {
    create?: XOR<UserCreateWithoutRainTipInput, UserUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainTipInput
    upsert?: UserUpsertWithoutRainTipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRainTipInput, UserUpdateWithoutRainTipInput>, UserUncheckedUpdateWithoutRainTipInput>
  }

  export type RainHistoryCreateNestedOneWithoutRainWinnerInput = {
    create?: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainWinnerInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRainWinnerInput = {
    create?: XOR<UserCreateWithoutRainWinnerInput, UserUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainWinnerInput
    connect?: UserWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainWinnerInput
    upsert?: RainHistoryUpsertWithoutRainWinnerInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainWinnerInput, RainHistoryUpdateWithoutRainWinnerInput>, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
  }

  export type UserUpdateOneRequiredWithoutRainWinnerNestedInput = {
    create?: XOR<UserCreateWithoutRainWinnerInput, UserUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutRainWinnerInput
    upsert?: UserUpsertWithoutRainWinnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRainWinnerInput, UserUpdateWithoutRainWinnerInput>, UserUncheckedUpdateWithoutRainWinnerInput>
  }

  export type UserCreateNestedOneWithoutVipInfoInput = {
    create?: XOR<UserCreateWithoutVipInfoInput, UserUncheckedCreateWithoutVipInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipInfoInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVipInfoNestedInput = {
    create?: XOR<UserCreateWithoutVipInfoInput, UserUncheckedCreateWithoutVipInfoInput>
    connectOrCreate?: UserCreateOrConnectWithoutVipInfoInput
    upsert?: UserUpsertWithoutVipInfoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVipInfoInput, UserUpdateWithoutVipInfoInput>, UserUncheckedUpdateWithoutVipInfoInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumUserStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableFilter<$PrismaModel> | $Enums.UserStatus | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumGameCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.GameCategory | EnumGameCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGameCategoryFilter<$PrismaModel> | $Enums.GameCategory
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumGameCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameCategory | EnumGameCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameCategory[] | ListEnumGameCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumGameCategoryWithAggregatesFilter<$PrismaModel> | $Enums.GameCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameCategoryFilter<$PrismaModel>
    _max?: NestedEnumGameCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumChatChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelFilter<$PrismaModel> | $Enums.ChatChannel
  }

  export type NestedEnumChatChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelWithAggregatesFilter<$PrismaModel> | $Enums.ChatChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatChannelFilter<$PrismaModel>
    _max?: NestedEnumChatChannelFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type userachievementCreateWithoutAchievementInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserachievementInput
  }

  export type userachievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
  }

  export type userachievementCreateOrConnectWithoutAchievementInput = {
    where: userachievementWhereUniqueInput
    create: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput>
  }

  export type userachievementCreateManyAchievementInputEnvelope = {
    data: userachievementCreateManyAchievementInput | userachievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type userachievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: userachievementWhereUniqueInput
    update: XOR<userachievementUpdateWithoutAchievementInput, userachievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput>
  }

  export type userachievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: userachievementWhereUniqueInput
    data: XOR<userachievementUpdateWithoutAchievementInput, userachievementUncheckedUpdateWithoutAchievementInput>
  }

  export type userachievementUpdateManyWithWhereWithoutAchievementInput = {
    where: userachievementScalarWhereInput
    data: XOR<userachievementUpdateManyMutationInput, userachievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type userachievementScalarWhereInput = {
    AND?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
    OR?: userachievementScalarWhereInput[]
    NOT?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
    id?: StringFilter<"userachievement"> | string
    progress?: IntFilter<"userachievement"> | number
    isUnlocked?: BoolFilter<"userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"userachievement"> | Date | string
    updatedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    userId?: StringFilter<"userachievement"> | string
    achievementId?: StringFilter<"userachievement"> | string
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutUserInput = {
    id?: string
    role: string
    createdAt: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    role: string
    createdAt: Date | string
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutUserInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
  }

  export type InvitationCreateOrConnectWithoutUserInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput>
  }

  export type InvitationCreateManyUserInputEnvelope = {
    data: InvitationCreateManyUserInput | InvitationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwoFactorCreateWithoutUserInput = {
    id?: string
    secret: string
    backupCodes: string
  }

  export type TwoFactorUncheckedCreateWithoutUserInput = {
    id?: string
    secret: string
    backupCodes: string
  }

  export type TwoFactorCreateOrConnectWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    create: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorCreateManyUserInputEnvelope = {
    data: TwoFactorCreateManyUserInput | TwoFactorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainBetCreateWithoutUserInput = {
    id?: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
    RainHistory: RainHistoryCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateWithoutUserInput = {
    id?: string
    rainHistoryId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetCreateOrConnectWithoutUserInput = {
    where: RainBetWhereUniqueInput
    create: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput>
  }

  export type RainBetCreateManyUserInputEnvelope = {
    data: RainBetCreateManyUserInput | RainBetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainHistoryCreateWithoutUserInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput>
  }

  export type RainHistoryCreateManyUserInputEnvelope = {
    data: RainHistoryCreateManyUserInput | RainHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainTipCreateWithoutUserInput = {
    id?: string
    tipAmount: number
    tippedAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateWithoutUserInput = {
    id?: string
    rainHistoryId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainTipCreateOrConnectWithoutUserInput = {
    where: RainTipWhereUniqueInput
    create: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput>
  }

  export type RainTipCreateManyUserInputEnvelope = {
    data: RainTipCreateManyUserInput | RainTipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainWinnerCreateWithoutUserInput = {
    id?: string
    wonAmount: number
    wonAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateWithoutUserInput = {
    id?: string
    rainHistoryId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainWinnerCreateOrConnectWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    create: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput>
  }

  export type RainWinnerCreateManyUserInputEnvelope = {
    data: RainWinnerCreateManyUserInput | RainWinnerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type chatmessageCreateWithoutUserInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatroom?: chatroomCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    roomId?: string | null
  }

  export type chatmessageCreateOrConnectWithoutUserInput = {
    where: chatmessageWhereUniqueInput
    create: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput>
  }

  export type chatmessageCreateManyUserInputEnvelope = {
    data: chatmessageCreateManyUserInput | chatmessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type friendshipCreateWithoutUser_friendship_friendIdTouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user_friendship_userIdTouser: UserCreateNestedOneWithoutFriendship_friendship_userIdTouserInput
  }

  export type friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
  }

  export type friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput = {
    where: friendshipWhereUniqueInput
    create: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput>
  }

  export type friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope = {
    data: friendshipCreateManyUser_friendship_friendIdTouserInput | friendshipCreateManyUser_friendship_friendIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type friendshipCreateWithoutUser_friendship_userIdTouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user_friendship_friendIdTouser: UserCreateNestedOneWithoutFriendship_friendship_friendIdTouserInput
  }

  export type friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    friendId: string
  }

  export type friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput = {
    where: friendshipWhereUniqueInput
    create: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput>
  }

  export type friendshipCreateManyUser_friendship_userIdTouserInputEnvelope = {
    data: friendshipCreateManyUser_friendship_userIdTouserInput | friendshipCreateManyUser_friendship_userIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type notificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type notificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type notificationCreateOrConnectWithoutUserInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationCreateManyUserInputEnvelope = {
    data: notificationCreateManyUserInput | notificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OperatorCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: number
    games?: GameCreateNestedManyWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentCreateNestedManyWithoutOperatorInput
    Product?: ProductCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: number
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
    Product?: ProductUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutOwnerInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput>
  }

  export type OperatorCreateManyOwnerInputEnvelope = {
    data: OperatorCreateManyOwnerInput | OperatorCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUser_profile_userIdTouserInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    operator: OperatorCreateNestedOneWithoutProfilesInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUser_profile_userIdTouserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUser_profile_userIdTouserInput, ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput>
  }

  export type ProfileCreateManyUser_profile_userIdTouserInputEnvelope = {
    data: ProfileCreateManyUser_profile_userIdTouserInput | ProfileCreateManyUser_profile_userIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type tournamententryCreateWithoutUserInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTournamententryInput
    tournament: tournamentCreateNestedOneWithoutTournamententryInput
  }

  export type tournamententryUncheckedCreateWithoutUserInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    tournamentId: string
    profileId: string
  }

  export type tournamententryCreateOrConnectWithoutUserInput = {
    where: tournamententryWhereUniqueInput
    create: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput>
  }

  export type tournamententryCreateManyUserInputEnvelope = {
    data: tournamententryCreateManyUserInput | tournamententryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userachievementCreateWithoutUserInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    achievement: achievementCreateNestedOneWithoutUserachievementInput
  }

  export type userachievementUncheckedCreateWithoutUserInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    achievementId: string
  }

  export type userachievementCreateOrConnectWithoutUserInput = {
    where: userachievementWhereUniqueInput
    create: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput>
  }

  export type userachievementCreateManyUserInputEnvelope = {
    data: userachievementCreateManyUserInput | userachievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VipInfoCreateWithoutUserInput = {
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: string
    icon: string
    exp_switch_type: number
    now_deposit_exp: string
    level_deposit_exp: string
    now_bet_exp: string
    level_bet_exp: string
    telegram: string
    is_protection?: boolean
    protection_deposit_exp: string
    protection_deposit_amount: string
    protection_bet_exp: string
    protection_bet_amount: string
    protection_days: number
    protection_switch: number
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp: string
    unprotection_deposit_amount: string
    unprotection_bet_exp: string
    unprotection_bet_amount: string
    unprotection_days: number
    unprotection_switch: number
    main_currency: string
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
  }

  export type VipInfoUncheckedCreateWithoutUserInput = {
    id?: number
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: string
    icon: string
    exp_switch_type: number
    now_deposit_exp: string
    level_deposit_exp: string
    now_bet_exp: string
    level_bet_exp: string
    telegram: string
    is_protection?: boolean
    protection_deposit_exp: string
    protection_deposit_amount: string
    protection_bet_exp: string
    protection_bet_amount: string
    protection_days: number
    protection_switch: number
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp: string
    unprotection_deposit_amount: string
    unprotection_bet_exp: string
    unprotection_bet_amount: string
    unprotection_days: number
    unprotection_switch: number
    main_currency: string
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
  }

  export type VipInfoCreateOrConnectWithoutUserInput = {
    where: VipInfoWhereUniqueInput
    create: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput>
  }

  export type VipInfoCreateManyUserInputEnvelope = {
    data: VipInfoCreateManyUserInput | VipInfoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    activeGameId?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    active?: BoolFilter<"Session"> | boolean
    token?: StringFilter<"Session"> | string
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Account"> | Date | string | null
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    id?: StringFilter<"Member"> | string
    organizationId?: StringFilter<"Member"> | string
    userId?: StringFilter<"Member"> | string
    role?: StringFilter<"Member"> | string
    createdAt?: DateTimeFilter<"Member"> | Date | string
  }

  export type InvitationUpsertWithWhereUniqueWithoutUserInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutUserInput, InvitationUncheckedUpdateWithoutUserInput>
    create: XOR<InvitationCreateWithoutUserInput, InvitationUncheckedCreateWithoutUserInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutUserInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutUserInput, InvitationUncheckedUpdateWithoutUserInput>
  }

  export type InvitationUpdateManyWithWhereWithoutUserInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutUserInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    organizationId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    role?: StringNullableFilter<"Invitation"> | string | null
    status?: StringFilter<"Invitation"> | string
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    inviterId?: StringFilter<"Invitation"> | string
  }

  export type TwoFactorUpsertWithWhereUniqueWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    update: XOR<TwoFactorUpdateWithoutUserInput, TwoFactorUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorUpdateWithWhereUniqueWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    data: XOR<TwoFactorUpdateWithoutUserInput, TwoFactorUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorUpdateManyWithWhereWithoutUserInput = {
    where: TwoFactorScalarWhereInput
    data: XOR<TwoFactorUpdateManyMutationInput, TwoFactorUncheckedUpdateManyWithoutUserInput>
  }

  export type TwoFactorScalarWhereInput = {
    AND?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
    OR?: TwoFactorScalarWhereInput[]
    NOT?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
    id?: StringFilter<"TwoFactor"> | string
    secret?: StringFilter<"TwoFactor"> | string
    backupCodes?: StringFilter<"TwoFactor"> | string
    userId?: StringFilter<"TwoFactor"> | string
  }

  export type RainBetUpsertWithWhereUniqueWithoutUserInput = {
    where: RainBetWhereUniqueInput
    update: XOR<RainBetUpdateWithoutUserInput, RainBetUncheckedUpdateWithoutUserInput>
    create: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput>
  }

  export type RainBetUpdateWithWhereUniqueWithoutUserInput = {
    where: RainBetWhereUniqueInput
    data: XOR<RainBetUpdateWithoutUserInput, RainBetUncheckedUpdateWithoutUserInput>
  }

  export type RainBetUpdateManyWithWhereWithoutUserInput = {
    where: RainBetScalarWhereInput
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyWithoutUserInput>
  }

  export type RainBetScalarWhereInput = {
    AND?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
    OR?: RainBetScalarWhereInput[]
    NOT?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
    id?: StringFilter<"RainBet"> | string
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: IntFilter<"RainBet"> | number
    odds?: IntFilter<"RainBet"> | number
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
  }

  export type RainHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    update: XOR<RainHistoryUpdateWithoutUserInput, RainHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput>
  }

  export type RainHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    data: XOR<RainHistoryUpdateWithoutUserInput, RainHistoryUncheckedUpdateWithoutUserInput>
  }

  export type RainHistoryUpdateManyWithWhereWithoutUserInput = {
    where: RainHistoryScalarWhereInput
    data: XOR<RainHistoryUpdateManyMutationInput, RainHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type RainHistoryScalarWhereInput = {
    AND?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
    OR?: RainHistoryScalarWhereInput[]
    NOT?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
    id?: StringFilter<"RainHistory"> | string
    userId?: StringFilter<"RainHistory"> | string
    amount?: IntFilter<"RainHistory"> | number
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
  }

  export type RainTipUpsertWithWhereUniqueWithoutUserInput = {
    where: RainTipWhereUniqueInput
    update: XOR<RainTipUpdateWithoutUserInput, RainTipUncheckedUpdateWithoutUserInput>
    create: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput>
  }

  export type RainTipUpdateWithWhereUniqueWithoutUserInput = {
    where: RainTipWhereUniqueInput
    data: XOR<RainTipUpdateWithoutUserInput, RainTipUncheckedUpdateWithoutUserInput>
  }

  export type RainTipUpdateManyWithWhereWithoutUserInput = {
    where: RainTipScalarWhereInput
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyWithoutUserInput>
  }

  export type RainTipScalarWhereInput = {
    AND?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
    OR?: RainTipScalarWhereInput[]
    NOT?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
    id?: StringFilter<"RainTip"> | string
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: IntFilter<"RainTip"> | number
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
  }

  export type RainWinnerUpsertWithWhereUniqueWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    update: XOR<RainWinnerUpdateWithoutUserInput, RainWinnerUncheckedUpdateWithoutUserInput>
    create: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput>
  }

  export type RainWinnerUpdateWithWhereUniqueWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    data: XOR<RainWinnerUpdateWithoutUserInput, RainWinnerUncheckedUpdateWithoutUserInput>
  }

  export type RainWinnerUpdateManyWithWhereWithoutUserInput = {
    where: RainWinnerScalarWhereInput
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyWithoutUserInput>
  }

  export type RainWinnerScalarWhereInput = {
    AND?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
    OR?: RainWinnerScalarWhereInput[]
    NOT?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
    id?: StringFilter<"RainWinner"> | string
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: IntFilter<"RainWinner"> | number
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
  }

  export type chatmessageUpsertWithWhereUniqueWithoutUserInput = {
    where: chatmessageWhereUniqueInput
    update: XOR<chatmessageUpdateWithoutUserInput, chatmessageUncheckedUpdateWithoutUserInput>
    create: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput>
  }

  export type chatmessageUpdateWithWhereUniqueWithoutUserInput = {
    where: chatmessageWhereUniqueInput
    data: XOR<chatmessageUpdateWithoutUserInput, chatmessageUncheckedUpdateWithoutUserInput>
  }

  export type chatmessageUpdateManyWithWhereWithoutUserInput = {
    where: chatmessageScalarWhereInput
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyWithoutUserInput>
  }

  export type chatmessageScalarWhereInput = {
    AND?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
    OR?: chatmessageScalarWhereInput[]
    NOT?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
    id?: StringFilter<"chatmessage"> | string
    content?: StringFilter<"chatmessage"> | string
    channel?: EnumChatChannelFilter<"chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"chatmessage">
    createdAt?: DateTimeFilter<"chatmessage"> | Date | string
    userId?: StringFilter<"chatmessage"> | string
    roomId?: StringNullableFilter<"chatmessage"> | string | null
  }

  export type friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput = {
    where: friendshipWhereUniqueInput
    update: XOR<friendshipUpdateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_friendIdTouserInput>
    create: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput>
  }

  export type friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput = {
    where: friendshipWhereUniqueInput
    data: XOR<friendshipUpdateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_friendIdTouserInput>
  }

  export type friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput = {
    where: friendshipScalarWhereInput
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserInput>
  }

  export type friendshipScalarWhereInput = {
    AND?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
    OR?: friendshipScalarWhereInput[]
    NOT?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
    id?: StringFilter<"friendship"> | string
    status?: EnumFriendshipStatusFilter<"friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeNullableFilter<"friendship"> | Date | string | null
    userId?: StringFilter<"friendship"> | string
    friendId?: StringFilter<"friendship"> | string
  }

  export type friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput = {
    where: friendshipWhereUniqueInput
    update: XOR<friendshipUpdateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_userIdTouserInput>
    create: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput>
  }

  export type friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput = {
    where: friendshipWhereUniqueInput
    data: XOR<friendshipUpdateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_userIdTouserInput>
  }

  export type friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput = {
    where: friendshipScalarWhereInput
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserInput>
  }

  export type notificationUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
  }

  export type notificationUpdateManyWithWhereWithoutUserInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutUserInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: StringFilter<"notification"> | string
    type?: EnumNotificationTypeFilter<"notification"> | $Enums.NotificationType
    title?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    readAt?: DateTimeNullableFilter<"notification"> | Date | string | null
    metadata?: JsonNullableFilter<"notification">
    createdAt?: DateTimeFilter<"notification"> | Date | string
    userId?: StringFilter<"notification"> | string
  }

  export type OperatorUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OperatorWhereUniqueInput
    update: XOR<OperatorUpdateWithoutOwnerInput, OperatorUncheckedUpdateWithoutOwnerInput>
    create: XOR<OperatorCreateWithoutOwnerInput, OperatorUncheckedCreateWithoutOwnerInput>
  }

  export type OperatorUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OperatorWhereUniqueInput
    data: XOR<OperatorUpdateWithoutOwnerInput, OperatorUncheckedUpdateWithoutOwnerInput>
  }

  export type OperatorUpdateManyWithWhereWithoutOwnerInput = {
    where: OperatorScalarWhereInput
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OperatorScalarWhereInput = {
    AND?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
    OR?: OperatorScalarWhereInput[]
    NOT?: OperatorScalarWhereInput | OperatorScalarWhereInput[]
    id?: StringFilter<"Operator"> | string
    name?: StringFilter<"Operator"> | string
    slug?: StringFilter<"Operator"> | string
    logo?: StringNullableFilter<"Operator"> | string | null
    description?: StringNullableFilter<"Operator"> | string | null
    isActive?: BoolFilter<"Operator"> | boolean
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Operator"> | Date | string | null
    ownerId?: StringFilter<"Operator"> | string
    balance?: IntFilter<"Operator"> | number
  }

  export type ProfileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutUser_profile_userIdTouserInput, ProfileUncheckedUpdateWithoutUser_profile_userIdTouserInput>
    create: XOR<ProfileCreateWithoutUser_profile_userIdTouserInput, ProfileUncheckedCreateWithoutUser_profile_userIdTouserInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutUser_profile_userIdTouserInput, ProfileUncheckedUpdateWithoutUser_profile_userIdTouserInput>
  }

  export type ProfileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: StringFilter<"Profile"> | string
    balance?: IntFilter<"Profile"> | number
    xpEarned?: IntFilter<"Profile"> | number
    isActive?: BoolFilter<"Profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    phpId?: IntNullableFilter<"Profile"> | number | null
    userId?: StringFilter<"Profile"> | string
    currency?: StringFilter<"Profile"> | string
    shopId?: StringFilter<"Profile"> | string
  }

  export type tournamententryUpsertWithWhereUniqueWithoutUserInput = {
    where: tournamententryWhereUniqueInput
    update: XOR<tournamententryUpdateWithoutUserInput, tournamententryUncheckedUpdateWithoutUserInput>
    create: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput>
  }

  export type tournamententryUpdateWithWhereUniqueWithoutUserInput = {
    where: tournamententryWhereUniqueInput
    data: XOR<tournamententryUpdateWithoutUserInput, tournamententryUncheckedUpdateWithoutUserInput>
  }

  export type tournamententryUpdateManyWithWhereWithoutUserInput = {
    where: tournamententryScalarWhereInput
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyWithoutUserInput>
  }

  export type tournamententryScalarWhereInput = {
    AND?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
    OR?: tournamententryScalarWhereInput[]
    NOT?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
    id?: StringFilter<"tournamententry"> | string
    score?: IntFilter<"tournamententry"> | number
    wagered?: IntFilter<"tournamententry"> | number
    won?: IntFilter<"tournamententry"> | number
    joinedAt?: DateTimeFilter<"tournamententry"> | Date | string
    userId?: StringFilter<"tournamententry"> | string
    tournamentId?: StringFilter<"tournamententry"> | string
    profileId?: StringFilter<"tournamententry"> | string
  }

  export type userachievementUpsertWithWhereUniqueWithoutUserInput = {
    where: userachievementWhereUniqueInput
    update: XOR<userachievementUpdateWithoutUserInput, userachievementUncheckedUpdateWithoutUserInput>
    create: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput>
  }

  export type userachievementUpdateWithWhereUniqueWithoutUserInput = {
    where: userachievementWhereUniqueInput
    data: XOR<userachievementUpdateWithoutUserInput, userachievementUncheckedUpdateWithoutUserInput>
  }

  export type userachievementUpdateManyWithWhereWithoutUserInput = {
    where: userachievementScalarWhereInput
    data: XOR<userachievementUpdateManyMutationInput, userachievementUncheckedUpdateManyWithoutUserInput>
  }

  export type VipInfoUpsertWithWhereUniqueWithoutUserInput = {
    where: VipInfoWhereUniqueInput
    update: XOR<VipInfoUpdateWithoutUserInput, VipInfoUncheckedUpdateWithoutUserInput>
    create: XOR<VipInfoCreateWithoutUserInput, VipInfoUncheckedCreateWithoutUserInput>
  }

  export type VipInfoUpdateWithWhereUniqueWithoutUserInput = {
    where: VipInfoWhereUniqueInput
    data: XOR<VipInfoUpdateWithoutUserInput, VipInfoUncheckedUpdateWithoutUserInput>
  }

  export type VipInfoUpdateManyWithWhereWithoutUserInput = {
    where: VipInfoScalarWhereInput
    data: XOR<VipInfoUpdateManyMutationInput, VipInfoUncheckedUpdateManyWithoutUserInput>
  }

  export type VipInfoScalarWhereInput = {
    AND?: VipInfoScalarWhereInput | VipInfoScalarWhereInput[]
    OR?: VipInfoScalarWhereInput[]
    NOT?: VipInfoScalarWhereInput | VipInfoScalarWhereInput[]
    id?: IntFilter<"VipInfo"> | number
    level?: IntFilter<"VipInfo"> | number
    deposit_exp?: IntFilter<"VipInfo"> | number
    bet_exp?: IntFilter<"VipInfo"> | number
    rank_bet_exp?: IntFilter<"VipInfo"> | number
    rank_deposit_exp?: IntFilter<"VipInfo"> | number
    rank_name?: StringFilter<"VipInfo"> | string
    icon?: StringFilter<"VipInfo"> | string
    exp_switch_type?: IntFilter<"VipInfo"> | number
    now_deposit_exp?: StringFilter<"VipInfo"> | string
    level_deposit_exp?: StringFilter<"VipInfo"> | string
    now_bet_exp?: StringFilter<"VipInfo"> | string
    level_bet_exp?: StringFilter<"VipInfo"> | string
    telegram?: StringFilter<"VipInfo"> | string
    is_protection?: BoolFilter<"VipInfo"> | boolean
    protection_deposit_exp?: StringFilter<"VipInfo"> | string
    protection_deposit_amount?: StringFilter<"VipInfo"> | string
    protection_bet_exp?: StringFilter<"VipInfo"> | string
    protection_bet_amount?: StringFilter<"VipInfo"> | string
    protection_days?: IntFilter<"VipInfo"> | number
    protection_switch?: IntFilter<"VipInfo"> | number
    cycle_award_switch?: BoolFilter<"VipInfo"> | boolean
    level_award_switch?: BoolFilter<"VipInfo"> | boolean
    signin_award_switch?: BoolFilter<"VipInfo"> | boolean
    bet_award_switch?: BoolFilter<"VipInfo"> | boolean
    withdrawal_award_switch?: BoolFilter<"VipInfo"> | boolean
    unprotection_deposit_exp?: StringFilter<"VipInfo"> | string
    unprotection_deposit_amount?: StringFilter<"VipInfo"> | string
    unprotection_bet_exp?: StringFilter<"VipInfo"> | string
    unprotection_bet_amount?: StringFilter<"VipInfo"> | string
    unprotection_days?: IntFilter<"VipInfo"> | number
    unprotection_switch?: IntFilter<"VipInfo"> | number
    main_currency?: StringFilter<"VipInfo"> | string
    can_receive_level_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_rank_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_day_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_week_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_month_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_signin_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_bet_award?: BoolFilter<"VipInfo"> | boolean
    can_receive_withdrawal_award?: BoolFilter<"VipInfo"> | boolean
    userid?: StringFilter<"VipInfo"> | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOperatorInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOperatorInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOperatorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOperatorInput, UserUncheckedCreateWithoutOperatorInput>
  }

  export type GameCreateWithoutOperatorInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    gamesession?: gamesessionCreateNestedManyWithoutGameInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutOperatorInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutGameInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutOperatorInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput>
  }

  export type GameCreateManyOperatorInputEnvelope = {
    data: GameCreateManyOperatorInput | GameCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutOperatorInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    user_profile_userIdTouser: UserCreateNestedOneWithoutActiveProfileInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutOperatorInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutOperatorInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput>
  }

  export type ProfileCreateManyOperatorInputEnvelope = {
    data: ProfileCreateManyOperatorInput | ProfileCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type tournamentCreateWithoutOperatorInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionCreateNestedManyWithoutTournamentInput
    tournamententry?: tournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateWithoutOperatorInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentCreateOrConnectWithoutOperatorInput = {
    where: tournamentWhereUniqueInput
    create: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput>
  }

  export type tournamentCreateManyOperatorInputEnvelope = {
    data: tournamentCreateManyOperatorInput | tournamentCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutOperatorInput = {
    id?: string
    title: string
    description: string
    url: string
    type: string
    bonusCode?: string | null
    bonusTotalInCredits?: number | null
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number | null
    isPromo?: boolean | null
    totalDiscountInCents: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOperatorInput = {
    id?: string
    title: string
    description: string
    url: string
    type: string
    bonusCode?: string | null
    bonusTotalInCredits?: number | null
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number | null
    isPromo?: boolean | null
    totalDiscountInCents: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOperatorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput>
  }

  export type ProductCreateManyOperatorInputEnvelope = {
    data: ProductCreateManyOperatorInput | ProductCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOperatorInput = {
    update: XOR<UserUpdateWithoutOperatorInput, UserUncheckedUpdateWithoutOperatorInput>
    create: XOR<UserCreateWithoutOperatorInput, UserUncheckedCreateWithoutOperatorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOperatorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOperatorInput, UserUncheckedUpdateWithoutOperatorInput>
  }

  export type UserUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameUpsertWithWhereUniqueWithoutOperatorInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutOperatorInput, GameUncheckedUpdateWithoutOperatorInput>
    create: XOR<GameCreateWithoutOperatorInput, GameUncheckedCreateWithoutOperatorInput>
  }

  export type GameUpdateWithWhereUniqueWithoutOperatorInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutOperatorInput, GameUncheckedUpdateWithoutOperatorInput>
  }

  export type GameUpdateManyWithWhereWithoutOperatorInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutOperatorInput>
  }

  export type GameScalarWhereInput = {
    AND?: GameScalarWhereInput | GameScalarWhereInput[]
    OR?: GameScalarWhereInput[]
    NOT?: GameScalarWhereInput | GameScalarWhereInput[]
    id?: StringFilter<"Game"> | string
    name?: StringFilter<"Game"> | string
    title?: StringFilter<"Game"> | string
    temperature?: StringNullableFilter<"Game"> | string | null
    developer?: StringNullableFilter<"Game"> | string | null
    vipLevel?: IntNullableFilter<"Game"> | number | null
    isActive?: BoolNullableFilter<"Game"> | boolean | null
    device?: IntNullableFilter<"Game"> | number | null
    featured?: BoolNullableFilter<"Game"> | boolean | null
    gamebank?: StringNullableFilter<"Game"> | string | null
    bet?: FloatNullableFilter<"Game"> | number | null
    denomination?: FloatNullableFilter<"Game"> | number | null
    categoryTemp?: FloatNullableFilter<"Game"> | number | null
    originalId?: IntNullableFilter<"Game"> | number | null
    bids?: IntNullableFilter<"Game"> | number | null
    statIn?: FloatNullableFilter<"Game"> | number | null
    statOut?: FloatNullableFilter<"Game"> | number | null
    currentRtp?: FloatNullableFilter<"Game"> | number | null
    rtpStatIn?: FloatNullableFilter<"Game"> | number | null
    rtpStatOut?: FloatNullableFilter<"Game"> | number | null
    standardRtp?: FloatNullableFilter<"Game"> | number | null
    popularity?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot1?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot2?: FloatNullableFilter<"Game"> | number | null
    chanceFirepot3?: FloatNullableFilter<"Game"> | number | null
    fireCount1?: FloatNullableFilter<"Game"> | number | null
    fireCount2?: FloatNullableFilter<"Game"> | number | null
    fireCount3?: FloatNullableFilter<"Game"> | number | null
    linesPercentConfigSpin?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigSpinBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonus?: StringNullableFilter<"Game"> | string | null
    linesPercentConfigBonusBonus?: StringNullableFilter<"Game"> | string | null
    rezerv?: FloatNullableFilter<"Game"> | number | null
    cask?: FloatNullableFilter<"Game"> | number | null
    advanced?: StringNullableFilter<"Game"> | string | null
    scaleMode?: StringFilter<"Game"> | string
    slotViewState?: StringFilter<"Game"> | string
    view?: IntNullableFilter<"Game"> | number | null
    categoryId?: StringNullableFilter<"Game"> | string | null
    operatorId?: StringNullableFilter<"Game"> | string | null
    providerId?: StringNullableFilter<"Game"> | string | null
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    category?: EnumGameCategoryFilter<"Game"> | $Enums.GameCategory
    jackpotGroupId?: StringNullableFilter<"Game"> | string | null
    active?: BoolFilter<"Game"> | boolean
    password?: StringNullableFilter<"Game"> | string | null
  }

  export type ProfileUpsertWithWhereUniqueWithoutOperatorInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutOperatorInput, ProfileUncheckedUpdateWithoutOperatorInput>
    create: XOR<ProfileCreateWithoutOperatorInput, ProfileUncheckedCreateWithoutOperatorInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutOperatorInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutOperatorInput, ProfileUncheckedUpdateWithoutOperatorInput>
  }

  export type ProfileUpdateManyWithWhereWithoutOperatorInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutOperatorInput>
  }

  export type tournamentUpsertWithWhereUniqueWithoutOperatorInput = {
    where: tournamentWhereUniqueInput
    update: XOR<tournamentUpdateWithoutOperatorInput, tournamentUncheckedUpdateWithoutOperatorInput>
    create: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput>
  }

  export type tournamentUpdateWithWhereUniqueWithoutOperatorInput = {
    where: tournamentWhereUniqueInput
    data: XOR<tournamentUpdateWithoutOperatorInput, tournamentUncheckedUpdateWithoutOperatorInput>
  }

  export type tournamentUpdateManyWithWhereWithoutOperatorInput = {
    where: tournamentScalarWhereInput
    data: XOR<tournamentUpdateManyMutationInput, tournamentUncheckedUpdateManyWithoutOperatorInput>
  }

  export type tournamentScalarWhereInput = {
    AND?: tournamentScalarWhereInput | tournamentScalarWhereInput[]
    OR?: tournamentScalarWhereInput[]
    NOT?: tournamentScalarWhereInput | tournamentScalarWhereInput[]
    id?: StringFilter<"tournament"> | string
    name?: StringFilter<"tournament"> | string
    description?: StringNullableFilter<"tournament"> | string | null
    startTime?: DateTimeFilter<"tournament"> | Date | string
    endTime?: DateTimeFilter<"tournament"> | Date | string
    entryFee?: IntNullableFilter<"tournament"> | number | null
    prizePool?: IntFilter<"tournament"> | number
    isActive?: BoolFilter<"tournament"> | boolean
    createdAt?: DateTimeFilter<"tournament"> | Date | string
    updatedAt?: DateTimeNullableFilter<"tournament"> | Date | string | null
    operatorId?: StringFilter<"tournament"> | string
    leaderboard?: JsonNullableFilter<"tournament">
  }

  export type ProductUpsertWithWhereUniqueWithoutOperatorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutOperatorInput, ProductUncheckedUpdateWithoutOperatorInput>
    create: XOR<ProductCreateWithoutOperatorInput, ProductUncheckedCreateWithoutOperatorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutOperatorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutOperatorInput, ProductUncheckedUpdateWithoutOperatorInput>
  }

  export type ProductUpdateManyWithWhereWithoutOperatorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutOperatorInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    url?: StringFilter<"Product"> | string
    type?: StringFilter<"Product"> | string
    bonusCode?: StringNullableFilter<"Product"> | string | null
    bonusTotalInCredits?: IntNullableFilter<"Product"> | number | null
    priceInCents?: IntFilter<"Product"> | number
    amountToReceiveInCredits?: IntFilter<"Product"> | number
    bestValue?: IntFilter<"Product"> | number
    discountInCents?: IntFilter<"Product"> | number
    bonusSpins?: IntNullableFilter<"Product"> | number | null
    isPromo?: BoolNullableFilter<"Product"> | boolean | null
    totalDiscountInCents?: IntFilter<"Product"> | number
    shopId?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type gamesessionCreateWithoutProfileInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutProfileInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutProfileInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput>
  }

  export type gamesessionCreateManyProfileInputEnvelope = {
    data: gamesessionCreateManyProfileInput | gamesessionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type OperatorCreateWithoutProfilesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentCreateNestedManyWithoutOperatorInput
    Product?: ProductCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutProfilesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    ownerId: string
    balance?: number
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
    Product?: ProductUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutProfilesInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutProfilesInput, OperatorUncheckedCreateWithoutProfilesInput>
  }

  export type UserCreateWithoutActiveProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActiveProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActiveProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActiveProfileInput, UserUncheckedCreateWithoutActiveProfileInput>
  }

  export type tournamententryCreateWithoutProfileInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    tournament: tournamentCreateNestedOneWithoutTournamententryInput
    user: UserCreateNestedOneWithoutTournamententryInput
  }

  export type tournamententryUncheckedCreateWithoutProfileInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    tournamentId: string
  }

  export type tournamententryCreateOrConnectWithoutProfileInput = {
    where: tournamententryWhereUniqueInput
    create: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput>
  }

  export type tournamententryCreateManyProfileInputEnvelope = {
    data: tournamententryCreateManyProfileInput | tournamententryCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutProfileInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gamesession?: gamesessionCreateNestedOneWithoutTransactionInput
    Product?: ProductCreateNestedManyWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutProfileInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    Product?: ProductUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type TransactionCreateOrConnectWithoutProfileInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput>
  }

  export type TransactionCreateManyProfileInputEnvelope = {
    data: TransactionCreateManyProfileInput | TransactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type gamesessionUpsertWithWhereUniqueWithoutProfileInput = {
    where: gamesessionWhereUniqueInput
    update: XOR<gamesessionUpdateWithoutProfileInput, gamesessionUncheckedUpdateWithoutProfileInput>
    create: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput>
  }

  export type gamesessionUpdateWithWhereUniqueWithoutProfileInput = {
    where: gamesessionWhereUniqueInput
    data: XOR<gamesessionUpdateWithoutProfileInput, gamesessionUncheckedUpdateWithoutProfileInput>
  }

  export type gamesessionUpdateManyWithWhereWithoutProfileInput = {
    where: gamesessionScalarWhereInput
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyWithoutProfileInput>
  }

  export type gamesessionScalarWhereInput = {
    AND?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
    OR?: gamesessionScalarWhereInput[]
    NOT?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
    id?: StringFilter<"gamesession"> | string
    startTime?: DateTimeFilter<"gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"gamesession"> | Date | string | null
    betAmount?: IntNullableFilter<"gamesession"> | number | null
    winAmount?: IntNullableFilter<"gamesession"> | number | null
    xpEarned?: IntFilter<"gamesession"> | number
    metadata?: JsonNullableFilter<"gamesession">
    gameId?: StringFilter<"gamesession"> | string
    tournamentId?: StringNullableFilter<"gamesession"> | string | null
    active?: BoolFilter<"gamesession"> | boolean
    profileId?: StringFilter<"gamesession"> | string
  }

  export type OperatorUpsertWithoutProfilesInput = {
    update: XOR<OperatorUpdateWithoutProfilesInput, OperatorUncheckedUpdateWithoutProfilesInput>
    create: XOR<OperatorCreateWithoutProfilesInput, OperatorUncheckedCreateWithoutProfilesInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutProfilesInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutProfilesInput, OperatorUncheckedUpdateWithoutProfilesInput>
  }

  export type OperatorUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUpdateManyWithoutOperatorNestedInput
    Product?: ProductUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type UserUpsertWithoutActiveProfileInput = {
    update: XOR<UserUpdateWithoutActiveProfileInput, UserUncheckedUpdateWithoutActiveProfileInput>
    create: XOR<UserCreateWithoutActiveProfileInput, UserUncheckedCreateWithoutActiveProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActiveProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActiveProfileInput, UserUncheckedUpdateWithoutActiveProfileInput>
  }

  export type UserUpdateWithoutActiveProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActiveProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tournamententryUpsertWithWhereUniqueWithoutProfileInput = {
    where: tournamententryWhereUniqueInput
    update: XOR<tournamententryUpdateWithoutProfileInput, tournamententryUncheckedUpdateWithoutProfileInput>
    create: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput>
  }

  export type tournamententryUpdateWithWhereUniqueWithoutProfileInput = {
    where: tournamententryWhereUniqueInput
    data: XOR<tournamententryUpdateWithoutProfileInput, tournamententryUncheckedUpdateWithoutProfileInput>
  }

  export type tournamententryUpdateManyWithWhereWithoutProfileInput = {
    where: tournamententryScalarWhereInput
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyWithoutProfileInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutProfileInput, TransactionUncheckedUpdateWithoutProfileInput>
    create: XOR<TransactionCreateWithoutProfileInput, TransactionUncheckedCreateWithoutProfileInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutProfileInput, TransactionUncheckedUpdateWithoutProfileInput>
  }

  export type TransactionUpdateManyWithWhereWithoutProfileInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: IntFilter<"Transaction"> | number
    reference?: StringNullableFilter<"Transaction"> | string | null
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"Transaction">
    isRealMoney?: BoolFilter<"Transaction"> | boolean
    paymentMethod?: StringNullableFilter<"Transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"Transaction"> | string | null
    profileId?: StringFilter<"Transaction"> | string
  }

  export type OperatorCreateWithoutGamesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentCreateNestedManyWithoutOperatorInput
    Product?: ProductCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutGamesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    ownerId: string
    balance?: number
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
    Product?: ProductUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutGamesInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutGamesInput, OperatorUncheckedCreateWithoutGamesInput>
  }

  export type gamesessionCreateWithoutGameInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutGameInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: string | null
    active?: boolean
    profileId: string
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutGameInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutGameInput, gamesessionUncheckedCreateWithoutGameInput>
  }

  export type gamesessionCreateManyGameInputEnvelope = {
    data: gamesessionCreateManyGameInput | gamesessionCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type tournamentgameCreateWithoutGameInput = {
    id?: string
    multiplier?: number
    tournament: tournamentCreateNestedOneWithoutTournamentgameInput
  }

  export type tournamentgameUncheckedCreateWithoutGameInput = {
    id?: string
    multiplier?: number
    tournamentId: string
  }

  export type tournamentgameCreateOrConnectWithoutGameInput = {
    where: tournamentgameWhereUniqueInput
    create: XOR<tournamentgameCreateWithoutGameInput, tournamentgameUncheckedCreateWithoutGameInput>
  }

  export type tournamentgameCreateManyGameInputEnvelope = {
    data: tournamentgameCreateManyGameInput | tournamentgameCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type OperatorUpsertWithoutGamesInput = {
    update: XOR<OperatorUpdateWithoutGamesInput, OperatorUncheckedUpdateWithoutGamesInput>
    create: XOR<OperatorCreateWithoutGamesInput, OperatorUncheckedCreateWithoutGamesInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutGamesInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutGamesInput, OperatorUncheckedUpdateWithoutGamesInput>
  }

  export type OperatorUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUpdateManyWithoutOperatorNestedInput
    Product?: ProductUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type gamesessionUpsertWithWhereUniqueWithoutGameInput = {
    where: gamesessionWhereUniqueInput
    update: XOR<gamesessionUpdateWithoutGameInput, gamesessionUncheckedUpdateWithoutGameInput>
    create: XOR<gamesessionCreateWithoutGameInput, gamesessionUncheckedCreateWithoutGameInput>
  }

  export type gamesessionUpdateWithWhereUniqueWithoutGameInput = {
    where: gamesessionWhereUniqueInput
    data: XOR<gamesessionUpdateWithoutGameInput, gamesessionUncheckedUpdateWithoutGameInput>
  }

  export type gamesessionUpdateManyWithWhereWithoutGameInput = {
    where: gamesessionScalarWhereInput
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyWithoutGameInput>
  }

  export type tournamentgameUpsertWithWhereUniqueWithoutGameInput = {
    where: tournamentgameWhereUniqueInput
    update: XOR<tournamentgameUpdateWithoutGameInput, tournamentgameUncheckedUpdateWithoutGameInput>
    create: XOR<tournamentgameCreateWithoutGameInput, tournamentgameUncheckedCreateWithoutGameInput>
  }

  export type tournamentgameUpdateWithWhereUniqueWithoutGameInput = {
    where: tournamentgameWhereUniqueInput
    data: XOR<tournamentgameUpdateWithoutGameInput, tournamentgameUncheckedUpdateWithoutGameInput>
  }

  export type tournamentgameUpdateManyWithWhereWithoutGameInput = {
    where: tournamentgameScalarWhereInput
    data: XOR<tournamentgameUpdateManyMutationInput, tournamentgameUncheckedUpdateManyWithoutGameInput>
  }

  export type tournamentgameScalarWhereInput = {
    AND?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
    OR?: tournamentgameScalarWhereInput[]
    NOT?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
    id?: StringFilter<"tournamentgame"> | string
    multiplier?: FloatFilter<"tournamentgame"> | number
    tournamentId?: StringFilter<"tournamentgame"> | string
    gameId?: StringFilter<"tournamentgame"> | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MemberCreateWithoutOrganizationInput = {
    id?: string
    role: string
    createdAt: Date | string
    user: UserCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role: string
    createdAt: Date | string
  }

  export type MemberCreateOrConnectWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberCreateManyOrganizationInputEnvelope = {
    data: MemberCreateManyOrganizationInput | MemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutOrganizationInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type InvitationCreateOrConnectWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type InvitationCreateManyOrganizationInputEnvelope = {
    data: InvitationCreateManyOrganizationInput | InvitationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type MemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type MemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type InvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutOrganizationInput, InvitationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<InvitationCreateWithoutOrganizationInput, InvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutOrganizationInput, InvitationUncheckedUpdateWithoutOrganizationInput>
  }

  export type InvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
    invitations?: InvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
    invitations?: InvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: InvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    invitations?: InvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutMembersInput = {
    update: XOR<UserUpdateWithoutMembersInput, UserUncheckedUpdateWithoutMembersInput>
    create: XOR<UserCreateWithoutMembersInput, UserUncheckedCreateWithoutMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembersInput, UserUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
    members?: MemberCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug?: string | null
    logo?: string | null
    createdAt: Date | string
    metadata?: string | null
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutInvitationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutInvitationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationUpsertWithoutInvitationsInput = {
    update: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutInvitationsInput = {
    update: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTwofactorsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwofactorsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwofactorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwofactorsInput, UserUncheckedCreateWithoutTwofactorsInput>
  }

  export type UserUpsertWithoutTwofactorsInput = {
    update: XOR<UserUpdateWithoutTwofactorsInput, UserUncheckedUpdateWithoutTwofactorsInput>
    create: XOR<UserCreateWithoutTwofactorsInput, UserUncheckedCreateWithoutTwofactorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwofactorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwofactorsInput, UserUncheckedUpdateWithoutTwofactorsInput>
  }

  export type UserUpdateWithoutTwofactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwofactorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type chatroomCreateWithoutChatmessageInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gamesession?: gamesessionCreateNestedOneWithoutChatroomInput
  }

  export type chatroomUncheckedCreateWithoutChatmessageInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
  }

  export type chatroomCreateOrConnectWithoutChatmessageInput = {
    where: chatroomWhereUniqueInput
    create: XOR<chatroomCreateWithoutChatmessageInput, chatroomUncheckedCreateWithoutChatmessageInput>
  }

  export type UserCreateWithoutChatmessageInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatmessageInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatmessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
  }

  export type chatroomUpsertWithoutChatmessageInput = {
    update: XOR<chatroomUpdateWithoutChatmessageInput, chatroomUncheckedUpdateWithoutChatmessageInput>
    create: XOR<chatroomCreateWithoutChatmessageInput, chatroomUncheckedCreateWithoutChatmessageInput>
    where?: chatroomWhereInput
  }

  export type chatroomUpdateToOneWithWhereWithoutChatmessageInput = {
    where?: chatroomWhereInput
    data: XOR<chatroomUpdateWithoutChatmessageInput, chatroomUncheckedUpdateWithoutChatmessageInput>
  }

  export type chatroomUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamesession?: gamesessionUpdateOneWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutChatmessageInput = {
    update: XOR<UserUpdateWithoutChatmessageInput, UserUncheckedUpdateWithoutChatmessageInput>
    create: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatmessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatmessageInput, UserUncheckedUpdateWithoutChatmessageInput>
  }

  export type UserUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type chatmessageCreateWithoutChatroomInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateWithoutChatroomInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type chatmessageCreateOrConnectWithoutChatroomInput = {
    where: chatmessageWhereUniqueInput
    create: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput>
  }

  export type chatmessageCreateManyChatroomInputEnvelope = {
    data: chatmessageCreateManyChatroomInput | chatmessageCreateManyChatroomInput[]
    skipDuplicates?: boolean
  }

  export type gamesessionCreateWithoutChatroomInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutChatroomInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutChatroomInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutChatroomInput, gamesessionUncheckedCreateWithoutChatroomInput>
  }

  export type chatmessageUpsertWithWhereUniqueWithoutChatroomInput = {
    where: chatmessageWhereUniqueInput
    update: XOR<chatmessageUpdateWithoutChatroomInput, chatmessageUncheckedUpdateWithoutChatroomInput>
    create: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput>
  }

  export type chatmessageUpdateWithWhereUniqueWithoutChatroomInput = {
    where: chatmessageWhereUniqueInput
    data: XOR<chatmessageUpdateWithoutChatroomInput, chatmessageUncheckedUpdateWithoutChatroomInput>
  }

  export type chatmessageUpdateManyWithWhereWithoutChatroomInput = {
    where: chatmessageScalarWhereInput
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyWithoutChatroomInput>
  }

  export type gamesessionUpsertWithoutChatroomInput = {
    update: XOR<gamesessionUpdateWithoutChatroomInput, gamesessionUncheckedUpdateWithoutChatroomInput>
    create: XOR<gamesessionCreateWithoutChatroomInput, gamesessionUncheckedCreateWithoutChatroomInput>
    where?: gamesessionWhereInput
  }

  export type gamesessionUpdateToOneWithWhereWithoutChatroomInput = {
    where?: gamesessionWhereInput
    data: XOR<gamesessionUpdateWithoutChatroomInput, gamesessionUncheckedUpdateWithoutChatroomInput>
  }

  export type gamesessionUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type UserCreateWithoutFriendship_friendship_friendIdTouserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendship_friendship_friendIdTouserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendship_friendship_friendIdTouserInput, UserUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput>
  }

  export type UserCreateWithoutFriendship_friendship_userIdTouserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriendship_friendship_userIdTouserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriendship_friendship_userIdTouserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendship_friendship_userIdTouserInput, UserUncheckedCreateWithoutFriendship_friendship_userIdTouserInput>
  }

  export type UserUpsertWithoutFriendship_friendship_friendIdTouserInput = {
    update: XOR<UserUpdateWithoutFriendship_friendship_friendIdTouserInput, UserUncheckedUpdateWithoutFriendship_friendship_friendIdTouserInput>
    create: XOR<UserCreateWithoutFriendship_friendship_friendIdTouserInput, UserUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendship_friendship_friendIdTouserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendship_friendship_friendIdTouserInput, UserUncheckedUpdateWithoutFriendship_friendship_friendIdTouserInput>
  }

  export type UserUpdateWithoutFriendship_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendship_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFriendship_friendship_userIdTouserInput = {
    update: XOR<UserUpdateWithoutFriendship_friendship_userIdTouserInput, UserUncheckedUpdateWithoutFriendship_friendship_userIdTouserInput>
    create: XOR<UserCreateWithoutFriendship_friendship_userIdTouserInput, UserUncheckedCreateWithoutFriendship_friendship_userIdTouserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriendship_friendship_userIdTouserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriendship_friendship_userIdTouserInput, UserUncheckedUpdateWithoutFriendship_friendship_userIdTouserInput>
  }

  export type UserUpdateWithoutFriendship_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendship_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type chatroomCreateWithoutGamesessionInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: chatmessageCreateNestedManyWithoutChatroomInput
  }

  export type chatroomUncheckedCreateWithoutGamesessionInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type chatroomCreateOrConnectWithoutGamesessionInput = {
    where: chatroomWhereUniqueInput
    create: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput>
  }

  export type chatroomCreateManyGamesessionInputEnvelope = {
    data: chatroomCreateManyGamesessionInput | chatroomCreateManyGamesessionInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutGamesessionInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    operator?: OperatorCreateNestedOneWithoutGamesInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutGamesessionInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    operatorId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutGamesessionInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutGamesessionInput, GameUncheckedCreateWithoutGamesessionInput>
  }

  export type ProfileCreateWithoutGamesessionInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    operator: OperatorCreateNestedOneWithoutProfilesInput
    user_profile_userIdTouser: UserCreateNestedOneWithoutActiveProfileInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutGamesessionInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutGamesessionInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutGamesessionInput, ProfileUncheckedCreateWithoutGamesessionInput>
  }

  export type tournamentCreateWithoutGamesessionInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    operator: OperatorCreateNestedOneWithoutTournamentsInput
    tournamententry?: tournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateWithoutGamesessionInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentCreateOrConnectWithoutGamesessionInput = {
    where: tournamentWhereUniqueInput
    create: XOR<tournamentCreateWithoutGamesessionInput, tournamentUncheckedCreateWithoutGamesessionInput>
  }

  export type TransactionCreateWithoutGamesessionInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    profile: ProfileCreateNestedOneWithoutTransactionsInput
    Product?: ProductCreateNestedManyWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutGamesessionInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    profileId: string
    Product?: ProductUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type TransactionCreateOrConnectWithoutGamesessionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput>
  }

  export type TransactionCreateManyGamesessionInputEnvelope = {
    data: TransactionCreateManyGamesessionInput | TransactionCreateManyGamesessionInput[]
    skipDuplicates?: boolean
  }

  export type chatroomUpsertWithWhereUniqueWithoutGamesessionInput = {
    where: chatroomWhereUniqueInput
    update: XOR<chatroomUpdateWithoutGamesessionInput, chatroomUncheckedUpdateWithoutGamesessionInput>
    create: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput>
  }

  export type chatroomUpdateWithWhereUniqueWithoutGamesessionInput = {
    where: chatroomWhereUniqueInput
    data: XOR<chatroomUpdateWithoutGamesessionInput, chatroomUncheckedUpdateWithoutGamesessionInput>
  }

  export type chatroomUpdateManyWithWhereWithoutGamesessionInput = {
    where: chatroomScalarWhereInput
    data: XOR<chatroomUpdateManyMutationInput, chatroomUncheckedUpdateManyWithoutGamesessionInput>
  }

  export type chatroomScalarWhereInput = {
    AND?: chatroomScalarWhereInput | chatroomScalarWhereInput[]
    OR?: chatroomScalarWhereInput[]
    NOT?: chatroomScalarWhereInput | chatroomScalarWhereInput[]
    id?: StringFilter<"chatroom"> | string
    name?: StringFilter<"chatroom"> | string
    isGameRoom?: BoolFilter<"chatroom"> | boolean
    createdAt?: DateTimeFilter<"chatroom"> | Date | string
    gameSessionId?: StringNullableFilter<"chatroom"> | string | null
  }

  export type GameUpsertWithoutGamesessionInput = {
    update: XOR<GameUpdateWithoutGamesessionInput, GameUncheckedUpdateWithoutGamesessionInput>
    create: XOR<GameCreateWithoutGamesessionInput, GameUncheckedCreateWithoutGamesessionInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutGamesessionInput, GameUncheckedUpdateWithoutGamesessionInput>
  }

  export type GameUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    operator?: OperatorUpdateOneWithoutGamesNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutGameNestedInput
  }

  export type ProfileUpsertWithoutGamesessionInput = {
    update: XOR<ProfileUpdateWithoutGamesessionInput, ProfileUncheckedUpdateWithoutGamesessionInput>
    create: XOR<ProfileCreateWithoutGamesessionInput, ProfileUncheckedCreateWithoutGamesessionInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutGamesessionInput, ProfileUncheckedUpdateWithoutGamesessionInput>
  }

  export type ProfileUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    user_profile_userIdTouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type tournamentUpsertWithoutGamesessionInput = {
    update: XOR<tournamentUpdateWithoutGamesessionInput, tournamentUncheckedUpdateWithoutGamesessionInput>
    create: XOR<tournamentCreateWithoutGamesessionInput, tournamentUncheckedCreateWithoutGamesessionInput>
    where?: tournamentWhereInput
  }

  export type tournamentUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: tournamentWhereInput
    data: XOR<tournamentUpdateWithoutGamesessionInput, tournamentUncheckedUpdateWithoutGamesessionInput>
  }

  export type tournamentUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    operator?: OperatorUpdateOneRequiredWithoutTournamentsNestedInput
    tournamententry?: tournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    tournamententry?: tournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutGamesessionInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutGamesessionInput, TransactionUncheckedUpdateWithoutGamesessionInput>
    create: XOR<TransactionCreateWithoutGamesessionInput, TransactionUncheckedCreateWithoutGamesessionInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutGamesessionInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutGamesessionInput, TransactionUncheckedUpdateWithoutGamesessionInput>
  }

  export type TransactionUpdateManyWithWhereWithoutGamesessionInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutGamesessionInput>
  }

  export type OperatorCreateWithoutProductInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    ownerId: string
    balance?: number
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    tournaments?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutProductInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutProductInput, OperatorUncheckedCreateWithoutProductInput>
  }

  export type TransactionCreateWithoutProductInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gamesession?: gamesessionCreateNestedOneWithoutTransactionInput
    profile: ProfileCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutProductInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId: string
  }

  export type TransactionCreateOrConnectWithoutProductInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput>
  }

  export type OperatorUpsertWithoutProductInput = {
    update: XOR<OperatorUpdateWithoutProductInput, OperatorUncheckedUpdateWithoutProductInput>
    create: XOR<OperatorCreateWithoutProductInput, OperatorUncheckedCreateWithoutProductInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutProductInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutProductInput, OperatorUncheckedUpdateWithoutProductInput>
  }

  export type OperatorUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutProductInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutProductInput, TransactionUncheckedUpdateWithoutProductInput>
    create: XOR<TransactionCreateWithoutProductInput, TransactionUncheckedCreateWithoutProductInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutProductInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutProductInput, TransactionUncheckedUpdateWithoutProductInput>
  }

  export type TransactionUpdateManyWithWhereWithoutProductInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutProductInput>
  }

  export type UserCreateWithoutNotificationInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type gamesessionCreateWithoutTournamentInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    Transaction?: TransactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutTournamentInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    active?: boolean
    profileId: string
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutTournamentInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput>
  }

  export type gamesessionCreateManyTournamentInputEnvelope = {
    data: gamesessionCreateManyTournamentInput | gamesessionCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type OperatorCreateWithoutTournamentsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: number
    owner: UserCreateNestedOneWithoutOperatorInput
    games?: GameCreateNestedManyWithoutOperatorInput
    profiles?: ProfileCreateNestedManyWithoutOperatorInput
    Product?: ProductCreateNestedManyWithoutOperatorInput
  }

  export type OperatorUncheckedCreateWithoutTournamentsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    ownerId: string
    balance?: number
    games?: GameUncheckedCreateNestedManyWithoutOperatorInput
    profiles?: ProfileUncheckedCreateNestedManyWithoutOperatorInput
    Product?: ProductUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type OperatorCreateOrConnectWithoutTournamentsInput = {
    where: OperatorWhereUniqueInput
    create: XOR<OperatorCreateWithoutTournamentsInput, OperatorUncheckedCreateWithoutTournamentsInput>
  }

  export type tournamententryCreateWithoutTournamentInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutTournamententryInput
    user: UserCreateNestedOneWithoutTournamententryInput
  }

  export type tournamententryUncheckedCreateWithoutTournamentInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    profileId: string
  }

  export type tournamententryCreateOrConnectWithoutTournamentInput = {
    where: tournamententryWhereUniqueInput
    create: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput>
  }

  export type tournamententryCreateManyTournamentInputEnvelope = {
    data: tournamententryCreateManyTournamentInput | tournamententryCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type tournamentgameCreateWithoutTournamentInput = {
    id?: string
    multiplier?: number
    game: GameCreateNestedOneWithoutTournamentgameInput
  }

  export type tournamentgameUncheckedCreateWithoutTournamentInput = {
    id?: string
    multiplier?: number
    gameId: string
  }

  export type tournamentgameCreateOrConnectWithoutTournamentInput = {
    where: tournamentgameWhereUniqueInput
    create: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput>
  }

  export type tournamentgameCreateManyTournamentInputEnvelope = {
    data: tournamentgameCreateManyTournamentInput | tournamentgameCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type gamesessionUpsertWithWhereUniqueWithoutTournamentInput = {
    where: gamesessionWhereUniqueInput
    update: XOR<gamesessionUpdateWithoutTournamentInput, gamesessionUncheckedUpdateWithoutTournamentInput>
    create: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput>
  }

  export type gamesessionUpdateWithWhereUniqueWithoutTournamentInput = {
    where: gamesessionWhereUniqueInput
    data: XOR<gamesessionUpdateWithoutTournamentInput, gamesessionUncheckedUpdateWithoutTournamentInput>
  }

  export type gamesessionUpdateManyWithWhereWithoutTournamentInput = {
    where: gamesessionScalarWhereInput
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyWithoutTournamentInput>
  }

  export type OperatorUpsertWithoutTournamentsInput = {
    update: XOR<OperatorUpdateWithoutTournamentsInput, OperatorUncheckedUpdateWithoutTournamentsInput>
    create: XOR<OperatorCreateWithoutTournamentsInput, OperatorUncheckedCreateWithoutTournamentsInput>
    where?: OperatorWhereInput
  }

  export type OperatorUpdateToOneWithWhereWithoutTournamentsInput = {
    where?: OperatorWhereInput
    data: XOR<OperatorUpdateWithoutTournamentsInput, OperatorUncheckedUpdateWithoutTournamentsInput>
  }

  export type OperatorUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutOperatorNestedInput
    games?: GameUpdateManyWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    Product?: ProductUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutTournamentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type tournamententryUpsertWithWhereUniqueWithoutTournamentInput = {
    where: tournamententryWhereUniqueInput
    update: XOR<tournamententryUpdateWithoutTournamentInput, tournamententryUncheckedUpdateWithoutTournamentInput>
    create: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput>
  }

  export type tournamententryUpdateWithWhereUniqueWithoutTournamentInput = {
    where: tournamententryWhereUniqueInput
    data: XOR<tournamententryUpdateWithoutTournamentInput, tournamententryUncheckedUpdateWithoutTournamentInput>
  }

  export type tournamententryUpdateManyWithWhereWithoutTournamentInput = {
    where: tournamententryScalarWhereInput
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyWithoutTournamentInput>
  }

  export type tournamentgameUpsertWithWhereUniqueWithoutTournamentInput = {
    where: tournamentgameWhereUniqueInput
    update: XOR<tournamentgameUpdateWithoutTournamentInput, tournamentgameUncheckedUpdateWithoutTournamentInput>
    create: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput>
  }

  export type tournamentgameUpdateWithWhereUniqueWithoutTournamentInput = {
    where: tournamentgameWhereUniqueInput
    data: XOR<tournamentgameUpdateWithoutTournamentInput, tournamentgameUncheckedUpdateWithoutTournamentInput>
  }

  export type tournamentgameUpdateManyWithWhereWithoutTournamentInput = {
    where: tournamentgameScalarWhereInput
    data: XOR<tournamentgameUpdateManyMutationInput, tournamentgameUncheckedUpdateManyWithoutTournamentInput>
  }

  export type ProfileCreateWithoutTournamententryInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    operator: OperatorCreateNestedOneWithoutProfilesInput
    user_profile_userIdTouser: UserCreateNestedOneWithoutActiveProfileInput
    transactions?: TransactionCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTournamententryInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTournamententryInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTournamententryInput, ProfileUncheckedCreateWithoutTournamententryInput>
  }

  export type tournamentCreateWithoutTournamententryInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionCreateNestedManyWithoutTournamentInput
    operator: OperatorCreateNestedOneWithoutTournamentsInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateWithoutTournamententryInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentCreateOrConnectWithoutTournamententryInput = {
    where: tournamentWhereUniqueInput
    create: XOR<tournamentCreateWithoutTournamententryInput, tournamentUncheckedCreateWithoutTournamententryInput>
  }

  export type UserCreateWithoutTournamententryInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTournamententryInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTournamententryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTournamententryInput, UserUncheckedCreateWithoutTournamententryInput>
  }

  export type ProfileUpsertWithoutTournamententryInput = {
    update: XOR<ProfileUpdateWithoutTournamententryInput, ProfileUncheckedUpdateWithoutTournamententryInput>
    create: XOR<ProfileCreateWithoutTournamententryInput, ProfileUncheckedCreateWithoutTournamententryInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTournamententryInput, ProfileUncheckedUpdateWithoutTournamententryInput>
  }

  export type ProfileUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    user_profile_userIdTouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type tournamentUpsertWithoutTournamententryInput = {
    update: XOR<tournamentUpdateWithoutTournamententryInput, tournamentUncheckedUpdateWithoutTournamententryInput>
    create: XOR<tournamentCreateWithoutTournamententryInput, tournamentUncheckedCreateWithoutTournamententryInput>
    where?: tournamentWhereInput
  }

  export type tournamentUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: tournamentWhereInput
    data: XOR<tournamentUpdateWithoutTournamententryInput, tournamentUncheckedUpdateWithoutTournamententryInput>
  }

  export type tournamentUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUpdateManyWithoutTournamentNestedInput
    operator?: OperatorUpdateOneRequiredWithoutTournamentsNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type UserUpsertWithoutTournamententryInput = {
    update: XOR<UserUpdateWithoutTournamententryInput, UserUncheckedUpdateWithoutTournamententryInput>
    create: XOR<UserCreateWithoutTournamententryInput, UserUncheckedCreateWithoutTournamententryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTournamententryInput, UserUncheckedUpdateWithoutTournamententryInput>
  }

  export type UserUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GameCreateWithoutTournamentgameInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    operator?: OperatorCreateNestedOneWithoutGamesInput
    gamesession?: gamesessionCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutTournamentgameInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    operatorId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutTournamentgameInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutTournamentgameInput, GameUncheckedCreateWithoutTournamentgameInput>
  }

  export type tournamentCreateWithoutTournamentgameInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionCreateNestedManyWithoutTournamentInput
    operator: OperatorCreateNestedOneWithoutTournamentsInput
    tournamententry?: tournamententryCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateWithoutTournamentgameInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentCreateOrConnectWithoutTournamentgameInput = {
    where: tournamentWhereUniqueInput
    create: XOR<tournamentCreateWithoutTournamentgameInput, tournamentUncheckedCreateWithoutTournamentgameInput>
  }

  export type GameUpsertWithoutTournamentgameInput = {
    update: XOR<GameUpdateWithoutTournamentgameInput, GameUncheckedUpdateWithoutTournamentgameInput>
    create: XOR<GameCreateWithoutTournamentgameInput, GameUncheckedCreateWithoutTournamentgameInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutTournamentgameInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutTournamentgameInput, GameUncheckedUpdateWithoutTournamentgameInput>
  }

  export type GameUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    operator?: OperatorUpdateOneWithoutGamesNestedInput
    gamesession?: gamesessionUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: gamesessionUncheckedUpdateManyWithoutGameNestedInput
  }

  export type tournamentUpsertWithoutTournamentgameInput = {
    update: XOR<tournamentUpdateWithoutTournamentgameInput, tournamentUncheckedUpdateWithoutTournamentgameInput>
    create: XOR<tournamentCreateWithoutTournamentgameInput, tournamentUncheckedCreateWithoutTournamentgameInput>
    where?: tournamentWhereInput
  }

  export type tournamentUpdateToOneWithWhereWithoutTournamentgameInput = {
    where?: tournamentWhereInput
    data: XOR<tournamentUpdateWithoutTournamentgameInput, tournamentUncheckedUpdateWithoutTournamentgameInput>
  }

  export type tournamentUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUpdateManyWithoutTournamentNestedInput
    operator?: OperatorUpdateOneRequiredWithoutTournamentsNestedInput
    tournamententry?: tournamententryUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type gamesessionCreateWithoutTransactionInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    game: GameCreateNestedOneWithoutGamesessionInput
    profile: ProfileCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutTransactionInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutTransactionInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutTransactionInput, gamesessionUncheckedCreateWithoutTransactionInput>
  }

  export type ProfileCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    operator: OperatorCreateNestedOneWithoutProfilesInput
    user_profile_userIdTouser: UserCreateNestedOneWithoutActiveProfileInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTransactionsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTransactionsInput, ProfileUncheckedCreateWithoutTransactionsInput>
  }

  export type ProductCreateWithoutTransactionsInput = {
    id?: string
    title: string
    description: string
    url: string
    type: string
    bonusCode?: string | null
    bonusTotalInCredits?: number | null
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number | null
    isPromo?: boolean | null
    totalDiscountInCents: number
    createdAt?: Date | string
    updatedAt?: Date | string
    operator?: OperatorCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTransactionsInput = {
    id?: string
    title: string
    description: string
    url: string
    type: string
    bonusCode?: string | null
    bonusTotalInCredits?: number | null
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number | null
    isPromo?: boolean | null
    totalDiscountInCents: number
    shopId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutTransactionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
  }

  export type gamesessionUpsertWithoutTransactionInput = {
    update: XOR<gamesessionUpdateWithoutTransactionInput, gamesessionUncheckedUpdateWithoutTransactionInput>
    create: XOR<gamesessionCreateWithoutTransactionInput, gamesessionUncheckedCreateWithoutTransactionInput>
    where?: gamesessionWhereInput
  }

  export type gamesessionUpdateToOneWithWhereWithoutTransactionInput = {
    where?: gamesessionWhereInput
    data: XOR<gamesessionUpdateWithoutTransactionInput, gamesessionUncheckedUpdateWithoutTransactionInput>
  }

  export type gamesessionUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type ProfileUpsertWithoutTransactionsInput = {
    update: XOR<ProfileUpdateWithoutTransactionsInput, ProfileUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ProfileCreateWithoutTransactionsInput, ProfileUncheckedCreateWithoutTransactionsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTransactionsInput, ProfileUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProfileUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    user_profile_userIdTouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutTransactionsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTransactionsInput, ProductUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ProductCreateWithoutTransactionsInput, ProductUncheckedCreateWithoutTransactionsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTransactionsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTransactionsInput, ProductUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProductUpdateManyWithWhereWithoutTransactionsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type achievementCreateWithoutUserachievementInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type achievementUncheckedCreateWithoutUserachievementInput = {
    id?: string
    name: string
    description: string
    targetXp: number
    reward?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type achievementCreateOrConnectWithoutUserachievementInput = {
    where: achievementWhereUniqueInput
    create: XOR<achievementCreateWithoutUserachievementInput, achievementUncheckedCreateWithoutUserachievementInput>
  }

  export type UserCreateWithoutUserachievementInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserachievementInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserachievementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserachievementInput, UserUncheckedCreateWithoutUserachievementInput>
  }

  export type achievementUpsertWithoutUserachievementInput = {
    update: XOR<achievementUpdateWithoutUserachievementInput, achievementUncheckedUpdateWithoutUserachievementInput>
    create: XOR<achievementCreateWithoutUserachievementInput, achievementUncheckedCreateWithoutUserachievementInput>
    where?: achievementWhereInput
  }

  export type achievementUpdateToOneWithWhereWithoutUserachievementInput = {
    where?: achievementWhereInput
    data: XOR<achievementUpdateWithoutUserachievementInput, achievementUncheckedUpdateWithoutUserachievementInput>
  }

  export type achievementUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type achievementUncheckedUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutUserachievementInput = {
    update: XOR<UserUpdateWithoutUserachievementInput, UserUncheckedUpdateWithoutUserachievementInput>
    create: XOR<UserCreateWithoutUserachievementInput, UserUncheckedCreateWithoutUserachievementInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserachievementInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserachievementInput, UserUncheckedUpdateWithoutUserachievementInput>
  }

  export type UserUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RainHistoryCreateWithoutRainBetInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainBetInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainBetInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
  }

  export type UserCreateWithoutRainBetInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRainBetInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRainBetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRainBetInput, UserUncheckedCreateWithoutRainBetInput>
  }

  export type RainHistoryUpsertWithoutRainBetInput = {
    update: XOR<RainHistoryUpdateWithoutRainBetInput, RainHistoryUncheckedUpdateWithoutRainBetInput>
    create: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainBetInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainBetInput, RainHistoryUncheckedUpdateWithoutRainBetInput>
  }

  export type RainHistoryUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type UserUpsertWithoutRainBetInput = {
    update: XOR<UserUpdateWithoutRainBetInput, UserUncheckedUpdateWithoutRainBetInput>
    create: XOR<UserCreateWithoutRainBetInput, UserUncheckedCreateWithoutRainBetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRainBetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRainBetInput, UserUncheckedUpdateWithoutRainBetInput>
  }

  export type UserUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RainBetCreateWithoutRainHistoryInput = {
    id?: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
    user: UserCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateWithoutRainHistoryInput = {
    id?: string
    userId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetCreateOrConnectWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    create: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainBetCreateManyRainHistoryInputEnvelope = {
    data: RainBetCreateManyRainHistoryInput | RainBetCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRainHistoryInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRainHistoryInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRainHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRainHistoryInput, UserUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipCreateWithoutRainHistoryInput = {
    id?: string
    tipAmount: number
    tippedAt?: Date | string
    user: UserCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateWithoutRainHistoryInput = {
    id?: string
    userId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainTipCreateOrConnectWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    create: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipCreateManyRainHistoryInputEnvelope = {
    data: RainTipCreateManyRainHistoryInput | RainTipCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type RainWinnerCreateWithoutRainHistoryInput = {
    id?: string
    wonAmount: number
    wonAt?: Date | string
    user: UserCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateWithoutRainHistoryInput = {
    id?: string
    userId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainWinnerCreateOrConnectWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    create: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainWinnerCreateManyRainHistoryInputEnvelope = {
    data: RainWinnerCreateManyRainHistoryInput | RainWinnerCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type RainBetUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    update: XOR<RainBetUpdateWithoutRainHistoryInput, RainBetUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainBetUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    data: XOR<RainBetUpdateWithoutRainHistoryInput, RainBetUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainBetUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainBetScalarWhereInput
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type UserUpsertWithoutRainHistoryInput = {
    update: XOR<UserUpdateWithoutRainHistoryInput, UserUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<UserCreateWithoutRainHistoryInput, UserUncheckedCreateWithoutRainHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRainHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRainHistoryInput, UserUncheckedUpdateWithoutRainHistoryInput>
  }

  export type UserUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RainTipUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    update: XOR<RainTipUpdateWithoutRainHistoryInput, RainTipUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    data: XOR<RainTipUpdateWithoutRainHistoryInput, RainTipUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainTipUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainTipScalarWhereInput
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    update: XOR<RainWinnerUpdateWithoutRainHistoryInput, RainWinnerUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    data: XOR<RainWinnerUpdateWithoutRainHistoryInput, RainWinnerUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainWinnerUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainWinnerScalarWhereInput
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type RainHistoryCreateWithoutRainTipInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: UserCreateNestedOneWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainTipInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainTipInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
  }

  export type UserCreateWithoutRainTipInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRainTipInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRainTipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRainTipInput, UserUncheckedCreateWithoutRainTipInput>
  }

  export type RainHistoryUpsertWithoutRainTipInput = {
    update: XOR<RainHistoryUpdateWithoutRainTipInput, RainHistoryUncheckedUpdateWithoutRainTipInput>
    create: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainTipInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainTipInput, RainHistoryUncheckedUpdateWithoutRainTipInput>
  }

  export type RainHistoryUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type UserUpsertWithoutRainTipInput = {
    update: XOR<UserUpdateWithoutRainTipInput, UserUncheckedUpdateWithoutRainTipInput>
    create: XOR<UserCreateWithoutRainTipInput, UserUncheckedCreateWithoutRainTipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRainTipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRainTipInput, UserUncheckedUpdateWithoutRainTipInput>
  }

  export type UserUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RainHistoryCreateWithoutRainWinnerInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: UserCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainWinnerInput = {
    id?: string
    userId: string
    amount: number
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainWinnerInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
  }

  export type UserCreateWithoutRainWinnerInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRainWinnerInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
    vipInfo?: VipInfoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRainWinnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRainWinnerInput, UserUncheckedCreateWithoutRainWinnerInput>
  }

  export type RainHistoryUpsertWithoutRainWinnerInput = {
    update: XOR<RainHistoryUpdateWithoutRainWinnerInput, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
    create: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainWinnerInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainWinnerInput, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
  }

  export type RainHistoryUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type UserUpsertWithoutRainWinnerInput = {
    update: XOR<UserUpdateWithoutRainWinnerInput, UserUncheckedUpdateWithoutRainWinnerInput>
    create: XOR<UserCreateWithoutRainWinnerInput, UserUncheckedCreateWithoutRainWinnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRainWinnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRainWinnerInput, UserUncheckedUpdateWithoutRainWinnerInput>
  }

  export type UserUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
    vipInfo?: VipInfoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVipInfoInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    members?: MemberCreateNestedManyWithoutUserInput
    invitations?: InvitationCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorCreateNestedManyWithoutUserInput
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: OperatorCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVipInfoInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean | null
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    twoFactorEnabled?: boolean | null
    role?: string | null
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    username: string
    passwordHash?: string | null
    totalXp?: number
    balance?: number
    isVerified?: boolean
    active?: boolean
    lastLogin?: Date | string | null
    lastDailySpin?: Date | string | null
    verificationToken?: string | null
    avatar?: string | null
    activeProfileId?: string | null
    vipInfoId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    members?: MemberUncheckedCreateNestedManyWithoutUserInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutUserInput
    twofactors?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: OperatorUncheckedCreateNestedManyWithoutOwnerInput
    activeProfile?: ProfileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVipInfoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVipInfoInput, UserUncheckedCreateWithoutVipInfoInput>
  }

  export type UserUpsertWithoutVipInfoInput = {
    update: XOR<UserUpdateWithoutVipInfoInput, UserUncheckedUpdateWithoutVipInfoInput>
    create: XOR<UserCreateWithoutVipInfoInput, UserUncheckedCreateWithoutVipInfoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVipInfoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVipInfoInput, UserUncheckedUpdateWithoutVipInfoInput>
  }

  export type UserUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    members?: MemberUpdateManyWithoutUserNestedInput
    invitations?: InvitationUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: OperatorUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVipInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: IntFieldUpdateOperationsInput | number
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastDailySpin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    vipInfoId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    members?: MemberUncheckedUpdateManyWithoutUserNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutUserNestedInput
    twofactors?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: OperatorUncheckedUpdateManyWithoutOwnerNestedInput
    activeProfile?: ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userachievementCreateManyAchievementInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
  }

  export type userachievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type userachievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: string | null
    active?: boolean
    token: string
    updatedAt?: Date | string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type MemberCreateManyUserInput = {
    id?: string
    organizationId: string
    role: string
    createdAt: Date | string
  }

  export type InvitationCreateManyUserInput = {
    id?: string
    organizationId: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
  }

  export type TwoFactorCreateManyUserInput = {
    id?: string
    secret: string
    backupCodes: string
  }

  export type RainBetCreateManyUserInput = {
    id?: string
    rainHistoryId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainHistoryCreateManyUserInput = {
    id?: string
    amount: number
    rainType: string
    createdAt?: Date | string
  }

  export type RainTipCreateManyUserInput = {
    id?: string
    rainHistoryId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainWinnerCreateManyUserInput = {
    id?: string
    rainHistoryId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type chatmessageCreateManyUserInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    roomId?: string | null
  }

  export type friendshipCreateManyUser_friendship_friendIdTouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId: string
  }

  export type friendshipCreateManyUser_friendship_userIdTouserInput = {
    id?: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string | null
    friendId: string
  }

  export type notificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OperatorCreateManyOwnerInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    balance?: number
  }

  export type ProfileCreateManyUser_profile_userIdTouserInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    currency?: string
    shopId: string
  }

  export type tournamententryCreateManyUserInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    tournamentId: string
    profileId: string
  }

  export type userachievementCreateManyUserInput = {
    id?: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    achievementId: string
  }

  export type VipInfoCreateManyUserInput = {
    id?: number
    level: number
    deposit_exp: number
    bet_exp: number
    rank_bet_exp: number
    rank_deposit_exp: number
    rank_name: string
    icon: string
    exp_switch_type: number
    now_deposit_exp: string
    level_deposit_exp: string
    now_bet_exp: string
    level_bet_exp: string
    telegram: string
    is_protection?: boolean
    protection_deposit_exp: string
    protection_deposit_amount: string
    protection_bet_exp: string
    protection_bet_amount: string
    protection_days: number
    protection_switch: number
    cycle_award_switch?: boolean
    level_award_switch?: boolean
    signin_award_switch?: boolean
    bet_award_switch?: boolean
    withdrawal_award_switch?: boolean
    unprotection_deposit_exp: string
    unprotection_deposit_amount: string
    unprotection_bet_exp: string
    unprotection_bet_amount: string
    unprotection_days: number
    unprotection_switch: number
    main_currency: string
    can_receive_level_award?: boolean
    can_receive_rank_award?: boolean
    can_receive_day_award?: boolean
    can_receive_week_award?: boolean
    can_receive_month_award?: boolean
    can_receive_signin_award?: boolean
    can_receive_bet_award?: boolean
    can_receive_withdrawal_award?: boolean
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    token?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
  }

  export type TwoFactorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    backupCodes?: StringFieldUpdateOperationsInput | string
  }

  export type RainBetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom?: chatroomUpdateOneWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatmessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type friendshipUpdateWithoutUser_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_friendship_userIdTouser?: UserUpdateOneRequiredWithoutFriendship_friendship_userIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateWithoutUser_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type friendshipUpdateWithoutUser_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_friendship_friendIdTouser?: UserUpdateOneRequiredWithoutFriendship_friendship_friendIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateWithoutUser_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type notificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
    games?: GameUpdateManyWithoutOperatorNestedInput
    profiles?: ProfileUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUpdateManyWithoutOperatorNestedInput
    Product?: ProductUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
    games?: GameUncheckedUpdateManyWithoutOperatorNestedInput
    profiles?: ProfileUncheckedUpdateManyWithoutOperatorNestedInput
    tournaments?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
    Product?: ProductUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type OperatorUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: IntFieldUpdateOperationsInput | number
  }

  export type ProfileUpdateWithoutUser_profile_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    operator?: OperatorUpdateOneRequiredWithoutProfilesNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUser_profile_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutUser_profile_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTournamententryNestedInput
    tournament?: tournamentUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type tournamententryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievement?: achievementUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type userachievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type VipInfoUpdateWithoutUserInput = {
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    exp_switch_type?: IntFieldUpdateOperationsInput | number
    now_deposit_exp?: StringFieldUpdateOperationsInput | string
    level_deposit_exp?: StringFieldUpdateOperationsInput | string
    now_bet_exp?: StringFieldUpdateOperationsInput | string
    level_bet_exp?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: StringFieldUpdateOperationsInput | string
    protection_deposit_amount?: StringFieldUpdateOperationsInput | string
    protection_bet_exp?: StringFieldUpdateOperationsInput | string
    protection_bet_amount?: StringFieldUpdateOperationsInput | string
    protection_days?: IntFieldUpdateOperationsInput | number
    protection_switch?: IntFieldUpdateOperationsInput | number
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: StringFieldUpdateOperationsInput | string
    unprotection_deposit_amount?: StringFieldUpdateOperationsInput | string
    unprotection_bet_exp?: StringFieldUpdateOperationsInput | string
    unprotection_bet_amount?: StringFieldUpdateOperationsInput | string
    unprotection_days?: IntFieldUpdateOperationsInput | number
    unprotection_switch?: IntFieldUpdateOperationsInput | number
    main_currency?: StringFieldUpdateOperationsInput | string
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VipInfoUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    exp_switch_type?: IntFieldUpdateOperationsInput | number
    now_deposit_exp?: StringFieldUpdateOperationsInput | string
    level_deposit_exp?: StringFieldUpdateOperationsInput | string
    now_bet_exp?: StringFieldUpdateOperationsInput | string
    level_bet_exp?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: StringFieldUpdateOperationsInput | string
    protection_deposit_amount?: StringFieldUpdateOperationsInput | string
    protection_bet_exp?: StringFieldUpdateOperationsInput | string
    protection_bet_amount?: StringFieldUpdateOperationsInput | string
    protection_days?: IntFieldUpdateOperationsInput | number
    protection_switch?: IntFieldUpdateOperationsInput | number
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: StringFieldUpdateOperationsInput | string
    unprotection_deposit_amount?: StringFieldUpdateOperationsInput | string
    unprotection_bet_exp?: StringFieldUpdateOperationsInput | string
    unprotection_bet_amount?: StringFieldUpdateOperationsInput | string
    unprotection_days?: IntFieldUpdateOperationsInput | number
    unprotection_switch?: IntFieldUpdateOperationsInput | number
    main_currency?: StringFieldUpdateOperationsInput | string
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VipInfoUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    deposit_exp?: IntFieldUpdateOperationsInput | number
    bet_exp?: IntFieldUpdateOperationsInput | number
    rank_bet_exp?: IntFieldUpdateOperationsInput | number
    rank_deposit_exp?: IntFieldUpdateOperationsInput | number
    rank_name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    exp_switch_type?: IntFieldUpdateOperationsInput | number
    now_deposit_exp?: StringFieldUpdateOperationsInput | string
    level_deposit_exp?: StringFieldUpdateOperationsInput | string
    now_bet_exp?: StringFieldUpdateOperationsInput | string
    level_bet_exp?: StringFieldUpdateOperationsInput | string
    telegram?: StringFieldUpdateOperationsInput | string
    is_protection?: BoolFieldUpdateOperationsInput | boolean
    protection_deposit_exp?: StringFieldUpdateOperationsInput | string
    protection_deposit_amount?: StringFieldUpdateOperationsInput | string
    protection_bet_exp?: StringFieldUpdateOperationsInput | string
    protection_bet_amount?: StringFieldUpdateOperationsInput | string
    protection_days?: IntFieldUpdateOperationsInput | number
    protection_switch?: IntFieldUpdateOperationsInput | number
    cycle_award_switch?: BoolFieldUpdateOperationsInput | boolean
    level_award_switch?: BoolFieldUpdateOperationsInput | boolean
    signin_award_switch?: BoolFieldUpdateOperationsInput | boolean
    bet_award_switch?: BoolFieldUpdateOperationsInput | boolean
    withdrawal_award_switch?: BoolFieldUpdateOperationsInput | boolean
    unprotection_deposit_exp?: StringFieldUpdateOperationsInput | string
    unprotection_deposit_amount?: StringFieldUpdateOperationsInput | string
    unprotection_bet_exp?: StringFieldUpdateOperationsInput | string
    unprotection_bet_amount?: StringFieldUpdateOperationsInput | string
    unprotection_days?: IntFieldUpdateOperationsInput | number
    unprotection_switch?: IntFieldUpdateOperationsInput | number
    main_currency?: StringFieldUpdateOperationsInput | string
    can_receive_level_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_rank_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_day_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_week_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_month_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_signin_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_bet_award?: BoolFieldUpdateOperationsInput | boolean
    can_receive_withdrawal_award?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GameCreateManyOperatorInput = {
    id?: string
    name: string
    title: string
    temperature?: string | null
    developer?: string | null
    vipLevel?: number | null
    isActive?: boolean | null
    device?: number | null
    featured?: boolean | null
    gamebank?: string | null
    bet?: number | null
    denomination?: number | null
    categoryTemp?: number | null
    originalId?: number | null
    bids?: number | null
    statIn?: number | null
    statOut?: number | null
    currentRtp?: number | null
    rtpStatIn?: number | null
    rtpStatOut?: number | null
    standardRtp?: number | null
    popularity?: number | null
    chanceFirepot1?: number | null
    chanceFirepot2?: number | null
    chanceFirepot3?: number | null
    fireCount1?: number | null
    fireCount2?: number | null
    fireCount3?: number | null
    linesPercentConfigSpin?: string | null
    linesPercentConfigSpinBonus?: string | null
    linesPercentConfigBonus?: string | null
    linesPercentConfigBonusBonus?: string | null
    rezerv?: number | null
    cask?: number | null
    advanced?: string | null
    scaleMode?: string
    slotViewState?: string
    view?: number | null
    categoryId?: string | null
    providerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: $Enums.GameCategory
    jackpotGroupId?: string | null
    active?: boolean
    password?: string | null
  }

  export type ProfileCreateManyOperatorInput = {
    id?: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    phpId?: number | null
    userId: string
    currency?: string
  }

  export type tournamentCreateManyOperatorInput = {
    id?: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: number | null
    prizePool?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductCreateManyOperatorInput = {
    id?: string
    title: string
    description: string
    url: string
    type: string
    bonusCode?: string | null
    bonusTotalInCredits?: number | null
    priceInCents?: number
    amountToReceiveInCredits?: number
    bestValue?: number
    discountInCents?: number
    bonusSpins?: number | null
    isPromo?: boolean | null
    totalDiscountInCents: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: gamesessionUpdateManyWithoutGameNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
    gamesession?: gamesessionUncheckedUpdateManyWithoutGameNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    developer?: NullableStringFieldUpdateOperationsInput | string | null
    vipLevel?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    device?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gamebank?: NullableStringFieldUpdateOperationsInput | string | null
    bet?: NullableFloatFieldUpdateOperationsInput | number | null
    denomination?: NullableFloatFieldUpdateOperationsInput | number | null
    categoryTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    originalId?: NullableIntFieldUpdateOperationsInput | number | null
    bids?: NullableIntFieldUpdateOperationsInput | number | null
    statIn?: NullableFloatFieldUpdateOperationsInput | number | null
    statOut?: NullableFloatFieldUpdateOperationsInput | number | null
    currentRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatIn?: NullableFloatFieldUpdateOperationsInput | number | null
    rtpStatOut?: NullableFloatFieldUpdateOperationsInput | number | null
    standardRtp?: NullableFloatFieldUpdateOperationsInput | number | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot1?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot2?: NullableFloatFieldUpdateOperationsInput | number | null
    chanceFirepot3?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount1?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount2?: NullableFloatFieldUpdateOperationsInput | number | null
    fireCount3?: NullableFloatFieldUpdateOperationsInput | number | null
    linesPercentConfigSpin?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigSpinBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonus?: NullableStringFieldUpdateOperationsInput | string | null
    linesPercentConfigBonusBonus?: NullableStringFieldUpdateOperationsInput | string | null
    rezerv?: NullableFloatFieldUpdateOperationsInput | number | null
    cask?: NullableFloatFieldUpdateOperationsInput | number | null
    advanced?: NullableStringFieldUpdateOperationsInput | string | null
    scaleMode?: StringFieldUpdateOperationsInput | string
    slotViewState?: StringFieldUpdateOperationsInput | string
    view?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumGameCategoryFieldUpdateOperationsInput | $Enums.GameCategory
    jackpotGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    user_profile_userIdTouser?: UserUpdateOneRequiredWithoutActiveProfileNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUpdateManyWithoutTournamentNestedInput
    tournamententry?: tournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableIntFieldUpdateOperationsInput | number | null
    prizePool?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProductUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type gamesessionCreateManyProfileInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
  }

  export type tournamententryCreateManyProfileInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    tournamentId: string
  }

  export type TransactionCreateManyProfileInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
  }

  export type gamesessionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tournamententryUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: tournamentUpdateOneRequiredWithoutTournamententryNestedInput
    user?: UserUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type tournamententryUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesession?: gamesessionUpdateOneWithoutTransactionNestedInput
    Product?: ProductUpdateManyWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    Product?: ProductUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gamesessionCreateManyGameInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: string | null
    active?: boolean
    profileId: string
  }

  export type tournamentgameCreateManyGameInput = {
    id?: string
    multiplier?: number
    tournamentId: string
  }

  export type gamesessionUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournament?: tournamentUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type tournamentgameUncheckedUpdateWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameUncheckedUpdateManyWithoutGameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type MemberCreateManyOrganizationInput = {
    id?: string
    userId: string
    role: string
    createdAt: Date | string
  }

  export type InvitationCreateManyOrganizationInput = {
    id?: string
    email: string
    role?: string | null
    status: string
    expiresAt: Date | string
    inviterId: string
  }

  export type MemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type InvitationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type chatmessageCreateManyChatroomInput = {
    id?: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type chatmessageUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type chatmessageUncheckedUpdateManyWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type chatroomCreateManyGamesessionInput = {
    id?: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
  }

  export type TransactionCreateManyGamesessionInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    profileId: string
  }

  export type chatroomUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: chatmessageUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: chatmessageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateManyWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneRequiredWithoutTransactionsNestedInput
    Product?: ProductUpdateManyWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileId?: StringFieldUpdateOperationsInput | string
    Product?: ProductUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesession?: gamesessionUpdateOneWithoutTransactionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type gamesessionCreateManyTournamentInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: number | null
    winAmount?: number | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    active?: boolean
    profileId: string
  }

  export type tournamententryCreateManyTournamentInput = {
    id?: string
    score?: number
    wagered?: number
    won?: number
    joinedAt?: Date | string
    userId: string
    profileId: string
  }

  export type tournamentgameCreateManyTournamentInput = {
    id?: string
    multiplier?: number
    gameId: string
  }

  export type gamesessionUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    game?: GameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: ProfileUpdateOneRequiredWithoutGamesessionNestedInput
    Transaction?: TransactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableIntFieldUpdateOperationsInput | number | null
    winAmount?: NullableIntFieldUpdateOperationsInput | number | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutTournamententryNestedInput
    user?: UserUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type tournamententryUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: IntFieldUpdateOperationsInput | number
    won?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    game?: GameUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type tournamentgameUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operator?: OperatorUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    bonusCode?: NullableStringFieldUpdateOperationsInput | string | null
    bonusTotalInCredits?: NullableIntFieldUpdateOperationsInput | number | null
    priceInCents?: IntFieldUpdateOperationsInput | number
    amountToReceiveInCredits?: IntFieldUpdateOperationsInput | number
    bestValue?: IntFieldUpdateOperationsInput | number
    discountInCents?: IntFieldUpdateOperationsInput | number
    bonusSpins?: NullableIntFieldUpdateOperationsInput | number | null
    isPromo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalDiscountInCents?: IntFieldUpdateOperationsInput | number
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainBetCreateManyRainHistoryInput = {
    id?: string
    userId: string
    betAmount: number
    odds: number
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainTipCreateManyRainHistoryInput = {
    id?: string
    userId: string
    tipAmount: number
    tippedAt?: Date | string
  }

  export type RainWinnerCreateManyRainHistoryInput = {
    id?: string
    userId: string
    wonAmount: number
    wonAt?: Date | string
  }

  export type RainBetUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: IntFieldUpdateOperationsInput | number
    odds?: IntFieldUpdateOperationsInput | number
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainTipUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: IntFieldUpdateOperationsInput | number
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: IntFieldUpdateOperationsInput | number
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}